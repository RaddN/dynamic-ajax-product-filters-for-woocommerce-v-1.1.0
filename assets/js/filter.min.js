/**
 * Product Filter - Frontend JavaScript
 */
(function ($) {
    'use strict';

    // Configuration options
    const WPC_FILTER = {
        formSelector: '#product-filter',
        productSelector: '.products',
        paginationSelector: 'nav.woocommerce-pagination',
        sortingSelector: 'form.woocommerce-ordering select',
        filterTriggers: 'input[type="checkbox"], input[type="radio"], select, input[type="range"]',
        searchField: '#plugincy-search-field',
        searchButton: '.plugincy-search-submit',
        spinnerClass: 'wpc-spinner',
        loadingClass: 'wpc-loading',
        debounceTime: 500, // ms to wait before processing input changes
        autoScrollOffset: 100
    };
    let count;
    let advancesettings, dapfforwc_options, dapfforwc_seo_permalinks_options, shopPageUrl, isProductArchive, currencySymbol, isHomePage;
    let front_page_slug;
    let debounceTimer;

    // Extract data from configuration objects using destructuring when available
    if (typeof dapfforwc_data !== 'undefined') {
        ({
            dapfforwc_advance_settings: advancesettings,
            dapfforwc_front_page_slug: front_page_slug,
            dapfforwc_options,
            dapfforwc_seo_permalinks_options
        } = dapfforwc_data);
    }

    if (typeof dapfforwc_ajax !== 'undefined') {
        ({
            shopPageUrl,
            isProductArchive,
            currencySymbol,
            isHomePage
        } = dapfforwc_ajax);
    }

    var rfilterbuttonsId = $('.rfilterbuttons').attr('id');



    let product_selector = advancesettings ? advancesettings["product_selector"] ?? 'ul.products' : 'ul.products';
    let productSelector_shortcode = $('#product-filter').data('product_selector');
    let pagination_selector = advancesettings ? advancesettings["pagination_selector"] ?? 'ul.page-numbers' : 'ul.page-numbers';
    let paginationSelector_shortcode = $('#product-filter').data('pagination_selector');

    function attachPaginationEvents() {
        const $form = $(WPC_FILTER.formSelector);
        $(document).on('click', `${paginationSelector_shortcode ?? pagination_selector} a.page-numbers`, function (e) {
            e.preventDefault(); // Prevent the default anchor click behavior
            const url = $(this).attr('href'); // Get the URL from the link
            const fullUrl = new URL(url, window.location.origin); // Ensure a valid URL
            const urlParams = fullUrl.searchParams;
            const page = urlParams.get('paged') || urlParams.get('product-page'); // Extract the page number
            $('#roverlay').show();
            $('#loader').show();
            handleFilterChange($form, page); // Fetch products for the selected page
        });
    }

    // Call this function after updating the product listings
    if ($('#product-filter').length) {
        attachPaginationEvents();
    }

    // Store the current filter state
    let filterState = {
        currentRequest: null,
        isLoading: false,
        pendingChanges: false
    };

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('filters')) {
        count = 1;
        applyFiltersFromUrl(urlParams.get('filters'));
        count = 0;

    }
    /**
     * Initialize the filter functionality
     */
    function initProductFilter() {
        const $form = $(WPC_FILTER.formSelector);

        if ($form.length === 0) {
            return;
        }

        // Bind events to filter elements
        bindFilterEvents($form);

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function (event) {
            // Only handle our own state changes
            if (event.state && event.state.wpcFilter) {
                window.location.reload();
            }
        });

        initSorting();
    }
    // single filter handle
    syncCheckboxSelections();
    function syncCheckboxSelections() {
        const $list = $('.rfilterbuttons ul').empty();
        $('#product-filter #' + rfilterbuttonsId + ' input').each(function () {
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;
            $list.append(createCheckboxListItem(value, checked, type));
        });
        $('#product-filter #' + rfilterbuttonsId + ' option').each(function (index) {
            // Skip the first option (index 0)
            if (index === 0) {
                return; // Skip this iteration
            }
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;

            $list.append(createCheckboxListItem(value, checked, type));
        });
        attachCheckboxClickEvents();
        attachMainFilterChangeEvents();
    }
    function createCheckboxListItem(value, checked, type) {
        const formattedLabel = value.split('-').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        return $('<li></li>').addClass(checked ? 'checked' : '').append(
            $('<input>', {
                name: 'attribute[' + rfilterbuttonsId + '][]',
                id: 'text_' + value,
                type: 'checkbox',
                value: value,
                checked: checked
            }).on('change', syncToMainFilter),
            $('<label></label>', {
                for: 'text_' + value,
                text: formattedLabel
            })
        );
    }

    function syncToMainFilter() {
        $(`#product-filter #${rfilterbuttonsId} input[value="${$(this).val()}"]`).prop('checked', $(this).is(':checked'));
        $(`#product-filter #${rfilterbuttonsId} select option[value="${$(this).val()}"]`).prop('selected', $(this).is(':checked'));
    }

    function attachCheckboxClickEvents() {
        $('.rfilterbuttons ul').off('click', 'li').on('click', 'li', function () {
            const checkbox = $(this).find('input');
            checkbox.prop('checked', !checkbox.is(':checked')).trigger('change');
            $(this).toggleClass('checked', checkbox.is(':checked'));
        });
    }

    function attachMainFilterChangeEvents() {
        $('#' + rfilterbuttonsId + ' input').on('change', function () {
            const relatedCheckbox = $(`.rfilterbuttons ul li input[value="${$(this).val()}"]`);
            relatedCheckbox.prop('checked', $(this).is(':checked')).closest('li').toggleClass('checked', $(this).is(':checked'));
        });
    }

    function store_selected_values() {
        const filtersByType = {};
        $('#product-filter input:checked').each(function () {
            const value = $(this).val();
            const name = $(this).attr('name');
            if (!filtersByType[name]) {
                filtersByType[name] = [];
            }
            filtersByType[name].push(value);
        });
        return filtersByType;
    }

    // create list of current selected filter
    function selectedFilterShowProductTop() {
        // Clear existing content
        $('.rfilterselected ul').empty();
        if (Array.isArray(selectedValesbyuser)) {
            for (let value of selectedValesbyuser) {
                $('.rfilterselected ul').append(`
            <li class="checked">
                <input id="selected_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
            </li>`);
            }
        } else if (typeof selectedValesbyuser === 'object' && selectedValesbyuser !== null) {
            for (let key in selectedValesbyuser) {
                for (let value of selectedValesbyuser[key]) {
                    $('.rfilterselected ul').append(`
                <li class="checked">
                <input id="selected_${key}_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${key}_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
                </li>`);
                }
            }
        }
    }

    // pagination handle

    let selectedValesbyuser = store_selected_values();

    selectedFilterShowProductTop();

    /**
     * Bind events to filter form elements
     */
    function bindFilterEvents($form) {
        // Handle filter changes with debounce
        let debounceTimer;

        // Track checkbox and radio changes
        $form.on('change', WPC_FILTER.filterTriggers, function () {
            clearTimeout(debounceTimer);
            filterState.pendingChanges = true;

            selectedValesbyuser = store_selected_values();

            selectedFilterShowProductTop();

            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, WPC_FILTER.debounceTime);
        });

        $('.rfilterbuttons').on('change', function () {
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });

        // Handle price range inputs
        $form.on('input', 'input[type="range"]', function () {
            updatePriceDisplay($(this));
        });

        // Handle search button click
        $form.on('click', WPC_FILTER.searchButton, function (e) {
            e.preventDefault();
            handleFilterChange($form);
        });

        // Handle search on enter key
        $(WPC_FILTER.searchField).on('keypress', function (e) {
            if (e.which === 13) {
                e.preventDefault();
                handleFilterChange($form);
            }
        });

        // Reset rating filter
        $form.on('click', '#reset-rating', function () {
            const $ratingInputs = $form.find('input[name="rating[]"]');
            $ratingInputs.prop('checked', false);
            handleFilterChange($form);
        });
    }

    $('.rfilterselected').on('change', 'li', function (e) {
        const $form = $(WPC_FILTER.formSelector);
        const value = $(this).find('input[type="checkbox"]').val();
        $(`#product-filter input[value="${value}"]`).prop('checked', false);
        selectedValesbyuser = store_selected_values();
        selectedFilterShowProductTop();
        handleFilterChange($form);
    });

    /**
     * Handle changes to filter form elements
     */
    function handleFilterChange($form, $page = 1) {
        filterState.pendingChanges = false;

        // Check if we're already processing a request
        if (filterState.isLoading) {
            return;
        }

        // Get the serialized form data
        const formData = $form.serialize();

        const product_show_settings = JSON.parse($form.data("product_show_settings"));

        // Access each value
        let perPage = product_show_settings.per_page;          // "5"
        let orderBy = $(WPC_FILTER.sortingSelector).val() === "menu_order" ? product_show_settings.orderby : $(WPC_FILTER.sortingSelector).val();          // "date"
        let order = product_show_settings.order;               // "DESC"
        let operatorSecond = product_show_settings.operator_second; // "in"

        // Build the query URL
        const currentUrl = window.location.href.split('?')[0];
        const queryString = formData.replace(/\+/g, '%20');
        let fullUrl;
        fullUrl = shopPageUrl + (queryString ? '?' + queryString : '');
        if ($page != null) {
            const pageParam = `paged=${$page}`;
            fullUrl += (queryString ? '&' : '?') + pageParam;
        }
        if (!isProductArchive) {
            fullUrl += `&per_page=${perPage}&operator_second=${operatorSecond}&orderby=${orderBy}&order=${order}`;
        }
        loadFilteredContentAjax(fullUrl, formData, currentUrl);
    }

    /**
     * Load filtered content via AJAX
     */
    function loadFilteredContentAjax(url, formData, currentUrl) {
        const $form = $(WPC_FILTER.formSelector);
        // Abort any pending request
        if (filterState.currentRequest) {
            filterState.currentRequest.abort();
        }

        // Set loading state
        setLoadingState(true);

        // Add X-Requested-With header for WordPress to detect AJAX
        filterState.currentRequest = $.ajax({
            url: url,
            data: formData,
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            },
            success: function (response) {
                if (response.success) {
                    if (dapfforwc_options.use_url_filter !== "ajax") {
                        // Update browser history / url with transformed URL if necessary
                        if (dapfforwc_seo_permalinks_options &&
                            dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks !== "on") {
                            let selectedValuesByUser = store_selected_values(); // Assuming this returns an object

                            // Extract values from the object
                            let filtersArray = [];

                            // Loop through the object and collect values
                            for (let key in selectedValuesByUser) {
                                if (Array.isArray(selectedValuesByUser[key])) {
                                    filtersArray.push(...selectedValuesByUser[key]); // Spread values into the filters array
                                }
                            }

                            // Convert to a comma-separated string
                            let filters = filtersArray.join(',');
                            let searchval = $("input#plugincy-search-field").val();

                            // Construct the new URL
                            let url = currentUrl + `?filters=${filters}` + (searchval && searchval !== '' ? '&title=' + searchval : '');

                            // Update the browser history
                            window.history.pushState({ wpcFilter: true }, '', url);
                        }
                        if (dapfforwc_seo_permalinks_options &&
                            dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks === "on") {
                            url = currentUrl + url.substring(url.indexOf('?'));
                            // Transform the URL to SEO format
                            let seoUrl = transformToSeoUrl(url, dapfforwc_seo_permalinks_options).replace(/%2C/g, ',');

                            // Update the browser history
                            window.history.pushState({ wpcFilter: true }, '', seoUrl);
                        }
                    }

                    // Update the products container
                    $(productSelector_shortcode ?? product_selector).html(response.data.html);
                    $(paginationSelector_shortcode ?? pagination_selector).html(response.data.pagination);
                    if (dapfforwc_options["update_filter_options"] === "on") {
                        $form.html(response.data.updated_form);
                    }


                    // Update product count if element exists
                    if ($('.woocommerce-result-count').length) {
                        $('.woocommerce-result-count').text('Showing 1-' +
                            Math.min(response.data.found, 12) + ' of ' + response.data.found + ' results');
                    }

                    selectedFilterShowProductTop();
                    syncCheckboxSelections();
                    initPriceRangeInputs();

                    // Auto-scroll to products container                
                    scrollToProducts();

                    // Trigger events for other scripts
                    $(document).trigger('wpc_filters_updated');
                    $(window).trigger('scroll');
                    $(window).trigger('resize');

                } else {
                    console.error('Filter request failed');
                }
            },
            error: function (xhr, status, error) {
                if (status !== 'abort') {
                    console.error('Filter request failed:', error);
                }
            },
            complete: function () {
                setLoadingState(false);
                filterState.currentRequest = null;
            }
        });
    }

    /**
     * Initialize sorting functionality
     */
    function initSorting() {
        // Prevent form submission on pressing Enter
        $('.woocommerce-ordering').on('submit', function (event) {
            event.preventDefault();
        });
        $(document).on('change', WPC_FILTER.sortingSelector, function (e) {
            e.preventDefault();

            const sortValue = $(this).val();

            // Create or update the orderby hidden input in the filter form
            let $orderbyInput = $('#filter-orderby');
            if ($orderbyInput.length === 0) {
                $orderbyInput = $('<input>').attr({
                    type: 'hidden',
                    id: 'filter-orderby',
                    name: 'orderby',
                    value: sortValue
                });
                $(WPC_FILTER.formSelector).append($orderbyInput);
            } else {
                $orderbyInput.val(sortValue);
            }

            // Reset to page 1 when sorting changes
            let $pageInput = $('#filter-page-num');
            if ($pageInput.length) {
                $pageInput.val(1);
            }

            // Trigger filter change with the new sort order
            handleFilterChange($(WPC_FILTER.formSelector));
        });
    }

    /**
     * Set loading state
     */
    function setLoadingState(isLoading) {
        filterState.isLoading = isLoading;
        let isloadingenablebyadmin = dapfforwc_options.show_loader === "on";

        if (isLoading && isloadingenablebyadmin) {
            $('html, body').css('cursor', 'wait');
            showSpinner();
            $(WPC_FILTER.formSelector).addClass(WPC_FILTER.loadingClass);
        } else {
            $('html, body').css('cursor', 'auto');
            hideSpinner();
            $(WPC_FILTER.formSelector).removeClass(WPC_FILTER.loadingClass);
        }
    }

    /**
     * Show loading spinner
     */
    function showSpinner() {
        if (count !== 1) {
            $('#roverlay').show();
            $('#loader').show();
        }
    }

    /**
     * Hide loading spinner
     */
    function hideSpinner() {
        $('#roverlay').hide();
        $('#loader').hide();
    }

    /**
     * Update price range display
     */
    function updatePriceDisplay($rangeInput) {
        const isMin = $rangeInput.hasClass('range-min');
        const value = parseInt($rangeInput.val());
        const $minInput = $('.range-min');
        const $maxInput = $('.range-max');

        const minValue = parseInt($minInput.val()) || 0;
        const maxValue = parseInt($maxInput.val()) || 0;
        const minPriceDefault = parseInt($minInput.attr('min')) || 0;
        const maxPriceDefault = parseInt($maxInput.attr('max')) || 100;

        if (isMin) {
            $('#min-price').val(value);
            $('.progress').css('left', ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100) + '%');
        } else {
            $('#max-price').val(value);
            $('.progress').css('right', (100 - (value / maxPriceDefault * 100)) + '%');
        }

        // Update price display using custom pseudo-element content
        changePseudoElementContent(`${minValue}`, `${maxValue}`, isMin ? 'min' : 'max');

        // Also update the aria-valuetext for accessibility
        if (isMin) {
            $rangeInput.attr('aria-valuetext', `${value}`);
        } else {
            $rangeInput.attr('aria-valuetext', `${value}`);
        }
    }

    function changePseudoElementContent(minValue, maxValue, activeHandle = null) {
        // Create a style element if it doesn't exist
        let styleEl = document.getElementById('price-range-display-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'price-range-display-style';
            document.head.appendChild(styleEl);
        }

        // Set z-index based on which handle is active
        const minZIndex = activeHandle === 'min' ? 10 : 5;
        const maxZIndex = activeHandle === 'max' ? 10 : 5;

        // Update the content of the style element using the product-filter specific selectors
        styleEl.textContent = `
            #product-filter .progress-percentage:before {
                content: "${currencySymbol} ${minValue}";
                z-index: ${minZIndex};
            }
            #product-filter .progress-percentage:after {
                content: "${currencySymbol} ${maxValue}";
                z-index: ${maxZIndex};
            }
        `;
    }


    function initPriceRangeInputs() {
        const $rangeInputs = $(".range-input input");
        const $priceInputs = $(".price-input input");
        const $range = $(".slider .progress");

        if ($rangeInputs.length < 2 || $priceInputs.length < 2) return;

        let minPrice = parseInt($rangeInputs[0].value) || 0;
        let maxPrice = parseInt($rangeInputs[1].value) || 0;
        const minPriceDefault = parseInt($rangeInputs[0].getAttribute('min')) || 0;
        const maxPriceDefault = parseInt($rangeInputs[0].getAttribute('max')) || 100;

        $range.css({
            'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
            'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
        });

        // Initialize price display
        changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

        // Handle range input changes
        $rangeInputs.on("input", function () {
            const isMin = $(this).hasClass('range-min');
            minPrice = parseInt($rangeInputs.eq(0).val()) || 0;
            maxPrice = parseInt($rangeInputs.eq(1).val()) || 0;

            changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

            $priceInputs.eq(0).val(minPrice);
            $priceInputs.eq(1).val(maxPrice);

            $range.css({
                'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
                'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
            });

            // Trigger debounced filter update
            const $form = $(WPC_FILTER.formSelector);
            filterState.pendingChanges = true;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, WPC_FILTER.debounceTime);
        });

        // Handle direct price input changes
        $priceInputs.on("input", function () {
            const isMin = $(this).hasClass('input-min');
            let minVal = parseInt($priceInputs.eq(0).val()) || 0;
            let maxVal = parseInt($priceInputs.eq(1).val()) || 0;

            // Ensure min <= max
            if (isMin) {
                minVal = Math.min(minVal, maxVal);
                $priceInputs.eq(0).val(minVal);
                $rangeInputs.eq(0).val(minVal);
                $range.css('left', ((minVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%");
            } else {
                maxVal = Math.max(minVal, maxVal);
                $priceInputs.eq(1).val(maxVal);
                $rangeInputs.eq(1).val(maxVal);
                $range.css('right', 100 - (maxVal / maxPriceDefault) * 100 + "%");
            }

            changePseudoElementContent(`${minVal}`, `${maxVal}`);
        });

        // Update filter on price input blur
        $priceInputs.on("blur", function () {
            const $form = $(WPC_FILTER.formSelector);
            handleFilterChange($form);
        });
    }


    /**
     * Scroll to products container
     */
    function scrollToProducts() {
        const $target = $(productSelector_shortcode ?? product_selector);

        if ($target.length > 0) {
            $('html, body').animate({
                scrollTop: $target.offset().top - WPC_FILTER.autoScrollOffset
            }, 500);
        }
    }


    function applyFiltersFromUrl(filtersString) {
        // Check if we're using the new format with attribute types in permalinks
        const urlParams = new URLSearchParams(window.location.search);
        const useNewFormat = urlParams.get('filters') === '1';
        const $form = $(WPC_FILTER.formSelector);

        const attrprefix = dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options;

        if (!useNewFormat) {
            for (const [key, value] of urlParams.entries()) {
                if (key === 'title') {
                    $("input#plugincy-search-field").val(value);
                    break;
                }
            }
            // Original implementation for simple filter string
            if (!filtersString) {
                const newUrl = `/${currentPage}/`;
                history.replaceState(null, '', newUrl);
                handleFilterChange($form);
                return;
            }

            const filterValues = filtersString.split(',').map(value => value.trim());
            filterValues.forEach(value => {
                if ($(`input[value="${value}"]`).length) {
                    $(`input[value="${value}"]`).prop('checked', true);
                } else if ($(`select option[value="${value}"]`).length) {
                    $(`select option[value="${value}"]`).prop('selected', true);
                }
            });

            handleFilterChange($form);
            return;
        }

        // New implementation for attribute type permalinks
        // Process each parameter in the URL
        // Reverse map the prefixes to attribute names for lookup
        const prefixToAttribute = {};
        // Handle category and tag directly
        prefixToAttribute[attrprefix["product-category"]] = "cata";
        prefixToAttribute[attrprefix.tag] = 'tag';
        prefixToAttribute[attrprefix.price] = 'price';
        prefixToAttribute[attrprefix.rating] = 'rating';

        // Handle all product attributes
        if (attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }

        for (const [key, value] of urlParams.entries()) {
            if (key === 'title') {
                $("input#plugincy-search-field").val(value);
            }
            if (key === 'filters' || key === 'title') continue; // Skip the format flag and search parameter

            // Split comma-separated values
            const values = value.split(',').map(v => v.trim());

            // Find the attribute name this prefix corresponds to
            const attributeName = prefixToAttribute[key];

            if (attributeName) {

                values.forEach(val => {
                    // Look for inputs that have name containing the attribute and value matching the value
                    const $inputs = $form.find(`input[name*="${attributeName}"][value="${val}"]`);
                    if ($inputs.length) {
                        $inputs.prop('checked', true);
                    }

                    // Handle select elements
                    const $options = $form.find(`select[name*="${attributeName}"] option[value="${val}"]`);
                    if ($options.length) {
                        $options.prop('selected', true);
                    }

                    // Handle price range specially if needed
                    if (attributeName === 'price' && val.includes('-')) {
                        const [min, max] = val.split('-');
                        const $minInput = $form.find('input.wpc-filters-range-min');
                        const $maxInput = $form.find('input.wpc-filters-range-max');

                        if ($minInput.length && $maxInput.length) {
                            $minInput.val(min);
                            $maxInput.val(max);
                        }
                    }
                });
            }
        }

        // Trigger filter change event to update the UI
        handleFilterChange($form);
    }


    /**
     * Transform standard filter URL to SEO-friendly URL format
     * @param {string} url - The original URL with standard filter parameters
     * @param {object} seoOptions - The SEO permalink configuration options
     * @returns {string} - The transformed SEO-friendly URL
     */
    function transformToSeoUrl(url, seoOptions) {
        // Parse the current URL
        const urlObj = new URL(url);
        const searchParams = urlObj.searchParams;

        // Create new URLSearchParams for our SEO-friendly URL
        const seoParams = new URLSearchParams();
        seoParams.append('filters', '1'); // Add the filters=1 parameter

        // Prefixes config from SEO options
        const prefixes = seoOptions.dapfforwc_permalinks_prefix_options;

        // Process category parameters
        if (searchParams.has("product-category[]")) {
            const categories = searchParams.getAll("product-category[]");
            if (categories.length > 0) {
                const catakey = (prefixes && ["product-category"]) ?? "cata";
                seoParams.append(catakey, categories.join(','));
            }
        }

        // Process tag parameters
        if (searchParams.has('tags[]')) {
            const tags = searchParams.getAll('tags[]');
            if (tags.length > 0) {
                seoParams.append(prefixes.tag, tags.join(','));
            }
        }

        // Process rating parameters
        if (searchParams.has('rating[]')) {
            const ratings = searchParams.getAll('rating[]');
            if (ratings.length > 0) {
                seoParams.append(prefixes.rating, ratings.join(','));
            }
        }

        // Process price parameters
        if (searchParams.has('min_price') || searchParams.has('max_price')) {
            const minPrice = searchParams.get('min_price') || '';
            const maxPrice = searchParams.get('max_price') || '';
            if (minPrice || maxPrice) {
                const priceKey = (prefixes && prefixes.price) ?? "price";
                seoParams.append(priceKey, `${minPrice}-${maxPrice}`);
            }
        }
        // Process search parameter
        if (searchParams.has('s') && searchParams.get('s') !== '') {
            seoParams.append('title', searchParams.get('s'));
        }

        // Process attribute parameters
        const attributeParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an attribute parameter
            if (key.startsWith('attribute[') && key.endsWith('][]')) {
                // Extract attribute name, e.g., 'attribute[brand][]' -> 'brand'
                const attributeName = key.replace('attribute[', '').replace('][]', '');

                if (!attributeParams[attributeName]) {
                    attributeParams[attributeName] = [];
                }
                attributeParams[attributeName].push(value);
            }
        }

        // Add attribute parameters with their SEO prefix
        for (const [attributeName, values] of Object.entries(attributeParams)) {
            if (prefixes?.attribute?.[attributeName]) {
                seoParams.append(prefixes.attribute[attributeName], values.join(','));
            }
        }

        // Build the new URL
        const baseUrl = urlObj.origin + urlObj.pathname;
        const seoQueryString = seoParams.toString();

        return baseUrl + (seoQueryString ? '?' + seoQueryString : '');
    }

    // Initialize on document ready
    $(document).ready(function () {
        initProductFilter();
        initPriceRangeInputs();
    });

    // Expose public API
    window.WPC_FILTER_API = {
        refresh: function () {
            handleFilterChange($(WPC_FILTER.formSelector));
        },
        reset: function () {
            const $form = $(WPC_FILTER.formSelector);
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select').prop('selectedIndex', 0);
            $form.find('input[type="text"], input[type="search"]').val('');

            // Reset price range sliders
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                $minRange.val($minRange.attr('min'));
                $maxRange.val($maxRange.attr('max'));
                updatePriceDisplay($minRange);
                updatePriceDisplay($maxRange);
            }

            handleFilterChange($form);
        }
    };

})(jQuery);

// cateogry hide & show manage for herichical
jQuery(document).ready(function ($) {
    $('.show-sub-cata').on('click', function (event) {
        event.preventDefault();
        const $childCategories = $(this).closest('div').next('.child-categories');
        $childCategories.slideToggle(() => {
            $(this).text($childCategories.is(':visible') ? '-' : '+');
        });
    });
});