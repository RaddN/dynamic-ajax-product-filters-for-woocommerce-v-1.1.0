/**
 * Product Filter - Frontend JavaScript
 */
(function ($) {
    'use strict';

    // Configuration options
    const dapfforwc_FILTER = {
        formSelector: '#product-filter',
        productSelector: '.products',
        paginationSelector: 'nav.woocommerce-pagination',
        sortingSelector: 'form.woocommerce-ordering select',
        filterTriggers: 'input[type="checkbox"], input[type="radio"], select, input[type="range"]',
        searchField: '#plugincy-search-field',
        searchButton: '.plugincy-search-submit',
        spinnerClass: 'dapfforwc-spinner',
        loadingClass: 'dapfforwc-loading',
        debounceTime: 500, // ms to wait before processing input changes
        autoScrollOffset: 100
    };
    window.re_initSelect2_Collaps = function () {
        // these will be no-ops until theyâ€™re defined later,
        // but once the later ready block runs it will overwrite this body.
    };
    let count;
    let advancesettings, dapfforwc_options, dapfforwc_seo_permalinks_options, dapfforwc_styleoptions, shopPageUrl, isProductArchive, currencySymbol, isHomePage;
    let front_page_slug;
    let debounceTimer;
    let lastMirrorSig = '';
    let lastPriceLabel = '';

    const DEBOUNCE_MS = Math.max(180, Math.min(dapfforwc_FILTER.debounceTime || 500, 400)); // clamp ~180-400ms
    let globalDebounceTimer = null;

    const plugincyResponseCache = new Map();
    const CACHE_MAX = 25;




    function debounceRun(fn) {
        clearTimeout(globalDebounceTimer);
        globalDebounceTimer = setTimeout(fn, DEBOUNCE_MS);
    }

    // Extract data from configuration objects using destructuring when available
    if (typeof dapfforwc_data !== 'undefined') {
        ({
            dapfforwc_advance_settings: advancesettings,
            dapfforwc_front_page_slug: front_page_slug,
            dapfforwc_options,
            dapfforwc_seo_permalinks_options,
            dapfforwc_styleoptions
        } = dapfforwc_data);
    }

    if (typeof dapfforwc_ajax !== 'undefined') {
        ({
            shopPageUrl,
            isProductArchive,
            currencySymbol,
            isHomePage
        } = dapfforwc_ajax);
    }

    if (typeof plugincydebugLog === 'function') {

        plugincydebugLog("Form Manage Settings : ", dapfforwc_options);
        plugincydebugLog("Form Style Settings : ", dapfforwc_styleoptions);
        plugincydebugLog("SEO setup Settings : ", dapfforwc_seo_permalinks_options);
        plugincydebugLog("Advanced Settings : ", advancesettings);
    }


    const escapeHtml = (value) => String(value ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
    }[c]));

    const DEFAULT_TEXTS = {
        no_products: 'No products were found matching your selection.',
        select2_placeholder: 'Select Options',
    };

    const TEXTS = {
        no_products: advancesettings && advancesettings.no_products_text ? advancesettings.no_products_text : DEFAULT_TEXTS.no_products,
        select2_placeholder: advancesettings && advancesettings.select2_placeholder ? advancesettings.select2_placeholder : DEFAULT_TEXTS.select2_placeholder,
    };

    const DEFAULT_MOBILE_BREAKPOINT = 768;
    const MOBILE_BREAKPOINT = (function () {
        const localized = (typeof dapfforwc_data !== "undefined" && dapfforwc_data.mobile_breakpoint)
            ? parseInt(dapfforwc_data.mobile_breakpoint, 10)
            : NaN;
        const advanced = advancesettings && advancesettings.mobile_breakpoint ? parseInt(advancesettings.mobile_breakpoint, 10) : NaN;
        if (!isNaN(localized) && localized > 0) return localized;
        if (!isNaN(advanced) && advanced > 0) return advanced;
        return DEFAULT_MOBILE_BREAKPOINT;
    })();
    window.__dapfforwc_mobile_bp = MOBILE_BREAKPOINT;

    var rfilterbuttonsId = $('.rfilterbuttons').attr('id');

    let collapsedWidgetState = new Map(); // Store widget collapse states

    /**
     * Determines the appropriate product selector based on priority order:
     * 1. Shortcode-defined selector
     * 2. Global settings selector
     * 3. Custom class selectors (fallback options)
     * 
     * @returns {string} The product selector string
     */
    function getProductSelector() {
        const DEFAULT_SELECTOR = '.products';

        // Check if shortcode defines a custom selector
        const formElement = $(dapfforwc_FILTER.formSelector);
        const shortcodeSelector = formElement.data('product_selector');

        const validPatterns = [
            /^[a-zA-Z][a-zA-Z0-9\-_]*$/,                    // Element
            /^\.[a-zA-Z][a-zA-Z0-9\-_]*$/,                  // Class
            /^#[a-zA-Z][a-zA-Z0-9\-_]*$/,                   // ID
            /^\[[a-zA-Z][a-zA-Z0-9\-_]*(\=[^\]]+)?\]$/,     // Attribute
            /^[a-zA-Z0-9\s\.\#\[\]\=\:\-\_\,\>\+\~\*\(\)]+$/ // Complex
        ];

        let isValidSelector = shortcodeSelector ? validPatterns.some(pattern => pattern.test(shortcodeSelector)) : false;
        if (!isValidSelector && shortcodeSelector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        if (isValidSelector && $(shortcodeSelector).length > 0) {
            return shortcodeSelector;
        }


        isValidSelector = advancesettings &&
            advancesettings.product_selector ? validPatterns.some(pattern => pattern.test(advancesettings.product_selector)) : false;
        if (!isValidSelector && advancesettings &&
            advancesettings.product_selector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        // Check global settings for custom selector
        if (isValidSelector &&
            $(advancesettings.product_selector).length > 0) {
            return advancesettings.product_selector;
        }

        // Fallback to custom class selectors in priority order
        const fallbackSelectors = [
            '.plugincy-filter-products'
        ];

        for (let i = 0; i < fallbackSelectors.length; i++) {
            const selector = fallbackSelectors[i];
            if ($(selector).length > 0) {
                return selector;
            }
        }

        // Final fallback: find parent of plugincy-filter-product-item
        const productItemElement = $('.plugincy-filter-product-item');
        if (productItemElement.length > 0) {
            const parentElement = productItemElement.parent();
            if (parentElement.length > 0) {
                const parentTag = parentElement.get(0).tagName.toLowerCase();
                const parentClass = parentElement.attr('class');
                const parentId = parentElement.attr('id');

                let parentSelector = parentTag;
                if (parentId) {
                    parentSelector = `#${parentId}`;
                } else if (parentClass) {
                    parentSelector = `${parentTag}.${parentClass.split(' ').join('.')}`;
                }
                return parentSelector;
            }
        }
        return DEFAULT_SELECTOR;
    }

    window.getProductSelector = $(getProductSelector()).length > 0;
    window.getProductSelectorString = getProductSelector();

    const product_selector = getProductSelector();

    const PAGINATION_INTERACTIVE_TARGETS = 'a, button, span, [role="button"], [data-page], [data-pagination], [data-next-page], [data-page-url], [data-url], [data-load-page], [data-target-page], [data-goto], .load-more-button, .plugincy-load-more, .woocommerce-load-more, .infinite-scroll-trigger, .jet-load-more__link, .elementor-pagination__link, .page-numbers li';
    const LOAD_MORE_CLASS_HINTS = [
        'load-more',
        'loadmore',
        'load_more',
        'plugincy-load-more',
        'plugincy_load_more',
        'woocommerce-load-more',
        'products-load-more',
        'products_load_more',
        'ajax-load-more',
        'infinite-scroll',
        'infinite_scroll',
        'infinite-scroll-trigger',
        'infinite_scroll_trigger',
        'jet-load-more',
        'jet_load_more',
        'elementor-load-more',
        'elementor_load_more',
        'yith-infs',
        'yith-wcan',
        'wcl-load-more',
        'flatsome-load-more',
        'astra-load-more',
        'woodmart-load-more'
    ];
    const LOAD_MORE_DATA_HINTS = [
        'load',
        'append',
        'infinite',
        'lazy',
        'next',
        'more',
        'scroll'
    ];
    const LOAD_MORE_WRAPPER_HINTS = [
        '.plugincy-load-more-wrapper',
        '.plugincy-load-more',
        '.woocommerce-load-more',
        '.products-load-more',
        '.load-more',
        '.loadmore',
        '.infinite-scroll',
        '.infinite-scroll-trigger',
        '.jet-load-more',
        '.jet-woo-builder__load-more',
        '.yith-wcan-infinite-scroll',
        '.yith-wcan-load-more',
        '.wcl-load-more',
        '.elementor-pagination',
        '.elementor-load-more',
        '.woolentor-load-more',
        '.flatsome-load-more'
    ];
    const LOAD_MORE_TEXT_HINTS = [
        'load more',
        'show more',
        'view more',
        'more products',
        'more items',
        'more results',
        'more goods',
        'more posts',
        'next page',
        'next products',
        'next items'
    ];
    const AUTO_SCROLL_CLASS_HINTS = [
        'infinite-scroll',
        'infinite_scroll',
        'infinite-scroll-trigger',
        'infinite_scroll_trigger'
    ];
    const AUTO_SCROLL_DATA_HINTS = [
        'scroll',
        'infinite',
        'auto'
    ];
    const AUTO_SCROLL_ATTR_NAMES = [
        'data-pagination',
        'data-pagination-mode',
        'data-pagination-type',
        'data-pagination-behavior',
        'data-behavior',
        'data-behaviour',
        'data-mode',
        'data-trigger',
        'data-load'
    ];
    const PAGINATION_TOTAL_DATA_ATTRS = [
        'total-pages',
        'totalPages',
        'max-pages',
        'maxPages',
        'page-count',
        'pageCount',
        'pages',
        'total',
        'total-count',
        'totalCount',
        'results',
        'results-total',
        'resultsTotal',
        'num-pages',
        'numPages',
        'pagination-total',
        'paginationTotal'
    ];

    function coerceTojQuery(element) {
        if (!element) return null;
        if (element.jquery) return element;
        if (element instanceof $) return element;
        if (element.nodeType || element === window || element === document) return $(element);
        if (typeof element === 'string') {
            try {
                const $el = $(element);
                return $el.length ? $el : null;
            } catch (_error) {
                return null;
            }
        }
        return null;
    }

    function createPaginationInteraction(overrides) {
        const base = {
            mode: 'replace',
            trigger: null,
            wrapper: null,
            reason: 'paginate'
        };
        if (!overrides) return base;
        const clone = Object.assign({}, base, overrides);
        clone.trigger = coerceTojQuery(clone.trigger);
        clone.wrapper = coerceTojQuery(clone.wrapper);
        clone.mode = clone.mode === 'append' ? 'append' : 'replace';
        return clone;
    }

    let paginationInteraction = createPaginationInteraction();
    let scrollAutoObserver = null;
    const scrollAutoWatched = new Set();
    let scrollAutoFallbackTargets = [];
    let scrollAutoFallbackHandler = null;
    let scrollAutoFallbackTicking = false;
    const scrollAutoTriggeredPages = new WeakMap();

    function setPaginationInteractionState(options) {
        paginationInteraction = createPaginationInteraction(options);
        if (paginationInteraction.mode === 'append' && (!paginationInteraction.trigger || !paginationInteraction.trigger.length) && paginationInteraction.wrapper && paginationInteraction.wrapper.length) {
            paginationInteraction.trigger = paginationInteraction.wrapper;
        }
        if (paginationInteraction.mode === 'append' && paginationInteraction.trigger && paginationInteraction.trigger.length) {
            setLoadMoreButtonState(paginationInteraction.trigger, true);
        }
    }

    function resetPaginationInteractionState() {
        if (paginationInteraction && paginationInteraction.trigger && paginationInteraction.trigger.length) {
            setLoadMoreButtonState(paginationInteraction.trigger, false);
        }
        paginationInteraction = createPaginationInteraction();
    }

    function ensureLoadMoreInlineStyles() {
        if (document.getElementById('dapfforwc-load-more-style')) return;
        const style = document.createElement('style');
        style.id = 'dapfforwc-load-more-style';
        style.textContent = '.dapfforwc-load-more-loading{position:relative;} .dapfforwc-load-more-spinner{display:inline-block;width:1em;height:1em;border:2px solid currentColor;border-top-color:transparent;border-radius:50%;animation:dapfforwc_spin .65s linear infinite;margin-left:.5em;vertical-align:middle;}@keyframes dapfforwc_spin{to{transform:rotate(360deg);}}';
        document.head.appendChild(style);
    }

    function setLoadMoreButtonState($button, isLoading) {
        $button = coerceTojQuery($button);
        if (!$button || !$button.length) return;
        ensureLoadMoreInlineStyles();
        const isInteractive = $button.is('button, input, [role="button"], a');
        if (isLoading) {
            $button.addClass('dapfforwc-load-more-loading').attr('aria-busy', 'true');
            if (isInteractive && $button.is('button, input, [role="button"]')) {
                $button.prop('disabled', true);
            }
            if ($button.is('a')) {
                $button.attr('aria-disabled', 'true');
            }
            if (!$button.find('> .dapfforwc-load-more-spinner').length) {
                $button.append('<span class="dapfforwc-load-more-spinner" aria-hidden="true"></span>');
            }
        } else {
            $button.removeClass('dapfforwc-load-more-loading').attr('aria-busy', 'false');
            if (isInteractive && $button.is('button, input, [role="button"]')) {
                $button.prop('disabled', false);
            }
            if ($button.is('a')) {
                $button.removeAttr('aria-disabled');
            }
            $button.find('> .dapfforwc-load-more-spinner').remove();
        }
    }

    function elementHasClassHint($element, hints) {
        if (!$element || !$element.length) return false;
        const cls = ($element.attr('class') || '').toLowerCase();
        return hints.some(hint => cls.indexOf(hint) !== -1);
    }

    function elementHasDataHint(element, hints) {
        if (!element) return false;
        const el = element.jquery ? element.get(0) : element;
        if (!el) return false;
        const dataset = el.dataset || {};
        for (const key in dataset) {
            if (!Object.prototype.hasOwnProperty.call(dataset, key)) continue;
            const normalizedKey = key.toLowerCase();
            const value = String(dataset[key]).toLowerCase();
            if (hints.some(h => normalizedKey.indexOf(h) !== -1 || value.indexOf(h) !== -1)) {
                return true;
            }
        }
        return false;
    }

    function elementAttrHasHint($element, attrNames, hints) {
        if (!$element || !$element.length) return false;
        for (const attr of attrNames) {
            const value = ($element.attr(attr) || '').toLowerCase();
            if (!value) continue;
            if (hints.some(h => value.indexOf(h) !== -1)) {
                return true;
            }
        }
        return false;
    }

    function isLoadMoreTrigger($element, $wrapper, detail) {
        if (detail && (detail.mode === 'append' || detail.append === true || detail.infinite === true)) {
            return true;
        }
        if ($element && elementHasClassHint($element, LOAD_MORE_CLASS_HINTS)) {
            return true;
        }
        if ($wrapper && elementHasClassHint($wrapper, LOAD_MORE_CLASS_HINTS)) {
            return true;
        }
        if ($element && elementAttrHasHint($element, ['rel', 'data-action', 'data-behavior', 'data-trigger', 'data-pagination', 'data-pagination-type', 'data-pagination-mode', 'data-mode', 'data-load', 'data-loader'], LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($wrapper && elementAttrHasHint($wrapper, ['data-pagination', 'data-mode', 'data-load'], LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($element && elementHasDataHint($element, LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($wrapper && elementHasDataHint($wrapper, LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($element && $element.attr('rel') && $element.attr('rel').toLowerCase() === 'next') {
            return true;
        }
        // Direct selector hints for wrappers (even if no classes on elements)
        if ($wrapper) {
            const matchesHint = LOAD_MORE_WRAPPER_HINTS.some(function (selector) {
                try {
                    return $wrapper.is(selector) || $wrapper.find(selector).length > 0;
                } catch (_error) {
                    return false;
                }
            });
            if (matchesHint) return true;
        }
        if ($element) {
            const matchesHint = LOAD_MORE_WRAPPER_HINTS.some(function (selector) {
                try {
                    return $element.is(selector) || $element.closest(selector).length > 0;
                } catch (_error) {
                    return false;
                }
            });
            if (matchesHint) return true;
        }
        if ($element && LOAD_MORE_TEXT_HINTS.length) {
            const txt = ($element.text() || '').toLowerCase();
            if (txt && LOAD_MORE_TEXT_HINTS.some(function (hint) { return txt.indexOf(hint) !== -1; })) {
                return true;
            }
        }
        return false;
    }

    function normalizePaginationSelectorInput(value) {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (typeof value !== 'string') return [];

        const selectors = [];
        let current = '';
        let depth = 0;

        for (let i = 0; i < value.length; i++) {
            const char = value[i];
            if (char === '(' || char === '[') {
                depth++;
                current += char;
            } else if (char === ')' || char === ']') {
                depth = Math.max(0, depth - 1);
                current += char;
            } else if (char === ',' && depth === 0) {
                if (current.trim()) {
                    selectors.push(current.trim());
                }
                current = '';
            } else {
                current += char;
            }
        }

        if (current.trim()) {
            selectors.push(current.trim());
        }

        return selectors;
    }

    function selectorExists(selector) {
        if (!selector || typeof selector !== 'string') return false;
        try {
            return document.querySelector(selector) !== null;
        } catch (error) {
            if (typeof plugincydebugLog === 'function') {
                plugincydebugLog('Invalid pagination selector detected:', selector, error);
            }
            return false;
        }
    }

    function isValidJquerySelector(selector) {
        if (!selector || typeof selector !== 'string') return false;
        try {
            $(selector);
            return true;
        } catch (error) {
            if (typeof plugincydebugLog === 'function') {
                plugincydebugLog('Invalid pagination selector detected:', selector, error);
            }
            return false;
        }
    }

    function collectPaginationSelectors() {
        const selectors = new Set();
        const addSelector = (selector, requirePresence = false) => {
            if (!selector || typeof selector !== 'string') return;
            const trimmed = selector.trim();
            if (!trimmed) return;
            if (!isValidJquerySelector(trimmed)) return;
            if (requirePresence && !selectorExists(trimmed)) return;
            selectors.add(trimmed);
        };

        const paginationSelector_shortcode = $('#product-filter').data('pagination_selector');
        normalizePaginationSelectorInput(paginationSelector_shortcode).forEach(sel => addSelector(sel));

        if (advancesettings && advancesettings["pagination_selector"]) {
            normalizePaginationSelectorInput(advancesettings["pagination_selector"]).forEach(sel => addSelector(sel));
        }

        addSelector('.plugincy-filter-pagination');

        const fallbackSelectors = [
            'nav.woocommerce-pagination',
            '.woocommerce-pagination',
            '.woocommerce .pagination',
            '.woocommerce .paginate_links',
            '.woocommerce .paginate-links',
            '.wc-block-pagination',
            '.wp-block-query-pagination',
            '.products + .navigation',
            '.woocommerce-result-count + .navigation',
            'ul.page-numbers',
            '.page-numbers',
            '.pagination',
            '.woocommerce .load-more',
            '.woocommerce .load-more-button',
            '.woocommerce .products-load-more',
            '.woocommerce .ajax-load-more',
            '.woocommerce .woocommerce-load-more',
            '.woocommerce .elementor-pagination',
            '.woocommerce .jet-load-more',
            '.woocommerce .jet-woo-builder__load-more',
            '.woocommerce .yith-infs-nav',
            '.woocommerce .yith-wcan-infinite-scroll',
            '.woocommerce .yith-wcan-load-more',
            '.woocommerce .infinite-scroll',
            '.woocommerce .infinite-scroll-trigger',
            '.woocommerce .wcl-pagination',
            '.woocommerce .woo-pagination'
        ];

        fallbackSelectors.forEach(sel => addSelector(sel, true));

        if (!selectors.size) {
            addSelector('.plugincy-filter-pagination');
        }

        return Array.from(selectors);
    }

    function parsePageNumber(value, increment = 0) {
        if (value === undefined || value === null || value === '') return null;
        let numeric;
        if (typeof value === 'number') {
            numeric = value;
        } else {
            const match = String(value).match(/-?\d+/);
            numeric = match ? parseInt(match[0], 10) : NaN;
        }
        if (isNaN(numeric)) return null;
        numeric += increment;
        if (numeric < 1) return null;
        return numeric;
    }

    function readPaginationDataAttr($element, attrName) {
        if (!$element || !$element.length || !attrName) return null;
        const el = $element.get(0);
        if (!el) return null;
        const normalizedAttr = attrName.replace(/^data-/, '');
        const datasetKey = normalizedAttr.replace(/-([a-z])/g, function (_match, chr) {
            return chr.toUpperCase();
        });
        if (typeof $element.data === 'function') {
            const dataValue = $element.data(datasetKey);
            if (dataValue !== undefined) return dataValue;
        }
        if (el.dataset && Object.prototype.hasOwnProperty.call(el.dataset, datasetKey)) {
            return el.dataset[datasetKey];
        }
        const attrVariants = attrName.startsWith('data-') ? [attrName, normalizedAttr] : [attrName, `data-${normalizedAttr}`];
        for (const attr of attrVariants) {
            if (el.hasAttribute && el.hasAttribute(attr)) {
                return el.getAttribute(attr);
            }
        }
        return null;
    }

    function extractPageFromUrl(rawUrl) {
        if (!rawUrl) return null;
        try {
            const parsed = new URL(rawUrl, window.location.origin);
            const params = parsed.searchParams;
            const pageKeys = ['page', 'paged', 'product-page'];
            for (const key of pageKeys) {
                const parsedQuery = parsePageNumber(params.get(key));
                if (parsedQuery) return parsedQuery;
            }
            const pathMatch = parsed.pathname.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
            if (pathMatch && pathMatch[1]) {
                return parsePageNumber(pathMatch[1]);
            }
        } catch (_error) {
            const fallbackPath = rawUrl.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
            if (fallbackPath && fallbackPath[1]) {
                return parsePageNumber(fallbackPath[1]);
            }
            const fallbackQuery = rawUrl.match(/[?&](?:paged|page|product-page)=(\d+)/i);
            if (fallbackQuery && fallbackQuery[1]) {
                return parsePageNumber(fallbackQuery[1]);
            }
        }
        return null;
    }

    function getPageFromElement($element, $wrapper) {
        const attrGroups = [
            { names: ['target-page', 'page-target', 'goto', 'go-to', 'go_to', 'pageToLoad', 'page-to-load'], increment: 0 },
            { names: ['next-page', 'nextpage', 'next_page', 'next', 'load-page', 'loadpage', 'load_page', 'upcoming-page', 'upcomingPage'], increment: 0 },
            { names: ['page', 'paged', 'pagination', 'page-num', 'page-number', 'pageindex', 'pageIndex', 'page-id', 'pageId'], increment: 0 },
            { names: ['current', 'current-page', 'current_page', 'currentPage'], increment: 1 }
        ];
        const sources = [$element, $wrapper];
        const rawPageToken = readPaginationDataAttr($element, 'page') || readPaginationDataAttr($element, 'paged') || readPaginationDataAttr($element, 'pagination');
        if (rawPageToken) {
            const normalizedToken = String(rawPageToken).trim().toLowerCase();
            if (normalizedToken === 'prev' || normalizedToken === 'previous' || normalizedToken === 'next') {
                let basePage = null;
                if ($wrapper && $wrapper.length) {
                    const $current = $wrapper.find('.current, .is-active, .active').last();
                    basePage = parsePageNumber($current.text());
                }
                if (!basePage) {
                    basePage = parsePageNumber(filterState.currentPage);
                }
                if (basePage) {
                    return normalizedToken === 'next' ? basePage + 1 : Math.max(1, basePage - 1);
                }
            }
        }
        for (const group of attrGroups) {
            for (const src of sources) {
                if (!src || !src.length) continue;
                for (const name of group.names) {
                    const value = readPaginationDataAttr(src, name);
                    const parsed = parsePageNumber(value, group.increment);
                    if (parsed) return parsed;
                }
            }
        }

        const valueAttr = $element ? $element.attr('value') : null;
        const pageFromValue = parsePageNumber(valueAttr);
        if (pageFromValue) return pageFromValue;

        const textContent = $element && typeof $element.text === 'function' ? $element.text() : '';
        const pageFromText = parsePageNumber(textContent);
        if (pageFromText) return pageFromText;

        if ($wrapper && $wrapper.length) {
            const $current = $wrapper.find('.current, .is-active, .active').last();
            const fromCurrent = parsePageNumber($current.text(), 1);
            if (fromCurrent) return fromCurrent;
        }

        return null;
    }

    function getUrlFromElement($element, $wrapper) {
        const attrNames = ['href', 'data-url', 'data-href', 'data-link', 'data-target', 'data-page-url', 'data-next-url', 'data-load-url', 'data-pagination-url'];
        const sources = [$element, $wrapper];
        for (const src of sources) {
            if (!src || !src.length) continue;
            for (const attr of attrNames) {
                let value = null;
                if (attr === 'href') {
                    value = src.attr(attr);
                } else {
                    value = readPaginationDataAttr(src, attr);
                }
                if (value && value !== '#' && !String(value).startsWith('javascript')) {
                    return value;
                }
            }
        }
        return null;
    }

    function buildPaginationPayload($element, $wrapper) {
        const inferredPage = getPageFromElement($element, $wrapper);
        const url = getUrlFromElement($element, $wrapper);
        return {
            page: inferredPage || extractPageFromUrl(url),
            url: url || null
        };
    }

    function dispatchFilteredPaginationRequest(payload, interactionOptions) {
        if (!payload) return;
        const $form = $(dapfforwc_FILTER.formSelector);
        if (!$form.length) return;

        let targetPage = parsePageNumber(payload.page) || extractPageFromUrl(payload.url) || null;
        const isAppendMode = interactionOptions && interactionOptions.mode === 'append';
        if (!targetPage && isAppendMode) {
            const current = parsePageNumber(filterState.currentPage) || 1;
            targetPage = current + 1;
        }
        if (!targetPage || targetPage < 1) {
            targetPage = 1;
        }

        if (filterState.isLoading) {
            return;
        }

        setPaginationInteractionState(interactionOptions);
        $('#roverlay').show();
        $('#loader').show();
        const started = handleFilterChange($form, targetPage);
        if (!started) {
            resetPaginationInteractionState();
            $('#roverlay').hide();
            $('#loader').hide();
        }
    }

    function registerExternalPaginationAPI() {
        window.dapfforwcLoadPage = function (pageOrPayload, maybeUrlOrOptions, maybeOptions) {
            let payload = {};
            let interaction = null;

            if (pageOrPayload && typeof pageOrPayload === 'object' && !Array.isArray(pageOrPayload)) {
                payload.page = pageOrPayload.page || pageOrPayload.paged || pageOrPayload.nextPage || pageOrPayload.targetPage || null;
                payload.url = pageOrPayload.url || pageOrPayload.href || pageOrPayload.link || null;
                interaction = pageOrPayload;
            } else {
                payload.page = pageOrPayload;
                if (typeof maybeUrlOrOptions === 'string') {
                    payload.url = maybeUrlOrOptions;
                    interaction = (maybeOptions && typeof maybeOptions === 'object') ? maybeOptions : null;
                } else if (maybeUrlOrOptions && typeof maybeUrlOrOptions === 'object') {
                    payload.url = maybeUrlOrOptions.url || maybeUrlOrOptions.href || null;
                    interaction = maybeUrlOrOptions;
                } else {
                    payload.url = null;
                    interaction = null;
                }
            }

            dispatchFilteredPaginationRequest(payload, interaction);
        };

        $(document)
            .off('.dapfforwcPaginationBridge')
            .on('dapfforwc:loadPage.dapfforwcPaginationBridge plugincy:loadPage.dapfforwcPaginationBridge dapfforwc:paginate.dapfforwcPaginationBridge', function (_event, detail) {
                if (detail === undefined || detail === null) return;

                let payload;
                if (typeof detail === 'number') {
                    payload = { page: detail };
                } else if (typeof detail === 'string') {
                    payload = { url: detail };
                } else {
                    payload = {
                        page: detail.page || detail.paged || detail.nextPage || detail.targetPage || detail.index || null,
                        url: detail.url || detail.href || detail.link || null
                    };
                }

                if (!payload || (payload.page === null || payload.page === undefined) && !payload.url) {
                    return;
                }

                dispatchFilteredPaginationRequest(payload, typeof detail === 'object' ? detail : null);
            });
    }

    const paginationSelectors = collectPaginationSelectors();
    const pagination_selector = paginationSelectors.length ? paginationSelectors.join(', ') : '.plugincy-filter-pagination';

    registerExternalPaginationAPI();

    function querySelectorsInContext(context, selector) {
        if (!selector) return $();
        try {
            if (!context || context === document || context === window) {
                return $(selector);
            }
            const $context = context.jquery ? context : $(context);
            if (!$context || !$context.length) return $();
            let $results = $();
            $context.each(function () {
                if (this === document || this === window) {
                    $results = $results.add($(selector));
                } else if (this && this.querySelectorAll) {
                    $results = $results.add($(this).find(selector));
                }
            });
            return $results;
        } catch (_error) {
            return $();
        }
    }

    function gatherPaginationWrappers(context, includeLoadMoreHints = false) {
        const nodes = new Set();
        const selectorPool = paginationSelectors.length ? paginationSelectors.slice() : ['.plugincy-filter-pagination'];
        if (includeLoadMoreHints) {
            LOAD_MORE_WRAPPER_HINTS.forEach(function (selector) { selectorPool.push(selector); });
        }
        selectorPool.forEach(function (selector) {
            if (!selector) return;
            const $found = querySelectorsInContext(context, selector);
            if (!$found || !$found.length) return;
            $found.each(function () { nodes.add(this); });
        });
        return Array.from(nodes).map(function (el) { return $(el); });
    }

    function collectAutoScrollWrappers(context) {
        return gatherPaginationWrappers(context || document, true);
    }

    function extractTotalPagesFromWrapper($wrapper) {
        if (!$wrapper || !$wrapper.length) return null;
        let maxPage = null;
        PAGINATION_TOTAL_DATA_ATTRS.forEach(function (name) {
            const parsed = parsePageNumber(readPaginationDataAttr($wrapper, name));
            if (parsed && (!maxPage || parsed > maxPage)) {
                maxPage = parsed;
            }
        });
        const $clickables = $wrapper.find(PAGINATION_INTERACTIVE_TARGETS);
        $clickables.each(function () {
            const $el = $(this);
            PAGINATION_TOTAL_DATA_ATTRS.forEach(function (name) {
                const parsedAttr = parsePageNumber(readPaginationDataAttr($el, name));
                if (parsedAttr && (!maxPage || parsedAttr > maxPage)) {
                    maxPage = parsedAttr;
                }
            });
            const inferred = getPageFromElement($el, $wrapper);
            if (inferred && (!maxPage || inferred > maxPage)) {
                maxPage = inferred;
            }
        });
        if (!maxPage) {
            $wrapper.find('.page-numbers li, .page-numbers a, .page-numbers span, .pagination li, .pagination a, .paginate_links li, .paginate_links a, .paginate-links li').each(function () {
                const parsed = parsePageNumber($(this).text());
                if (parsed && (!maxPage || parsed > maxPage)) {
                    maxPage = parsed;
                }
            });
        }
        return maxPage;
    }

    function inferTotalPagesFromContext(context) {
        const wrappers = gatherPaginationWrappers(context || document, true);
        let maxPage = null;
        wrappers.forEach(function ($wrapper) {
            const wrapperMax = extractTotalPagesFromWrapper($wrapper);
            if (wrapperMax && (!maxPage || wrapperMax > maxPage)) {
                maxPage = wrapperMax;
            }
        });
        return maxPage;
    }

    function markLoadMoreExhausted($wrapper) {
        $wrapper = coerceTojQuery($wrapper);
        if (!$wrapper || !$wrapper.length) return;
        if (!isLoadMoreTrigger($wrapper, $wrapper) && !shouldAutoScrollWrapper($wrapper)) return;
        const $button = findAutoScrollClickable($wrapper);
        if ($button && $button.length) {
            setLoadMoreButtonState($button, false);
            $button.addClass('dapfforwc-load-more-complete').attr('aria-disabled', 'true');
            if ($button.is('button, input, [role="button"]')) {
                $button.prop('disabled', true);
            }
            if ($button.is('a')) {
                $button.addClass('disabled').attr('tabindex', '-1');
            }
        }
        $wrapper.addClass('dapfforwc-load-more-complete').attr('aria-disabled', 'true').hide();
    }

    function restoreLoadMoreWrapper($wrapper) {
        $wrapper = coerceTojQuery($wrapper);
        if (!$wrapper || !$wrapper.length) return;
        const $button = findAutoScrollClickable($wrapper);
        if ($button && $button.length) {
            $button.removeClass('dapfforwc-load-more-complete').attr('aria-disabled', 'false');
            if ($button.is('button, input, [role="button"]')) {
                $button.prop('disabled', false);
            }
            if ($button.is('a')) {
                $button.removeClass('disabled').removeAttr('tabindex');
            }
        }
    }

    function enforceLoadMoreVisibility() {
        const total = parsePageNumber(filterState.totalPages);
        const current = parsePageNumber(filterState.currentPage) || 1;
        const wrappers = collectAutoScrollWrappers();
        if (!wrappers.length) return;
        if (total && current >= total) {
            wrappers.forEach(function ($wrapper) {
                markLoadMoreExhausted($wrapper);
            });
        } else {
            wrappers.forEach(function ($wrapper) {
                restoreLoadMoreWrapper($wrapper);
            });
        }
    }

    function parseResultCountData($element) {
        if (!$element || !$element.length) return null;
        const $first = $element.first ? $element.first() : $element;
        const text = typeof $first.text === 'function' ? $first.text() : '';
        if (!text) return null;
        const matches = text.match(/\d+/g);
        if (!matches || !matches.length) {
            if (/single/i.test(text)) {
                return { from: 1, to: 1, total: 1 };
            }
            return null;
        }
        const nums = matches.map(function (n) { return parseInt(n, 10); }).filter(function (n) { return !isNaN(n); });
        if (!nums.length) return null;
        if (nums.length >= 3) {
            return { from: nums[0], to: nums[1], total: nums[2] };
        }
        if (nums.length === 2) {
            return { from: nums[0], to: nums[1], total: nums[1] };
        }
        return { from: 1, to: nums[0], total: nums[0] };
    }

    function replaceResultCountNumbers(originalHtml, counts) {
        if (!originalHtml || !counts) return originalHtml;
        let index = 0;
        return String(originalHtml).replace(/\d+/g, function (match) {
            index++;
            if (index === 1 && counts.from !== undefined && counts.from !== null) {
                return String(counts.from);
            }
            if (index === 2 && counts.to !== undefined && counts.to !== null) {
                return String(counts.to);
            }
            if (index === 3 && counts.total !== undefined && counts.total !== null) {
                return String(counts.total);
            }
            return match;
        });
    }

    function countRenderedProducts($targetsProducts, appendedTargetsSet) {
        const seen = new Set();
        let total = 0;

        const addFromCollection = function ($collection) {
            if (!$collection || !$collection.length) return;
            $collection.each(function () {
                if (seen.has(this)) return;
                seen.add(this);
                total += $(this).children().length;
            });
        };

        if (appendedTargetsSet && appendedTargetsSet.size) {
            appendedTargetsSet.forEach(function (node) {
                const $node = coerceTojQuery(node);
                if ($node) addFromCollection($node);
            });
        }

        addFromCollection($targetsProducts);

        return total;
    }

    function updateResultCountAndLoadMore(options) {
        const opts = options || {};
        const resultCounts = opts.resultCounts || null;
        const totalResultsRaw = resultCounts && resultCounts.total !== undefined ? parseInt(resultCounts.total, 10) : null;
        const totalResults = isNaN(totalResultsRaw) ? null : totalResultsRaw;
        const displayedCount = countRenderedProducts(opts.$targetsProducts, opts.appendedTargets);
        let htmlToUse = typeof opts.originalHtml === 'string' ? opts.originalHtml : '';

        if (opts.isAppendMode) {
            const targetCounts = resultCounts ? {
                from: 1,
                to: resultCounts.to !== undefined && resultCounts.to !== null && totalResults !== null ? Math.min(resultCounts.to, totalResults) : resultCounts ? resultCounts.to : null,
                total: totalResults !== null ? totalResults : (resultCounts ? resultCounts.total : null)
            } : (totalResults !== null && displayedCount !== null && displayedCount !== undefined ? {
                from: 1,
                to: Math.min(displayedCount, totalResults),
                total: totalResults
            } : null);

            if (targetCounts) {
                htmlToUse = replaceResultCountNumbers(htmlToUse, targetCounts);
                if (!htmlToUse && targetCounts.total !== null && targetCounts.total !== undefined) {
                    htmlToUse = `Showing ${targetCounts.from}-${targetCounts.to} of ${targetCounts.total} results`;
                }
            }
        }

        if (opts.$targetsResultCount && opts.$targetsResultCount.length) {
            opts.$targetsResultCount.html(htmlToUse);
        }
        if (opts.$productCountSm && opts.$productCountSm.length) {
            opts.$productCountSm.html(htmlToUse);
        }

        if (totalResults !== null) {
            const perPage = parsePageNumber(filterState.perPage);
            const pageSize = perPage || (resultCounts && resultCounts.to && resultCounts.from ? (resultCounts.to - resultCounts.from + 1) : null);
            if (pageSize) {
                filterState.totalPages = Math.max(1, Math.ceil(totalResults / pageSize));
            }
            filterState.totalResults = totalResults;
        } else {
            filterState.totalPages = null;
            filterState.totalResults = null;
        }

        const wrappers = collectAutoScrollWrappers();
        if (wrappers.length) {
            const appendedCount = typeof opts.appendedItemCount === 'number' ? opts.appendedItemCount : null;
            const hasTotal = totalResults !== null && totalResults !== undefined;
            const hasDisplayed = displayedCount !== null && displayedCount !== undefined;
            const isExhausted = (hasTotal && hasDisplayed && displayedCount >= totalResults) ||
                (opts.isAppendMode && appendedCount !== null && appendedCount <= 0) ||
                (hasDisplayed && displayedCount === 0);
            wrappers.forEach(function ($wrapper) {
                if (isExhausted) {
                    markLoadMoreExhausted($wrapper);
                } else {
                    restoreLoadMoreWrapper($wrapper);
                }
            });
        }
    }

    function updateTotalPagesFromContext(context) {
        const inferred = inferTotalPagesFromContext(context);
        if (inferred) {
            filterState.totalPages = inferred;
        }
        enforceLoadMoreVisibility();
    }

    function teardownScrollPaginationObservers() {
        if (scrollAutoObserver) {
            scrollAutoWatched.forEach(function (el) {
                try {
                    scrollAutoObserver.unobserve(el);
                } catch (_error) { }
            });
            scrollAutoObserver.disconnect();
            scrollAutoObserver = null;
        }
        scrollAutoWatched.clear();
        if (scrollAutoFallbackHandler) {
            $(window).off('scroll.dapfforwcAutoScroll resize.dapfforwcAutoScroll', scrollAutoFallbackHandler);
            scrollAutoFallbackHandler = null;
        }
        scrollAutoFallbackTargets = [];
        scrollAutoFallbackTicking = false;
    }

    function isElementNearViewport(element, offset = 200) {
        if (!element || !element.getBoundingClientRect) return false;
        const rect = element.getBoundingClientRect();
        const viewHeight = window.innerHeight || document.documentElement.clientHeight || 0;
        return rect.top <= viewHeight + offset && rect.bottom >= -offset;
    }

    function shouldAutoScrollWrapper($wrapper) {
        if (!$wrapper || !$wrapper.length) return false;
        if (!isLoadMoreTrigger($wrapper, $wrapper)) return false;
        if (elementHasClassHint($wrapper, AUTO_SCROLL_CLASS_HINTS)) return true;
        if (elementAttrHasHint($wrapper, AUTO_SCROLL_ATTR_NAMES, AUTO_SCROLL_DATA_HINTS)) return true;
        if (elementHasDataHint($wrapper, AUTO_SCROLL_DATA_HINTS)) return true;
        const $clickable = findAutoScrollClickable($wrapper);
        if ($clickable && $clickable.length) {
            if (elementAttrHasHint($clickable, AUTO_SCROLL_ATTR_NAMES, AUTO_SCROLL_DATA_HINTS)) return true;
            if (elementHasDataHint($clickable, AUTO_SCROLL_DATA_HINTS)) return true;
        }
        return false;
    }

    function findAutoScrollClickable($wrapper) {
        if (!$wrapper || !$wrapper.length) return null;
        let $candidate = $wrapper.find(PAGINATION_INTERACTIVE_TARGETS).filter(function () {
            const $el = $(this);
            if (!$el.length || !$el.is(':visible')) return false;
            if ($el.is(':disabled') || $el.hasClass('disabled') || $el.attr('aria-disabled') === 'true') return false;
            return true;
        }).first();
        if (!$candidate.length) {
            $candidate = $wrapper;
        }
        return $candidate;
    }

    function triggerAutoScrollPagination($wrapper) {
        if (!$wrapper || !$wrapper.length) return;
        if (filterState.isLoading) return;
        const $clickable = findAutoScrollClickable($wrapper);
        if (!$clickable || !$clickable.length) return;

        const payload = buildPaginationPayload($clickable, $wrapper);
        let targetPage = parsePageNumber(payload.page) || extractPageFromUrl(payload.url);
        if (!targetPage) {
            targetPage = parsePageNumber(filterState.currentPage, 1) || 1;
            payload.page = targetPage;
        }

        const key = $wrapper.get(0);
        const lastTriggered = scrollAutoTriggeredPages.get(key);
        if (lastTriggered && targetPage <= lastTriggered) {
            return;
        }
        scrollAutoTriggeredPages.set(key, targetPage);

        const interactionOptions = {
            mode: 'append',
            trigger: $clickable,
            wrapper: $wrapper,
            reason: 'auto-scroll'
        };

        dispatchFilteredPaginationRequest(payload, interactionOptions);
    }

    function initScrollPaginationAutoLoad() {
        if (!$('#product-filter').length) {
            teardownScrollPaginationObservers();
            return;
        }

        const wrappers = collectAutoScrollWrappers().filter(shouldAutoScrollWrapper);
        teardownScrollPaginationObservers();

        if (!wrappers.length) {
            return;
        }

        const observedElements = wrappers.map(function ($wrapper) { return $wrapper.get(0); }).filter(Boolean);

        if ('IntersectionObserver' in window) {
            scrollAutoObserver = new IntersectionObserver(function (entries) {
                entries.forEach(function (entry) {
                    if (entry && entry.isIntersecting) {
                        triggerAutoScrollPagination($(entry.target));
                    }
                });
            }, { rootMargin: '200px 0px', threshold: 0.01 });
            observedElements.forEach(function (element) {
                scrollAutoObserver.observe(element);
                scrollAutoWatched.add(element);
            });
        } else {
            scrollAutoFallbackTargets = observedElements;
            scrollAutoFallbackHandler = function () {
                if (scrollAutoFallbackTicking) return;
                scrollAutoFallbackTicking = true;
                requestAnimationFrame(function () {
                    scrollAutoFallbackTicking = false;
                    if (!scrollAutoFallbackTargets.length) return;
                    scrollAutoFallbackTargets.forEach(function (element) {
                        if (isElementNearViewport(element)) {
                            triggerAutoScrollPagination($(element));
                        }
                    });
                });
            };
            $(window).on('scroll.dapfforwcAutoScroll resize.dapfforwcAutoScroll', scrollAutoFallbackHandler);
            scrollAutoFallbackHandler();
        }
    }


    function stopEventForPagination(e) {
        if (!e) return;
        if (typeof e.preventDefault === 'function') e.preventDefault();
        if (typeof e.stopImmediatePropagation === 'function') {
            e.stopImmediatePropagation();
        }
        if (typeof e.stopPropagation === 'function') e.stopPropagation();
    }

    function processPaginationClickEvent(e) {
        if (!pagination_selector) return false;
        if (e && e.dapfforwcHandled) return true;
        const $target = $(e && e.target);
        if (!$target || !$target.length) return false;
        const $wrapper = $target.closest(pagination_selector);
        if (!$wrapper.length) return false;
        let $clickable = $target.closest(PAGINATION_INTERACTIVE_TARGETS);
        if (!$clickable.length || !$clickable.closest($wrapper).length) {
            $clickable = $wrapper;
        }

        const isLoadMore = isLoadMoreTrigger($clickable, $wrapper);
        const stopEvent = function () {
            stopEventForPagination(e);
            if (e) e.dapfforwcHandled = true;
            return false;
        };

        if (isLoadMore) {
            const isDisabled = $clickable.is(':disabled') || $clickable.hasClass('disabled') || $clickable.attr('aria-disabled') === 'true' || $wrapper.attr('aria-disabled') === 'true';
            const isBusy = $clickable.hasClass('dapfforwc-load-more-loading') || $wrapper.hasClass('dapfforwc-load-more-loading');
            if (isDisabled || isBusy) {
                return stopEvent();
            }
        }

        const payload = buildPaginationPayload($clickable, $wrapper);
        if ((!payload.page && !payload.url) && !isLoadMore) {
            return false;
        }
        if (!payload.page && !payload.url && isLoadMore) {
            payload.page = parsePageNumber(
                readPaginationDataAttr($wrapper, 'next-page') ||
                readPaginationDataAttr($wrapper, 'next') ||
                readPaginationDataAttr($wrapper, 'page') ||
                readPaginationDataAttr($wrapper, 'paged') ||
                readPaginationDataAttr($wrapper, 'current-page') ||
                readPaginationDataAttr($wrapper, 'current')
            ) || parsePageNumber(filterState.currentPage, 1) || 1;
            payload.url = payload.url || readPaginationDataAttr($wrapper, 'url') || readPaginationDataAttr($wrapper, 'href') || null;
        }
        if (!payload.page && !payload.url) return false;

        const interactionOptions = {
            mode: isLoadMore ? 'append' : 'replace',
            trigger: isLoadMore ? $clickable : null,
            wrapper: $wrapper,
            reason: isLoadMore ? 'load-more' : 'paginate'
        };

        stopEvent();
        dispatchFilteredPaginationRequest(payload, interactionOptions);
        return true;
    }

    function attachPaginationEvents() {
        if (!pagination_selector) return;
        $(document).off('click.dapfforwcPagination');
        const delegateSelector = `${pagination_selector}, ${pagination_selector} ${PAGINATION_INTERACTIVE_TARGETS}`;
        $(document).on('click.dapfforwcPagination', delegateSelector, function (e) {
            processPaginationClickEvent(e);
        });

        if (!window.dapfforwcPaginationCaptureAttached) {
            window.dapfforwcPaginationCaptureAttached = true;
            document.addEventListener('click', function (e) {
                const handled = processPaginationClickEvent(e);
                if (handled) {
                    stopEventForPagination(e);
                }
            }, true);
        }
    }

    // Store the current filter state
    let filterState = {
        currentRequest: null,
        isLoading: false,
        pendingChanges: false,
        currentPage: 1,
        pendingPage: 1,
        totalPages: null,
        totalResults: null,
        perPage: null
    };

    // Call this function after updating the product listings
    if ($('#product-filter').length) {
        attachPaginationEvents();
        initScrollPaginationAutoLoad();
        updateTotalPagesFromContext(document);
    }

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('filters')) {
        count = 1;
        applyFiltersFromUrl(urlParams.get('filters'));
        count = 0;

    } else {
        const $form = $(dapfforwc_FILTER.formSelector);
        handleFilterChange($form, 1, true);
    }
    /**
     * Initialize the filter functionality
     */
    function initProductFilter() {
        const $form = $(dapfforwc_FILTER.formSelector);

        if ($form.length === 0) {
            return;
        }

        // Bind events to filter elements
        bindFilterEvents($form);

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function (event) {
            // Only handle our own state changes
            if (event.state && event.state.dapfforwcFilter) {
                window.location.reload();
            }
        });

        initSorting();
    }
    // single filter handle
    syncCheckboxSelections();

    function syncCheckboxSelections() {
        const $container = $('.rfilterbuttons ul');
        if (!$container.length) return;

        // Make a stable signature of current inputs to avoid needless rebuilds
        const sig = $('#product-filter #' + rfilterbuttonsId + ' input, #product-filter #' + rfilterbuttonsId + ' option')
            .map(function () { return this.name + ':' + this.value + ':' + (this.checked || this.selected); })
            .get().join('|');

        if (sig === lastMirrorSig) return;
        lastMirrorSig = sig;

        $container.empty();
        const frag = document.createDocumentFragment();

        $('#product-filter #' + rfilterbuttonsId + ' input').each(function () {
            const title = $(this).attr('title') || '';
            const item = createCheckboxListItem(title, $(this).val(), $(this).is(':checked'), this.type);
            if (item) frag.appendChild(item[0]);
        });


        $('#product-filter #' + rfilterbuttonsId + ' option').each(function (i) {
            if (i === 0) return;
            const item = createCheckboxListItem($(this).val(), $(this).val(), $(this).is(':checked'), this.type);
            if (item) frag.appendChild(item[0]);
        });
        $container[0].appendChild(frag);
        attachCheckboxClickEvents();
        attachMainFilterChangeEvents();
    }
    function createCheckboxListItem(title, value, checked, type) {
        const trimmedTitle = (title || "").trim();
        const trimmedValue = (value || "").trim();
        if (!trimmedTitle || !trimmedValue) return null;
        return $('<li></li>').addClass(checked ? 'checked' : '').append(
            $('<input>', {
                name: 'attribute[' + rfilterbuttonsId + '][]',
                id: 'text_' + trimmedValue,
                type: 'checkbox',
                value: trimmedValue,
                checked: checked
            }).on('change', syncToMainFilter),
            $('<label></label>', {
                for: 'text_' + trimmedValue,
                text: trimmedTitle
            })
        );
    }

    function syncToMainFilter() {
        $(`#product-filter #${rfilterbuttonsId} input[value="${$(this).val()}"]`).prop('checked', $(this).is(':checked'));
        $(`#product-filter #${rfilterbuttonsId} select option[value="${$(this).val()}"]`).prop('selected', $(this).is(':checked'));
    }

    function attachCheckboxClickEvents() {
        $('.rfilterbuttons ul').off('click', 'li').on('click', 'li', function () {
            const checkbox = $(this).find('input');
            checkbox.prop('checked', !checkbox.is(':checked')).trigger('change');
            $(this).toggleClass('checked', checkbox.is(':checked'));
        });
    }

    function attachMainFilterChangeEvents() {
        $('#' + rfilterbuttonsId + ' input').on('change', function () {
            const relatedCheckbox = $(`.rfilterbuttons ul li input[value="${$(this).val()}"]`);
            relatedCheckbox.prop('checked', $(this).is(':checked')).closest('li').toggleClass('checked', $(this).is(':checked'));
        });
    }

    function store_selected_values() {
        const filtersByType = {};
        const options_selector = "#product-filter input:checked:not('.default_values input')";
        // Handle checked checkboxes and radios
        $(options_selector).each(function () {
            const value = $(this).val();
            const name = $(this).attr('name');
            if (!filtersByType[name]) {
                filtersByType[name] = [];
            }
            if (!filtersByType[name].includes(value)) {
                filtersByType[name].push(value);
            }
        });
        // Handle selected options in select elements (excluding default/empty)
        $('#product-filter select').each(function () {
            const name = $(this).attr('name');
            const selectedValues = $(this).val();
            if (selectedValues && selectedValues.length > 0) {
                if (!filtersByType[name]) {
                    filtersByType[name] = [];
                }
                if (Array.isArray(selectedValues)) {
                    selectedValues.forEach(v => {
                        if (v !== "" && v !== "Any" && !filtersByType[name].includes(v)) {
                            filtersByType[name].push(v);
                        }
                    });
                } else if (selectedValues !== "" && selectedValues !== "Any" && !filtersByType[name].includes(selectedValues)) {
                    filtersByType[name].push(selectedValues);
                }
            }
        });
        return filtersByType;
    }


    // Retrieve the active price range when it differs from defaults
    function getActivePriceRange() {
        const $form = $(dapfforwc_FILTER.formSelector);
        const $rangeMin = $form.find('.range-min');
        const $rangeMax = $form.find('.range-max');
        const $numberMin = $form.find('input[name="mn_price"]');
        const $numberMax = $form.find('input[name="mx_price"]');

        const hasNumberInputs = $numberMin.length && $numberMax.length;
        const hasRangeInputs = $rangeMin.length && $rangeMax.length;

        if (!hasNumberInputs && !hasRangeInputs) return null;

        const defaultMin = ($numberMin.attr('min') ?? $rangeMin.attr('min')) ?? '';
        const defaultMax = ($numberMax.attr('max') ?? $rangeMax.attr('max')) ?? '';

        // Prefer the number inputs when present so manual typing is respected,
        // but fall back to the slider values if needed.
        const currentMin = (hasNumberInputs ? $numberMin.val() : $rangeMin.val()) || defaultMin;
        const currentMax = (hasNumberInputs ? $numberMax.val() : $rangeMax.val()) || defaultMax;

        if (String(currentMin) === String(defaultMin) && String(currentMax) === String(defaultMax)) {
            return null;
        }

        return {
            min: currentMin,
            max: currentMax,
            defaultMin,
            defaultMax
        };
    }


    function getActiveRangeFilter(minName, maxName) {
        const $form = $(dapfforwc_FILTER.formSelector);
        const $minInput = $form.find(`[name="${minName}"]`);
        const $maxInput = $form.find(`[name="${maxName}"]`);
        if (!$minInput.length && !$maxInput.length) return null;

        const defaultMin = $minInput.attr('min') ?? '';
        const defaultMax = $maxInput.attr('max') ?? '';
        const currentMin = ($minInput.val && $minInput.val()) ?? defaultMin;
        const currentMax = ($maxInput.val && $maxInput.val()) ?? defaultMax;

        if (!currentMin && !currentMax) return null;
        if (String(currentMin) === String(defaultMin) && String(currentMax) === String(defaultMax)) {
            return null;
        }

        return {
            min: currentMin || '',
            max: currentMax || '',
            defaultMin,
            defaultMax
        };
    }

    function resetPriceRangeToDefaults() {
        const $form = $(dapfforwc_FILTER.formSelector);
        const $rangeMin = $form.find('.range-min');
        const $rangeMax = $form.find('.range-max');
        const $numberMin = $form.find('input[name="mn_price"]');
        const $numberMax = $form.find('input[name="mx_price"]');
        const hasRange = $rangeMin.length && $rangeMax.length;

        if (!hasRange && (!$numberMin.length || !$numberMax.length)) return;

        const defaultMin = (hasRange ? $rangeMin.attr('min') : $numberMin.attr('min')) ?? '';
        const defaultMax = (hasRange ? $rangeMax.attr('max') : $numberMax.attr('max')) ?? '';

        if (hasRange) {
            $rangeMin.val(defaultMin);
            $rangeMax.val(defaultMax);
        }
        if ($numberMin.length) $numberMin.val(defaultMin);
        if ($numberMax.length) $numberMax.val(defaultMax);
        $form.find('#min-price').val(defaultMin);
        $form.find('#max-price').val(defaultMax);

        if (hasRange) {
            $form.find('.plugrogress').css({
                'left': '0%',
                'right': '0%'
            });

            changePseudoElementContent(defaultMin, defaultMax);
        }
    }


    function resetRangeFilterToDefaults(minName, maxName) {
        const $form = $(dapfforwc_FILTER.formSelector);
        const $minInput = $form.find(`[name="${minName}"]`);
        const $maxInput = $form.find(`[name="${maxName}"]`);
        const resolveResetValue = ($input) => {
            if (!$input || !$input.length) return '';
            const dataDefault = $input.data('default');
            return dataDefault !== undefined ? dataDefault : '';
        };
        const defaultMin = resolveResetValue($minInput);
        const defaultMax = resolveResetValue($maxInput);
        const syncDisplay = ($input, selector, value) => {
            if (!$input || !$input.length) return;
            const $row = $input.closest('.dimension-row');
            if ($row.length) {
                $row.find(selector).text(value);
            }
        };

        if ($minInput.length) {
            $minInput.val(defaultMin).trigger('change');
            syncDisplay($minInput, '.min-value', defaultMin);
        }
        if ($maxInput.length) {
            $maxInput.val(defaultMax).trigger('change');
            syncDisplay($maxInput, '.max-value', defaultMax);
        }
    }

    // create list of current selected filter
    function selectedFilterShowProductTop() {
        const lists = document.querySelectorAll('.rfilterselected ul');
        if (!lists.length) return;
        const frag = document.createDocumentFragment();

        const $form = $(dapfforwc_FILTER.formSelector);
        const addedKeys = new Set();

        const attrprefix = (typeof dapfforwc_seo_permalinks_options !== 'undefined' && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
        const prefixToAttribute = {};
        prefixToAttribute[attrprefix["product-category"] ?? 'cata'] = "product-category[]";
        prefixToAttribute[attrprefix.tag ?? 'tags'] = 'tag';
        prefixToAttribute[attrprefix.price ?? 'price'] = 'price';
        prefixToAttribute[attrprefix.rating ?? 'rating'] = 'rating';
        prefixToAttribute[attrprefix.brand ?? 'brand'] = 'rplurand';
        prefixToAttribute[attrprefix.author ?? 'authors'] = 'rpluthor';
        prefixToAttribute[attrprefix.stock_status ?? 'stockStatus'] = 'rplutock_status';
        prefixToAttribute[attrprefix.sale_status ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.sale_status ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.min_length ?? 'min_length'] = 'min_length';
        prefixToAttribute[attrprefix.max_length ?? 'max_length'] = 'max_length';
        prefixToAttribute[attrprefix.length ?? 'length'] = 'length';
        prefixToAttribute[attrprefix.width ?? 'width'] = 'width';
        prefixToAttribute[attrprefix.height ?? 'height'] = 'height';
        prefixToAttribute[attrprefix.weight ?? 'weight'] = 'weight';
        prefixToAttribute[attrprefix.sku ?? 'sku'] = 'sku';
        prefixToAttribute[attrprefix.discount ?? 'discount'] = 'discount';
        prefixToAttribute[attrprefix.date_filter ?? 'date'] = 'date_filter';
        const searchPrefix = (attrprefix.plugincy_search && attrprefix.plugincy_search !== '') ? attrprefix.plugincy_search : 'title';
        prefixToAttribute[searchPrefix] = 'plugincy_search';
        if (attrprefix && attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) {
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }
        if (attrprefix.custom) {
            for (const [customName, prefix] of Object.entries(attrprefix.custom)) {
                if (prefix) {
                    prefixToAttribute[prefix] = customName;
                }
            }
        }
        const getLabelPrefix = (key, fallback) => attrprefix[key] ?? key ?? fallback ?? '';
        const resolvePrefixKey = (key, fallback) => (key && key !== '' && prefixToAttribute[key] !== undefined ? key : fallback);

        const dimensionRanges = [
            { key: attrprefix.length ?? 'length', min: 'min_length', max: 'max_length', cls: 'checked-length-range' },
            { key: attrprefix.width ?? 'width', min: 'min_width', max: 'max_width', cls: 'checked-width-range' },
            { key: attrprefix.height ?? 'height', min: 'min_height', max: 'max_height', cls: 'checked-height-range' },
            { key: attrprefix.weight ?? 'weight', min: 'min_weight', max: 'max_weight', cls: 'checked-weight-range' }
        ];
        const activeRanges = dimensionRanges.map(cfg => ({
            ...cfg,
            range: getActiveRangeFilter(cfg.min, cfg.max)
        }));
        const skipRangeKeys = new Set();
        activeRanges.forEach(({ min, max, range }) => {
            if (range) {
                skipRangeKeys.add(min);
                skipRangeKeys.add(max);
            }
        });

        const selected = store_selected_values();
        const ratingLabelPrefix = attrprefix.rating ?? 'rating';
        const showInActiveFilters = (dapfforwc_styleoptions && dapfforwc_styleoptions.show_in_active_filters) || {};
        const dimensionKeys = new Set(dimensionRanges.map(({ key }) => key));
        const normalizeActiveFilterKey = (filterKey) => {
            if (!filterKey) return '';
            let key = String(filterKey);
            if (prefixToAttribute[key]) {
                key = prefixToAttribute[key];
            }
            key = key.replace(/\[\]$/, '');

            const attrMatch = key.match(/^attribute\[(.+?)\]/);
            if (attrMatch) {
                key = attrMatch[1];
            }

            const customMatch = key.match(/^custom_meta\[(.+?)\]/);
            if (customMatch) {
                key = customMatch[1];
            }

            if (prefixToAttribute[key]) {
                key = prefixToAttribute[key].replace(/\[\]$/, '');
            }

            if (dimensionKeys.has(key)) {
                return 'dimensions';
            }

            if (key.startsWith('rplugpa_')) {
                key = key.replace(/^rplugpa_/, '');
            }
            if (key.startsWith('rplugcusf_')) {
                key = key.replace(/^rplugcusf_/, '');
            }

            const map = {
                'product-category': 'product-category',
                'cata': 'product-category',
                'tag': 'tag',
                'tags': 'tag',
                'price_range': 'price',
                'price': 'price',
                'mn_price': 'price',
                'mx_price': 'price',
                'rating': 'rating',
                'rplurand': 'brands',
                'brand': 'brands',
                'rpluthor': 'authors',
                'author': 'authors',
                'rplutock_status': 'status',
                'stockStatus': 'status',
                'rpn_sale': 'sale_status',
                'saleStatus': 'sale_status',
                'length': 'dimensions',
                'width': 'dimensions',
                'height': 'dimensions',
                'weight': 'dimensions',
                'min_length': 'dimensions',
                'max_length': 'dimensions',
                'min_width': 'dimensions',
                'max_width': 'dimensions',
                'min_height': 'dimensions',
                'max_height': 'dimensions',
                'min_weight': 'dimensions',
                'max_weight': 'dimensions',
                'sku': 'sku',
                'discount': 'discount',
                'date_filter': 'date_filter',
                'date': 'date_filter',
                'plugincy_search': 'search',
            };

            return map[key] ?? key;
        };
        const shouldShowActiveFilter = (filterKey) => {
            const normalizedKey = normalizeActiveFilterKey(filterKey);
            if (!normalizedKey) return true;
            const setting = showInActiveFilters[normalizedKey];
            return setting === undefined || String(setting).toLowerCase() !== 'no';
        };
        const add = (filterKey, id, label, value, extraCls = '') => {
            if (!shouldShowActiveFilter(filterKey)) return;
            const key = `${filterKey || 'default'}::${value}`;
            if (addedKeys.has(key)) return;
            addedKeys.add(key);
            const li = document.createElement('li');
            li.className = `checked ${extraCls}`.trim();
            li.dataset.filterKey = filterKey || '';
            li.dataset.filterValue = value;
            li.innerHTML =
                `<input id="${id}" type="checkbox" value="${value}" checked>
       <label for="${id}">${label}</label>
       <label style="font-size:12px;margin-left:5px;">x</label>`;
            frag.appendChild(li);
        };


        const fieldValues = [
            { name: 'sku', key: attrprefix.sku ?? 'sku', cls: 'checked-sku-field' },
            { name: 'discount', key: attrprefix.discount ?? 'discount', cls: 'checked-discount-field' },
            { name: 'date_filter', key: attrprefix.date_filter ?? 'date', cls: 'checked-date-filter-field' }
        ];
        fieldValues.forEach(({ name, key, cls }) => {
            const val = (($form.find(`[name="${name}"]`).val()) ?? '').toString().trim();
            if (!val) return;
            const prefix = getLabelPrefix(key, key);
            add(name, `selected_${name}`, `${prefix}: ${val}`, val, cls);
        });

        if (Array.isArray(selected)) {
            for (const v of selected) add('selected', `selected_${v}`, v.replace(/-/g, ' '), v);
        } else if (selected && typeof selected === 'object') {
            for (const k in selected) {
                if (skipRangeKeys.has(k)) continue;
                const customLabelPrefix = (() => {
                    if (!k) return '';
                    const matchCustom = k.startsWith('rplugcusf_')
                        ? k.replace('rplugcusf_', '')
                        : (k.startsWith('custom_meta[') ? k.replace(/^custom_meta\[(.+?)\].*$/, '$1') : '');
                    if (!matchCustom) return '';
                    const customName = matchCustom;
                    const prefixKey = (attrprefix.custom && attrprefix.custom[customName]) ? attrprefix.custom[customName] : customName;
                    return getLabelPrefix(prefixKey, customName).replace(/[_-]/g, ' ');
                })();
                for (const v of selected[k]) {
                    const formattedLabel = v.replace(/-/g, ' ');
                    const label = customLabelPrefix
                        ? `${customLabelPrefix}: ${formattedLabel}`
                        : ((/rating/i.test(k)) ? `${ratingLabelPrefix}: ${formattedLabel}` : formattedLabel);
                    add(k, `selected_${k}_${v}`, label, v);
                }
            }
        }

        const sv = $('input#plugincy-search-field').val();
        const searchLabelPrefix = resolvePrefixKey(searchPrefix, 'title');
        if (sv) add('plugincy_search', 'selected_search', `${searchLabelPrefix === 'title' ? 'Searched' : searchLabelPrefix}: ${sv.replace(/-/g, ' ')}`, sv, 'checked-plugincy-search-field');

        const priceRange = getActivePriceRange();
        if (priceRange) {
            const formatCurrency = (val) => `${currencySymbol ? currencySymbol + ' ' : ''}${val}`;
            add(
                'price_range',
                'selected_price_range',
                `${(attrprefix.price ?? 'price')}: ${formatCurrency(priceRange.min)} - ${formatCurrency(priceRange.max)}`,
                `${priceRange.min}-${priceRange.max}`,
                'checked-price-range'
            );
        }

        activeRanges.forEach(({ key, min, max, cls, range }) => {
            if (!range) return;
            const prefix = getLabelPrefix(key, key);
            const valueLabel = `${range.min || range.defaultMin || ''}-${range.max || range.defaultMax || ''}`;
            add(key, `selected_${min}_${max}`, `${prefix}: ${valueLabel}`, valueLabel, cls);
        });

        // Replace children in one go for all matching lists
        lists.forEach((listEl) => {
            listEl.replaceChildren(frag.cloneNode(true));
        });
    }


    // pagination handle

    let selectedValesbyuser = store_selected_values();

    selectedFilterShowProductTop();

    /**
     * Bind events to filter form elements
     */
    function bindFilterEvents($form) {
        // Handle filter changes with debounce
        let debounceTimer;

        if ((!dapfforwc_styleoptions.apply_behavior || !dapfforwc_styleoptions.show_apply_button || !dapfforwc_styleoptions.show_apply_reset_on) || (dapfforwc_styleoptions.show_apply_reset_on && dapfforwc_styleoptions.show_apply_reset_on.reset_btn === "separate") || (dapfforwc_styleoptions.apply_behavior && dapfforwc_styleoptions.apply_behavior.reset_btn !== "only_apply") || (dapfforwc_styleoptions.show_apply_button && dapfforwc_styleoptions.show_apply_button.reset_btn !== "yes")) {
            // Track checkbox and radio changes
            $form.on('change', dapfforwc_FILTER.filterTriggers, function () {
                filterState.pendingChanges = true;

                selectedValesbyuser = store_selected_values();

                selectedFilterShowProductTop();

                debounceRun(function () {
                    if (filterState.pendingChanges) handleFilterChange($form);
                });
            });

            $('.rfilterbuttons').on('change', function () {
                selectedFilterShowProductTop();
                filterState.pendingChanges = true;
                debounceRun(function () {
                    if (filterState.pendingChanges) handleFilterChange($form);
                });
            });

            // Handle price range inputs
            $form.on('input', 'input[type="range"]', function () {
                updatePriceDisplay($(this));
            });

            // Handle search button click
            $form.on('click', dapfforwc_FILTER.searchButton, function (e) {
                e.preventDefault();
                handleFilterChange($form);
            });

            // Handle search on enter key
            $(dapfforwc_FILTER.searchField).on('keypress', function (e) {
                if (e.which === 13) {
                    e.preventDefault();
                    handleFilterChange($form);
                }
            });


            // Run filter when search text is cleared (no need to press enter)
            const triggerSearchClear = function () {
                filterState.pendingChanges = true;
                selectedValesbyuser = store_selected_values();
                selectedFilterShowProductTop();
                debounceRun(function () {
                    if (filterState.pendingChanges) handleFilterChange($form);
                });
            };
            $(dapfforwc_FILTER.searchField).on('input change', function () {
                if (($(this).val() || '').trim() === '') {
                    triggerSearchClear();
                }
            });
        } else {
            // Handle apply button click
            $form.on('click', '.dapfforwc-apply-filters-btn', function (e) {
                e.preventDefault();
                e.stopPropagation();
                filterState.pendingChanges = true;

                selectedValesbyuser = store_selected_values();

                selectedFilterShowProductTop();

                debounceRun(function () {
                    if (filterState.pendingChanges) handleFilterChange($form);
                });
            });

            $form.on('click', dapfforwc_FILTER.searchButton, function (e) {
                e.preventDefault();
                handleFilterChange($form);
            });
        }

        // Reset all filters in the same .plugincy-filter-group as the clicked .close button
        $(document).on('click', '.reset-value', function () {
            const $filterGroup = $(this).closest('.plugincy-filter-group');
            $filterGroup.find('.items input').each(function () {
                if (this.type === 'checkbox' || this.type === 'radio') {
                    $(this).prop('checked', false);
                }
            });
            $filterGroup.find('.items select').each(function () {
                $(this).prop('selectedIndex', 0);
            });
            $filterGroup.find('.items input[type="text"], .items input[type="search"]').each(function () {
                $(this).val('');
            });
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });

        // Handle reset button click
        $form.on('click', '.dapfforwc-reset-filters-btn', function (e) {
            e.preventDefault(); // Prevent default form submission
            e.stopPropagation(); // Stop event bubbling

            const $form = $(dapfforwc_FILTER.formSelector);

            // Reset all checkboxes and radio buttons
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);

            // Reset all select dropdowns to first option
            $form.find('select').each(function () {
                $(this).prop('selectedIndex', 0);
                // If using Select2, trigger change event
                if ($(this).hasClass('select2-hidden-accessible')) {
                    $(this).trigger('change.select2');
                }
            });

            // Reset all text and search inputs
            $form.find('input[type="text"], input[type="search"]').val('');


            // Reset dimension ranges
            resetRangeFilterToDefaults('min_length', 'max_length');
            resetRangeFilterToDefaults('min_width', 'max_width');
            resetRangeFilterToDefaults('min_height', 'max_height');
            resetRangeFilterToDefaults('min_weight', 'max_weight');


            // Reset price range sliders ONLY if they have changed from defaults
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                const defaultMin = $minRange.attr('min');
                const defaultMax = $maxRange.attr('max');
                const currentMin = $minRange.val();
                const currentMax = $maxRange.val();

                // Only reset price if it has changed from default values
                const priceHasChanged = (currentMin !== defaultMin || currentMax !== defaultMax);

                if (priceHasChanged) {
                    $minRange.val(defaultMin);
                    $maxRange.val(defaultMax);

                    // Update the visual display
                    updatePriceDisplay($minRange);
                    updatePriceDisplay($maxRange);

                    // Reset the price input fields
                    $('#min-price').val(defaultMin);
                    $('#max-price').val(defaultMax);

                    // Reset the progress bar to default position
                    const minPriceDefault = parseFloat(defaultMin) || 0;
                    const maxPriceDefault = parseFloat(defaultMax) || 100;

                    $('.plugrogress').css({
                        'left': '0%',
                        'right': '0%'
                    });

                    // Update price labels to default
                    changePseudoElementContent(defaultMin, defaultMax);
                }
            }

            // Clear search field specifically
            $('input#plugincy-search-field').val('');

            // Reset the rfilterbuttons if they exist
            if ($('.rfilterbuttons ul').length) {
                $('.rfilterbuttons ul li').removeClass('checked');
                $('.rfilterbuttons ul li input').prop('checked', false);
            }

            // Update the stored selected values
            selectedValesbyuser = store_selected_values();

            // Update the selected filters display
            selectedFilterShowProductTop();

            // Sync checkbox selections
            syncCheckboxSelections();

            // Clear filter state
            filterState.pendingChanges = true;

            // Trigger the filter change to reload products
            handleFilterChange($form, 1); // Reset to page 1

            // Update URL to remove all filter parameters
            const baseUrl = window.location.href.split('?')[0].replace(/\/filters\/[^?]*/, '');
            window.history.pushState({ dapfforwcFilter: true }, '', baseUrl);
        });


        // Track search clear to auto-restore products without needing Enter
        (function () {
            const $search = $(dapfforwc_FILTER.searchField);
            if (!$search.length) return;
            let lastSearchValue = ($search.val() || '').trim();
            $search.on('input', function () {
                const current = ($(this).val() || '').trim();
                if (current === '' && lastSearchValue !== '') {
                    filterState.pendingChanges = true;
                    selectedValesbyuser = store_selected_values();
                    selectedFilterShowProductTop();
                    debounceRun(function () {
                        if (filterState.pendingChanges) handleFilterChange($form);
                    });
                }
                lastSearchValue = current;
            });
        })();

    }

    $('.rfilterselected').on('click', 'li', function (e) {
        e.preventDefault();
        const $item = $(this);
        const $form = $(dapfforwc_FILTER.formSelector);
        const filterKey = $item.data('filterKey');
        const value = $item.data('filterValue') ?? $item.find('input').val();
        let changeEventTriggered = false;
        if ($item.hasClass('checked-plugincy-search-field')) {
            $('input#plugincy-search-field').val('');
        } else if ($item.hasClass('checked-price-range')) {
            resetPriceRangeToDefaults();
        } else if ($item.hasClass('checked-length-range')) {
            resetRangeFilterToDefaults('min_length', 'max_length');
        } else if ($item.hasClass('checked-width-range')) {
            resetRangeFilterToDefaults('min_width', 'max_width');
        } else if ($item.hasClass('checked-height-range')) {
            resetRangeFilterToDefaults('min_height', 'max_height');
        } else if ($item.hasClass('checked-weight-range')) {
            resetRangeFilterToDefaults('min_weight', 'max_weight');
        } else if ($item.hasClass('checked-sku-field')) {
            $form.find('[name="sku"]').val('').trigger('change');
            changeEventTriggered = true;
        } else if ($item.hasClass('checked-discount-field')) {
            $form.find('[name="discount"]').val('').trigger('change');
            changeEventTriggered = true;
        } else if ($item.hasClass('checked-date-filter-field')) {
            $form.find('[name="date_filter"]').val('').trigger('change');
            changeEventTriggered = true;
        } else {
            const inputSelector = filterKey
                ? `input[name="${filterKey}"][value="${value}"]`
                : `input[value="${value}"]`;
            $form.find(inputSelector).prop('checked', false);
            const $selects = filterKey
                ? $form.find(`select[name="${filterKey}"]`)
                : $form.find('select');
            $selects.each(function () {
                const $option = $(this).find(`option[value="${value}"]`);
                if ($option.length) {
                    $option.prop('selected', false);
                    $(this).trigger('change');
                    changeEventTriggered = true;
                }
            });
        }
        selectedValesbyuser = store_selected_values();
        selectedFilterShowProductTop();
        if (!changeEventTriggered) {
            handleFilterChange($form);
        }
    });

    $('#product-filter').on('change', 'input', function () {
        const name = $(this).attr('name');
        const value = $(this).val();
        const checked = $(this).is(':checked');
        // Find all inputs with same name and value, except the one just changed
        $(`#product-filter input[name="${name}"][value="${value}"]`).not(this).prop('checked', checked);
    });

    /**
     * Handle changes to filter form elements
     */
    function handleFilterChange($form, $page = 1, $isCacheOnly = false) {
        filterState.pendingChanges = false;
        const normalizedPage = parsePageNumber($page) || 1;
        filterState.pendingPage = normalizedPage;
        if (typeof window !== 'undefined') {
            window.dapfforwcDnwooCurrentPage = normalizedPage;
        }

        // Check if we're already processing a request
        if (filterState.isLoading) {
            return false;
        }

        // Get the serialized form data
        // Serialize form data, but remove fields where value is "any"
        let formArray = $form.serializeArray().filter(function (item) {
            return item.value !== "Any";
        });

        // Get current price range values (prioritize the number inputs so manual typing isn't lost)
        const $rangeMin = $form.find('.range-min');
        const $rangeMax = $form.find('.range-max');
        const $numberMin = $form.find('input[name="mn_price"]');
        const $numberMax = $form.find('input[name="mx_price"]');

        const hasNumberPrice = $numberMin.length && $numberMax.length;
        const hasRangePrice = $rangeMin.length && $rangeMax.length;

        let priceHasChanged = false;
        if (hasNumberPrice || hasRangePrice) {
            // Get default min/max prices
            const defaultMinPrice = (hasNumberPrice ? $numberMin.attr('min') : $rangeMin.attr('min')) || '';
            const defaultMaxPrice = (hasNumberPrice ? $numberMax.attr('max') : $rangeMax.attr('max')) || '';

            // Get current min/max prices (fall back to defaults when empty)
            const currentMinPrice = (hasNumberPrice ? $numberMin.val() : $rangeMin.val()) || defaultMinPrice;
            const currentMaxPrice = (hasNumberPrice ? $numberMax.val() : $rangeMax.val()) || defaultMaxPrice;

            // Check if price has changed from defaults
            priceHasChanged = (
                currentMinPrice !== defaultMinPrice ||
                currentMaxPrice !== defaultMaxPrice
            );
        }

        // Filter out price parameters if they haven't changed
        if (!priceHasChanged && (hasNumberPrice || hasRangePrice)) {
            formArray = formArray.filter(function (item) {
                return item.name !== 'mn_price' && item.name !== 'mx_price';
            });
        }

        // Merge duplicate fields (e.g., product-category[]) into comma-separated values
        const merged = {};
        formArray.forEach(function (item) {
            if (merged[item.name]) {
                merged[item.name].push(item.value);
            } else {
                merged[item.name] = [item.value];
            }
        });

        // Build param string with comma-separated values for arrays
        const mergedArray = [];
        for (const key in merged) {
            // Remove duplicate values for each key
            const uniqueValues = Array.from(new Set(merged[key]));
            if (uniqueValues.length > 1) {
                mergedArray.push({
                    name: key,
                    value: uniqueValues.join(',')
                });
            } else {
                mergedArray.push({
                    name: key,
                    value: uniqueValues[0]
                });
            }
        }
        const formData = $.param(mergedArray);

        let product_show_settings = $form.data("product_show_settings");
        if (typeof product_show_settings === "string") {
            try {
                product_show_settings = JSON.parse(product_show_settings);
            } catch (e) {
                product_show_settings = {};
            }
        } else if (typeof product_show_settings !== "object" || product_show_settings === null) {
            product_show_settings = {};
        }

        // Access each value
        let perPage = product_show_settings.per_page;          // "5"
        let orderBy = $(dapfforwc_FILTER.sortingSelector).val() === "menu_order" ? product_show_settings.orderby : $(dapfforwc_FILTER.sortingSelector).val();          // "date"
        let order = product_show_settings.order;               // "DESC"
        const perPageNumeric = parsePageNumber(perPage);
        filterState.perPage = perPageNumeric;

        // Build the query URL
        let currentUrl = window.location.href.split('?')[0];
        currentUrl = currentUrl.replace(/\/filters\/[^?]*/, '/?');
        // Remove any trailing "?" if no query follows
        if (currentUrl.endsWith('?')) {
            currentUrl = currentUrl.slice(0, -1);
        }
        const queryString = formData
            .replace(/\+/g, '%20')
            .replace(/%5B/g, '')
            .replace(/%5D/g, '')
            .replace(/attribute/g, 'rplugpa_')
            .replace(/custom_meta/g, 'rplugcusf_');
        const attrprefix = (typeof dapfforwc_seo_permalinks_options !== 'undefined' && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
        const paginationPrefix = (attrprefix && attrprefix.pagination && attrprefix.pagination !== '') ? attrprefix.pagination : 'paged';

        let fullUrl;
        fullUrl = currentUrl + (queryString ? '?' + queryString : '');
        if ($page != null) {
            const pageParams = [`paged=${$page}`, `product-page=${$page}`];
            if (paginationPrefix && paginationPrefix !== 'paged' && paginationPrefix !== 'product-page') {
                pageParams.push(`${encodeURIComponent(paginationPrefix)}=${$page}`);
            }
            const pageParam = pageParams.join('&');
            fullUrl += (queryString ? '&' : '?') + pageParam;
        }
        if (orderBy) {
            fullUrl += `&orderby=${orderBy}`;
        }
        if (!isProductArchive) {
            if (perPage) {
                fullUrl += `&per_page=${perPage}`;
            }
            if (order) {
                fullUrl += `&order=${order}`;
            }
        }

        let cat_operator = product_show_settings.cat_operator;
        if (cat_operator) {
            fullUrl += `&cat_operator=${cat_operator}`;
        }
        let tag_operator = product_show_settings.tag_operator;
        if (tag_operator) {
            fullUrl += `&tag_operator=${tag_operator}`;
        }
        let terms_operator = product_show_settings.terms_operator;
        if (terms_operator) {
            fullUrl += `&terms_operator=${terms_operator}`;
        }
        let brand_operator = product_show_settings.brand_operator;
        if (brand_operator) {
            fullUrl += `&brand_operator=${brand_operator}`;
        }


        const hasRange = hasRangePrice;

        const default_min_price = (hasRange ? $rangeMin.attr('min') : $numberMin.attr('min')) ?? '';
        const default_max_price = (hasRange ? $rangeMax.attr('max') : $numberMax.attr('max')) ?? '';

        if (default_min_price && default_max_price) {
            fullUrl += `&default_min=${default_min_price}`;
            fullUrl += `&default_max=${default_max_price}`;
        }

        if (!fullUrl.includes('gm_pf_fragment=1')) {
            fullUrl += (fullUrl.includes('?') ? '&' : '?') + 'gm_pf_fragment=1';
        }

        if ($isCacheOnly) {
            // Get the full HTML of the current document
            const cachedHtml = buildCachedHtmlWithFormState(fullUrl);
            plugincyResponseCache.set(fullUrl, cachedHtml);
        } else {
            loadFilteredContentAjax(fullUrl, formData, currentUrl);
        }
        return true;
    }


    /**
     * Ensure cached HTML keeps real image sources even when a lazy-load plugin delays swaps
     */
    function normalizeLazyImagesInRoot(root) {
        if (!root || typeof root.querySelectorAll !== 'function') {
            return;
        }

        const isPlaceholderSrc = (src) => {
            if (!src) return true;
            const trimmed = String(src).trim();
            if (!trimmed) return true;
            return /^data:image\/(?:gif|png|jpe?g)/i.test(trimmed) || /(?:placeholder|transparent|pixel)/i.test(trimmed);
        };

        const applyLazyValue = (el, sourceAttr, targetAttr, allowPlaceholderOverride = true) => {
            const val = el.getAttribute(sourceAttr);
            if (!val) return;
            const current = el.getAttribute(targetAttr);
            if (!current || (allowPlaceholderOverride && isPlaceholderSrc(current))) {
                el.setAttribute(targetAttr, val);
            }
        };

        root.querySelectorAll('img, source').forEach((node) => {
            const tag = (node.tagName || '').toLowerCase();
            if (tag === 'source') {
                applyLazyValue(node, 'data-srcset', 'srcset', false);
                applyLazyValue(node, 'data-lazy-srcset', 'srcset', false);
                applyLazyValue(node, 'data-sizes', 'sizes', false);
                applyLazyValue(node, 'data-lazy-sizes', 'sizes', false);
                return;
            }
            applyLazyValue(node, 'data-src', 'src');
            applyLazyValue(node, 'data-lazy-src', 'src');
            applyLazyValue(node, 'data-srcset', 'srcset', false);
            applyLazyValue(node, 'data-lazy-srcset', 'srcset', false);
            applyLazyValue(node, 'data-sizes', 'sizes', false);
            applyLazyValue(node, 'data-lazy-sizes', 'sizes', false);
        });
    }

    /**
     * Prepare HTML string for caching so lazy images render correctly when reused
     */
    function prepareHtmlForCache(htmlString, { preserveDocument = false } = {}) {
        if (typeof htmlString !== 'string' || htmlString.trim() === '') {
            return htmlString;
        }
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            normalizeLazyImagesInRoot(doc);
            if (preserveDocument) {
                return doc.documentElement.outerHTML;
            }
            return (doc.body && doc.body.innerHTML) ? doc.body.innerHTML : doc.documentElement.outerHTML;
        } catch (error) {
            console.error('Error preparing HTML for cache:', error);
            return htmlString;
        }
    }
    /**
     * Load filtered content via AJAX
     */

    function loadFilteredContentAjax(url, formData, currentUrl) {
        if (typeof plugincydebugLog === 'function') {
            plugincydebugLog("Data Fetching From", url);
        }
        const $form = $(dapfforwc_FILTER.formSelector);

        saveCollapseState();

        // Abort any pending request
        if (filterState.currentRequest) {
            filterState.currentRequest.abort();
        }

        // Set loading state
        setLoadingState(true);

        if (plugincyResponseCache.has(url)) {
            renderAjaxHTML(plugincyResponseCache.get(url), currentUrl, url); // new helper below
            window.re_initSelect2_Collaps();
            resetPaginationInteractionState();
            setTimeout(() => {
                setLoadingState(false);
            }, 200); // 1000 milliseconds = 1 second
            return;
        }


        // Add X-Requested-With header for WordPress to detect AJAX
        filterState.currentRequest = $.ajax({
            url: url,
            method: 'GET',
            dataType: 'html',
            cache: true,
            ifModified: false,
            headers: { 'X-Requested-With': 'XMLHttpRequest' },
            dapfforwc: true,
            success: function (response) {
                const cachedHtml = prepareHtmlForCache(response);
                plugincyResponseCache.set(url, cachedHtml);
                if (plugincyResponseCache.size > CACHE_MAX) {
                    const firstKey = plugincyResponseCache.keys().next().value;
                    plugincyResponseCache.delete(firstKey);
                }

                renderAjaxHTML(cachedHtml, currentUrl, url);

            },
            error: function (xhr, status, error) {
                if (status !== 'abort') {
                    console.error('Filter request failed:', error);
                }
            },
            complete: function (_jqXHR, _status) {
                setLoadingState(false);
                filterState.currentRequest = null;
                resetPaginationInteractionState();
                // If the user changed something during the request, immediately run the latest state.
                if (filterState.pendingChanges) {
                    debounceRun(function () {
                        handleFilterChange($(dapfforwc_FILTER.formSelector));
                    });
                }
            }


        });
    }


    function renderAjaxHTML(response, currentUrl, url) {
        // Create a temporary DOM element to parse the fetched HTML
        const tempDiv = $('<div>').html(response);
        const attrprefix = (dapfforwc_seo_permalinks_options && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
        const searchPrefix = (attrprefix && attrprefix.plugincy_search && attrprefix.plugincy_search !== '') ? attrprefix.plugincy_search : 'title';
        const paginationPrefix = (attrprefix && attrprefix.pagination && attrprefix.pagination !== '') ? attrprefix.pagination : 'paged';
        const activePage = parsePageNumber(filterState.pendingPage) || parsePageNumber(filterState.currentPage) || 1;
        const $currentForm = $(dapfforwc_FILTER.formSelector);
        const appendRangeParam = (paramsObj, minName, maxName, key) => {
            const range = getActiveRangeFilter(minName, maxName);
            if (!range) return;
            const value = `${range.min || range.defaultMin || ''}-${range.max || range.defaultMax || ''}`;
            const safeKey = key && key !== '' ? key : minName.replace(/^min_/, '').replace(/^max_/, '');
            paramsObj.set(safeKey, value);
        };
        const appendFieldParam = (paramsObj, name, key) => {
            const val = (($currentForm.find(`[name="${name}"]`).val()) ?? '').toString().trim();
            if (val) paramsObj.set(key && key !== '' ? key : name, val);
        };
        if (dapfforwc_options.use_url_filter !== "ajax") {
            // Update browser history / url with transformed URL if necessary
            if (dapfforwc_seo_permalinks_options &&
                dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks !== "on") {
                let selectedValuesByUser = store_selected_values(); // Assuming this returns an object

                // Extract values from the object
                let filtersArray = [];

                // Loop through the object and collect values
                for (let key in selectedValuesByUser) {
                    if (Array.isArray(selectedValuesByUser[key])) {
                        filtersArray.push(...selectedValuesByUser[key]); // Spread values into the filters array
                    }
                }

                // Convert to a comma-separated string
                let filters = filtersArray.join(',');
                let searchval = $("input#plugincy-search-field").val();
                const priceRange = getActivePriceRange();

                const params = new URLSearchParams();
                if (filters && filters !== '') {
                    params.set('filters', filters);
                } else if (searchval && searchval !== '') {
                    params.set('filters', '');
                }
                if (searchval && searchval !== '') {
                    params.set(searchPrefix, searchval);
                }
                if (priceRange) {
                    params.set('mn_price', priceRange.min);
                    params.set('mx_price', priceRange.max);
                }

                appendRangeParam(params, 'min_length', 'max_length', attrprefix.length ?? 'length');
                appendRangeParam(params, 'min_width', 'max_width', attrprefix.width ?? 'width');
                appendRangeParam(params, 'min_height', 'max_height', attrprefix.height ?? 'height');
                appendRangeParam(params, 'min_weight', 'max_weight', attrprefix.weight ?? 'weight');
                appendFieldParam(params, 'sku', attrprefix.sku ?? 'sku');
                appendFieldParam(params, 'discount', attrprefix.discount ?? 'discount');
                appendFieldParam(params, 'date_filter', attrprefix.date_filter ?? 'date');
                if (activePage > 1) {
                    params.set('paged', activePage);
                    params.set('product-page', activePage);
                    if (paginationPrefix !== 'paged' && paginationPrefix !== 'product-page') {
                        params.set(paginationPrefix, activePage);
                    }
                }


                // Construct the new URL
                let url = currentUrl;
                const paramString = params.toString();
                if (paramString) {
                    url += (url.includes('?') ? '&' : '?') + paramString;
                }

                url = url.replace(/%2C/g, ',');

                // Update the browser history
                window.history.pushState({ dapfforwcFilter: true }, '', url);
            }
            if (dapfforwc_seo_permalinks_options &&
                dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks === "on") {
                url = currentUrl + url.substring(url.indexOf('?'));
                // Transform the URL to SEO format
                let seoUrl = transformToSeoUrl(url, dapfforwc_seo_permalinks_options).replace(/%2C/g, ',');

                // Update the browser history
                window.history.pushState({ dapfforwcFilter: true }, '', seoUrl);
            }
        }

        const isAppendMode = paginationInteraction && paginationInteraction.mode === 'append';
        const appendedProductTargets = new Set();
        let appendedItemCount = 0;

        // Sources from the fetched tempDiv
        const $srcProducts = tempDiv.find(product_selector);
        const $updatedForm = tempDiv.find(dapfforwc_FILTER.formSelector);
        const $srcResultCount = tempDiv.find('.woocommerce-result-count');
        const resultCountData = parseResultCountData($srcResultCount);

        // Update each .products by index
        const $targetsProducts = $(product_selector);
        if ($targetsProducts.length) {
            if (isAppendMode) {
                $targetsProducts.each(function (i) {
                    const $target = $(this);
                    let $source = $srcProducts.eq(i);
                    if (!$source.length) {
                        $source = $srcProducts.eq(0);
                    }
                    if (!$source || !$source.length) return;
                    const $newItems = $source.children().clone();
                    if ($newItems.length) {
                        appendedItemCount += $newItems.length;
                        $target.append($newItems);
                        appendedProductTargets.add($target.get(0));
                    }
                });
            } else {
                const html = $srcProducts.length ? $srcProducts.eq(0).html() : '<p class="woocommerce-info">' + escapeHtml(TEXTS.no_products) + '</p>';
                // If there are N targets but only 1 source, reuse its HTML
                $targetsProducts.each(function (i) {
                    $(this).html($srcProducts.length > 1 ? $srcProducts.eq(i).html() : html);
                });
            }
        }

        filterState.currentPage = filterState.pendingPage || filterState.currentPage || 1;

        // Update each pagination / load-more container individually
        const paginationTargetsList = paginationSelectors.length ? paginationSelectors : ['.plugincy-filter-pagination'];
        paginationTargetsList.forEach(function (selector) {
            if (!selector) return;
            let $targets;
            let $sources;
            try {
                $targets = $(selector);
                $sources = tempDiv.find(selector);
            } catch (_error) {
                return;
            }
            if (!$targets.length) return;
            const pg = $sources.length ? $sources.eq(0).html() : '';
            $targets.each(function (i) {
                $(this).html($sources.length > 1 ? $sources.eq(i).html() : pg);
            });
        });



        // Update result counts by index (if there are multiple)
        const $targetsResultCount = $('.woocommerce-result-count');
        const $productCountSm = $('#rcountproduct');

        const rc = $srcResultCount.length ? $srcResultCount.eq(0).html() : '';
        updateResultCountAndLoadMore({
            originalHtml: rc,
            resultCounts: resultCountData,
            isAppendMode: isAppendMode,
            $targetsResultCount: $targetsResultCount,
            $productCountSm: $productCountSm,
            $targetsProducts: $targetsProducts,
            appendedTargets: appendedProductTargets,
            appendedItemCount: appendedItemCount
        });

        if (dapfforwc_options["update_filter_options"] === "on" && $updatedForm.length) {
            const $children = $updatedForm.children().slice(3);
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.children().slice(3).remove();
            $form.children().eq(2).after($children);
        } else if ((!dapfforwc_options["update_filter_options"] || dapfforwc_options["update_filter_options"] === "off") && $updatedForm.length) {
            const $form = $(dapfforwc_FILTER.formSelector);
            const buildKey = ($countEl) => {
                const $labelField = $countEl.closest('label').find('input, select, option').first();
                const $field = $labelField.length ? $labelField : $countEl.closest('option');
                const $select = $field && $field.length ? $field.closest('select') : $countEl.closest('select');
                const name = $field && $field.length ? ($field.attr('name') || ($select.length ? $select.attr('name') : '')) : ($select.length ? $select.attr('name') : '');
                const value = $field && $field.length ? ($field.val && typeof $field.val === 'function' ? $field.val() : $field.attr('value')) : undefined;
                if (!name || typeof value === 'undefined') {
                    return null;
                }
                return name + "::" + value;
            };
            const updatedCounts = Object.create(null);
            $updatedForm.find('.option_count').each(function () {
                const $count = $(this);
                const key = buildKey($count);
                if (!key) {
                    return;
                }
                const countText = $count.text();
                const parsed = parseInt(countText.replace(/\D+/g, ''), 10);
                updatedCounts[key] = Number.isNaN(parsed) ? 0 : parsed;
            });
            $form.find('.option_count').each(function () {
                const $count = $(this);
                const key = buildKey($count);
                if (!key) {
                    return;
                }
                const newCount = Object.prototype.hasOwnProperty.call(updatedCounts, key) ? updatedCounts[key] : 0;
                $count.html('<span>(</span>' + newCount + '<span>)</span>');

                // Disable input/select if count is zero
                if (newCount === 0) {
                    const $labelField = $count.closest('label').find('input, select').first();
                    const $field = $labelField.length ? $labelField : $count.closest('option');
                    const $select = $field && $field.length ? $field.closest('select') : $count.closest('select');

                    if ($field.length && $field.is('input')) {
                        $field.prop('disabled', true).addClass('disabled');
                    }
                    if ($select.length) {
                        $select.prop('disabled', true).addClass('disabled');
                    }
                } else {
                    const $labelField = $count.closest('label').find('input, select').first();
                    const $field = $labelField.length ? $labelField : $count.closest('option');
                    const $select = $field && $field.length ? $field.closest('select') : $count.closest('select');

                    if ($field.length && $field.is('input')) {
                        $field.prop('disabled', false).removeClass('disabled');
                    }
                    if ($select.length) {
                        $select.prop('disabled', false).removeClass('disabled');
                    }
                }
            });
        }

        selectedFilterShowProductTop();
        syncCheckboxSelections();
        initPriceRangeInputs();

        initScrollPaginationAutoLoad();

        // Auto-scroll to products container                
        // cheaper scroll (skip if already near)
        requestAnimationFrame(scrollToProducts);

        reinitDnwooPagination();

        // Trigger events for other scripts
        $(document).trigger('dapfforwc_filters_updated');
        requestAnimationFrame(function () { $(window).trigger('scroll'); });

        restoreCollapseState();

    }


    function reinitDnwooPagination() {
        if (typeof jQuery === 'undefined') {
            return;
        }
        const $ = jQuery;
        if (!$.fn || typeof $.fn.pagination !== 'function') {
            return;
        }

        $(".dnwoo_product_main_wrapper").each(function () {
            const $wrapper = $(this);
            const $paginateId = $wrapper.find("#dnwoo-paginate-page");
            const dataValues = $paginateId.data("values");

            if (!dataValues || !$paginateId.length) {
                return;
            }

            const signature = JSON.stringify(dataValues);
            if ($paginateId.children().length && $paginateId.data("dapfforwcPaginationSig") === signature) {
                return;
            }
            $paginateId.data("dapfforwcPaginationSig", signature);

            const productGridWrapper = $wrapper.find(".dnwoo_product_grid_wrapper");
            const pagiNav = $wrapper.find(".dnwoo-paginav");
            const topBar = $wrapper.siblings(".dnwoo-show-product-text");
            const divPosition = productGridWrapper.length ? productGridWrapper.offset() : null;
            let getPost = null;
            const storedPage = (typeof window !== 'undefined') ? parsePageNumber(window.dapfforwcDnwooCurrentPage) : null;
            const currentPage = storedPage || parsePageNumber(filterState.currentPage) || 1;
            const productCaching = {
                [currentPage]: productGridWrapper.html(),
            };

            $paginateId.pagination({
                total: dataValues["total"],
                current: currentPage,
                length: +dataValues["products-number"],
                next: "" !== dataValues["next-text"] ? dataValues["next-text"] : "&rarr;",
                prev: "" !== dataValues["prev-text"] ? dataValues["prev-text"] : "&larr;",
                click: function (options, _target) {
                    const { current } = options;
                    if (typeof window !== 'undefined') {
                        window.dapfforwcDnwooCurrentPage = current;
                    }
                    const first = +dataValues["products-number"] * current + 1 - +dataValues["products-number"];
                    const last = Math.min(dataValues["total"], +dataValues["products-number"] * current);

                    if (Object.prototype.hasOwnProperty.call(productCaching, current)) {
                        if (productGridWrapper.length) {
                            productGridWrapper.html(productCaching[current]);
                        }
                        if (topBar.length) {
                            topBar.html(`<p>Showing ${first}&ndash;${last} of ${dataValues["total"]} results</p>`);
                        }
                        if (divPosition) {
                            const pos = divPosition.top - (divPosition.left + 60);
                            $("body, html").animate({ scrollTop: pos });
                        }
                        return;
                    }

                    if (typeof Woo_Essential === 'undefined' || !Woo_Essential.ajaxurl) {
                        return;
                    }

                    if (getPost) getPost.abort();
                    getPost = $.ajax({
                        url: Woo_Essential.ajaxurl,
                        type: "POST",
                        data: {
                            action: "product_grid_pagination",
                            paged: current,
                            carousel_layouts: dataValues["carousel-layouts"],
                            per_page: dataValues["products-number"],
                            offset_number: dataValues["offset-number"],
                            order: dataValues["order"],
                            orderby: dataValues["orderby"],
                            type: dataValues["type"],
                            include_categories: dataValues["include-categories"],
                            hide_out_of_stock: dataValues["out-of-stock"],
                            image_height: dataValues["image-height"],
                            thumbnail_size: dataValues["thumbnail-size"],
                            show_rating: dataValues["show-rating"],
                            show_price_text: dataValues["show-price-text"],
                            show_category: dataValues["show-category"],
                            show_add_to_cart: dataValues["show-add-to-cart"],
                            show_quick_view_button: dataValues["show-quick-view"],
                            orderclass: dataValues["orderclass"],
                            show_add_to_cart_icon: dataValues["addtocarticon"],
                            show_wish_list_icon: dataValues["wishlisticon"],
                            show_add_compare_icon: dataValues["addcompare"],
                            show_quickview_icon: dataValues["quickviewicon"],
                            show_featured_product: dataValues["show-featured"],
                            outofstock_text: dataValues["outofstock-text"],
                            featured_text: dataValues["featured-text"],
                            show_badge: dataValues["show-badge"],
                            sale_text: dataValues["sale-text"],
                            percentage_text: dataValues["percentage-text"],
                            addtocart_text: dataValues["addtocart-text"],
                            dnwoo_quick_view_text: dataValues["quickview-text"],
                            header_level: dataValues["header-level"],
                            current_category: dataValues["current_categories"] || "",
                            current_tags: dataValues["current_tags"] || "",
                            select_option_text: dataValues["select-option-text"],
                            wpf_args: dataValues["wpf-args"],
                        },
                        beforeSend: function () {
                            if (productGridWrapper.length) {
                                productGridWrapper.css("opacity", "0.2");
                            }
                            if (topBar.length) {
                                topBar.css("opacity", "0.2");
                            }
                            if (pagiNav.length) {
                                pagiNav.css({
                                    "pointer-events": "none",
                                    opacity: "0.2",
                                });
                            }
                        },
                        success: function (html) {
                            if (html?.products && html?.products.length > 0) {
                                productCaching[current] = html?.products;
                                if (productGridWrapper.length) {
                                    productGridWrapper.html(html?.products);
                                }
                                if (topBar.length) {
                                    topBar.html(`<p>Showing ${first}&ndash;${last} of ${dataValues["total"]} results</p>`);
                                }
                                if (divPosition) {
                                    const pos = divPosition.top - (divPosition.left + 60);
                                    $("body, html").animate({ scrollTop: pos });
                                }
                            }
                            if (productGridWrapper.length) {
                                productGridWrapper.css("opacity", "1");
                            }
                            if (topBar.length) {
                                topBar.css("opacity", "1");
                            }
                            if (pagiNav.length) {
                                pagiNav.css({
                                    "pointer-events": "initial",
                                    opacity: "1",
                                });
                            }
                        },
                        error: function () {
                            if (productGridWrapper.length) {
                                productGridWrapper.css("opacity", "1");
                            }
                            if (topBar.length) {
                                topBar.css("opacity", "1");
                            }
                            if (pagiNav.length) {
                                pagiNav.css({
                                    "pointer-events": "initial",
                                    opacity: "1",
                                });
                            }
                        }
                    });
                },
            });
        });
    }


    const COLLAPSE_SELECTORS = {
        group: ".plugincy-filter-group",
        title: ".plugincy_title",
        items: ".plugincy-filter-group .items"
    };
    const COLLAPSE_MOBILE_BP = window.__dapfforwc_mobile_bp || 768;
    let collapseMediaQueryBound = false;

    function inferItemsDisplay($items) {
        const cls = $items.attr("class") || "";
        if (/(?:^|\s)(?:image|image_no_border|button_check)(?:\s|$)/.test(cls)) return "grid";
        if (/(?:^|\s)(?:plugincy_color|color_no_border|color_circle)(?:\s|$)/.test(cls)) return "flex";
        return "block";
    }

    function collapseItems($items) {
        $items.addClass("dapfforwc-hidden-important").css("display", "");
    }

    function expandItems($items) {
        $items.removeClass("dapfforwc-hidden-important");
        $items.each(function () {
            const $item = $(this);
            const display = inferItemsDisplay($item);
            this.style.setProperty("display", display, "important");
        });
    }

    function collapseAllSections(context) {
        const $ctx = context ? $(context) : $(document);
        $ctx.find(COLLAPSE_SELECTORS.items).each(function () {
            collapseItems($(this));
        });
        $ctx.find(`${COLLAPSE_SELECTORS.title} svg`).removeClass("rotated");
    }

    let activeTooltipBubble = null;

    function injectTooltipStyles() {
        if (document.getElementById("dapfforwc-tooltip-style")) return;
        const style = document.createElement("style");
        style.id = "dapfforwc-tooltip-style";
        style.textContent = ".dapfforwc-tooltip-bubble{position:absolute;z-index:9999999999;max-width:240px;padding:8px 10px;background:#111;color:#fff;font-size:12px;line-height:1.4;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.18);pointer-events:auto}";
        document.head.appendChild(style);
    }

    function hideTooltipBubble() {
        if (activeTooltipBubble) {
            activeTooltipBubble.remove();
            activeTooltipBubble = null;
        }
    }

    function showTooltipBubble(el) {
        const text = el.getAttribute("title") || el.getAttribute("data-tooltip");
        if (!text) return;
        injectTooltipStyles();
        hideTooltipBubble();
        const bubble = document.createElement("div");
        bubble.className = "dapfforwc-tooltip-bubble";
        bubble.textContent = text;
        document.body.appendChild(bubble);

        const rect = el.getBoundingClientRect();
        const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
        const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
        const top = rect.bottom + scrollY - 20;
        let left = rect.left + scrollX + (rect.width / 2) - (bubble.offsetWidth / 2);
        const maxLeft = Math.max(8, document.documentElement.clientWidth - bubble.offsetWidth - 8 + scrollX);
        left = Math.max(8 + scrollX, Math.min(left, maxLeft));

        bubble.style.top = `${Math.max(8, top)}px`;
        bubble.style.left = `${left}px`;
        activeTooltipBubble = bubble;
    }

    /**
     * Save the current collapse state of all filter widgets
     */
    function saveCollapseState() {
        collapsedWidgetState.clear();

        $(COLLAPSE_SELECTORS.group).each(function (index) {
            const $group = $(this);
            const $title = $group.find(COLLAPSE_SELECTORS.title);
            const $items = $group.children().not(COLLAPSE_SELECTORS.title);

            // Create a unique identifier for this widget
            const widgetId = $title.text().trim() || `widget-${index}`;

            // Check if items are hidden (collapsed)
            const isCollapsed = $items.hasClass("dapfforwc-hidden-important");

            collapsedWidgetState.set(widgetId, {
                isCollapsed: isCollapsed,
                svgRotated: $title.find("svg").hasClass("rotated")
            });
        });
    }

    /**
     * Restore the collapse state of all filter widgets
     */
    function restoreCollapseState() {
        $(COLLAPSE_SELECTORS.group).each(function (index) {
            const $group = $(this);
            const $title = $group.find(COLLAPSE_SELECTORS.title);
            const $items = $group.children().not(COLLAPSE_SELECTORS.title);

            // Get the unique identifier for this widget
            const widgetId = $title.text().trim() || `widget-${index}`;

            // Retrieve saved state
            const savedState = collapsedWidgetState.get(widgetId);

            if (savedState) {
                if (savedState.isCollapsed) {
                    collapseItems($items);
                } else {
                    expandItems($items);
                }

                // Restore SVG rotation
                if (savedState.svgRotated) {
                    $title.find("svg").addClass("rotated");
                } else {
                    $title.find("svg").removeClass("rotated");
                }
            }
        });
    }


    /**
     * Build cacheable HTML with checked/selected states applied from the URL without touching the live DOM
     */
    function buildCachedHtmlWithFormState(fullUrl) {
        try {
            const parser = new DOMParser();
            const clonedDoc = parser.parseFromString(document.documentElement.outerHTML, 'text/html');
            const form = clonedDoc.querySelector(dapfforwc_FILTER.formSelector);
            if (!form) {
                return document.documentElement.outerHTML;
            }

            const urlObj = new URL(fullUrl, window.location.origin);
            const params = urlObj.searchParams;
            const attrprefix = (typeof dapfforwc_seo_permalinks_options !== 'undefined' && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
            const searchParamKeys = [attrprefix.plugincy_search, 'plugincy_search', 'title'].filter(k => k && k !== '');
            const paginationParamKeys = [attrprefix.pagination, 'paged', 'product-page', 'page'].filter(k => k && k !== '');
            const skipKeys = new Set(['gm_pf_fragment', 'orderby', 'per_page', 'cat_operator', 'tag_operator', 'terms_operator', 'brand_operator', 'order', 'default_min', 'default_max', ...paginationParamKeys]);

            form.querySelectorAll('input[type="checkbox"], input[type="radio"]').forEach(el => el.removeAttribute('checked'));
            form.querySelectorAll('select option').forEach(opt => opt.removeAttribute('selected'));

            const setValue = (selectors, val) => {
                selectors.forEach(sel => {
                    form.querySelectorAll(sel).forEach(el => el.setAttribute('value', val));
                });
            };

            const getNameCandidates = (key) => {
                if (key.startsWith('rplugpa_')) {
                    const attrName = key.replace(/^rplugpa_/, '');
                    return [`attribute[${attrName}]`, `attribute[${attrName}][]`];
                }
                if (key.startsWith('rplugcusf_')) {
                    const metaName = key.replace(/^rplugcusf_/, '');
                    return [`custom_meta[${metaName}]`, `custom_meta[${metaName}][]`];
                }
                return [key, `${key}[]`];
            };

            const applyToFields = (names, val) => {
                names.forEach(name => {
                    form.querySelectorAll(`input[name="${name}"]`).forEach(input => {
                        if (input.type === 'checkbox' || input.type === 'radio') {
                            if (input.value === val) {
                                input.setAttribute('checked', 'checked');
                            }
                        } else {
                            input.setAttribute('value', val);
                        }
                    });
                    form.querySelectorAll(`select[name="${name}"] option`).forEach(option => {
                        if (option.value === val) {
                            option.setAttribute('selected', 'selected');
                        }
                    });
                });
            };

            params.forEach((rawValue, key) => {
                if (skipKeys.has(key)) {
                    return;
                }
                const values = (rawValue || '').split(',').map(v => v.trim()).filter(v => v !== '');
                if (!values.length) {
                    return;
                }

                if (searchParamKeys.includes(key)) {
                    setValue(['#plugincy-search-field', 'input[name="plugincy_search"]', 'input[name="title"]'], values[0]);
                    return;
                }

                if (key === 'mn_price') {
                    setValue(['.range-min', 'input[name="mn_price"]'], values[0]);
                    return;
                }
                if (key === 'mx_price') {
                    setValue(['.range-max', 'input[name="mx_price"]'], values[0]);
                    return;
                }

                const nameCandidates = getNameCandidates(key);
                values.forEach(val => applyToFields(nameCandidates, val));
            });

            normalizeLazyImagesInRoot(clonedDoc);
            return clonedDoc.documentElement.outerHTML;
        } catch (error) {
            console.error('Error preparing cached HTML:', error);
            return document.documentElement.outerHTML;
        }
    }

    /**
 * Sync form inputs with URL parameters for cached responses
 * @param {jQuery} $form - The form element to sync
 * @param {string} url - The URL containing filter parameters
 */
    function syncFormStateFromUrl($form, url) {
        try {
            const urlObj = new URL(url);
            const params = urlObj.searchParams;
            const attrprefix = (typeof dapfforwc_seo_permalinks_options !== 'undefined' && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
            const searchParamKeys = [attrprefix.plugincy_search, 'plugincy_search', 'title'].filter(k => k && k !== '');
            const searchParamKeysSet = new Set(searchParamKeys);
            const paginationParamKeysSet = new Set([attrprefix.pagination, 'paged', 'product-page', 'page'].filter(k => k && k !== ''));

            // Reset all inputs first
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select option').prop('selected', false);

            // Process each parameter
            for (const [key, value] of params.entries()) {
                // Skip if value is empty
                if (!value || value.trim() === '') {
                    continue;
                }

                // Skip non-filter parameters
                if (paginationParamKeysSet.has(key) || ['gm_pf_fragment', 'orderby', 'per_page', 'cat_operator', 'tag_operator', 'terms_operator', 'brand_operator', 'order'].includes(key)) {
                    continue;
                }

                // Handle search field
                if (searchParamKeysSet.has(key)) {
                    $form.find('#plugincy-search-field').val(value);
                    continue;
                }

                // Handle price range
                if (key === 'mn_price') {
                    const minPrice = parseFloat(value);
                    if (!isNaN(minPrice) && minPrice > 0) {
                        $form.find('.range-min, input[name="mn_price"]').val(value);
                    }
                    continue;
                }
                if (key === 'mx_price') {
                    const maxPrice = parseFloat(value);
                    if (!isNaN(maxPrice) && maxPrice > 0) {
                        $form.find('.range-max, input[name="mx_price"]').val(value);
                    }
                    continue;
                }

                // Handle comma-separated values
                const values = value.split(',')
                    .map(v => v.trim())
                    .filter(v => v !== '' && v !== 'Any'); // Filter out empty and "Any" values

                // Skip if no valid values
                if (values.length === 0) {
                    continue;
                }

                values.forEach(val => {
                    // Check checkboxes/radios
                    const $checkbox = $form.find(`input[name="${key}"][value="${val}"]`);
                    if ($checkbox.length) {
                        $checkbox.prop('checked', true);
                    }

                    const $checkboxArray = $form.find(`input[name="${key}[]"][value="${val}"]`);
                    if ($checkboxArray.length) {
                        $checkboxArray.prop('checked', true);
                    }

                    // Select options in dropdowns
                    const $selectOption = $form.find(`select[name="${key}"] option[value="${val}"]`);
                    if ($selectOption.length) {
                        $selectOption.prop('selected', true);
                    }

                    const $selectOptionArray = $form.find(`select[name="${key}[]"] option[value="${val}"]`);
                    if ($selectOptionArray.length) {
                        $selectOptionArray.prop('selected', true);
                    }

                    // Handle attribute parameters (rplugpa_)
                    if (key.startsWith('rplugpa_')) {
                        const $attrInput = $form.find(`input[name*="${key}"][value="${val}"]`);
                        if ($attrInput.length) {
                            $attrInput.prop('checked', true);
                        }

                        const $attrSelect = $form.find(`select[name*="${key}"] option[value="${val}"]`);
                        if ($attrSelect.length) {
                            $attrSelect.prop('selected', true);
                        }
                    }

                    // Handle custom parameters (rplugcusf_)
                    if (key.startsWith('rplugcusf_')) {
                        const $customInput = $form.find(`input[name*="${key}"][value="${val}"]`);
                        if ($customInput.length) {
                            $customInput.prop('checked', true);
                        }

                        const $customSelect = $form.find(`select[name*="${key}"] option[value="${val}"]`);
                        if ($customSelect.length) {
                            $customSelect.prop('selected', true);
                        }
                    }
                });
            }

            // Trigger change on select2 elements if present
            const $select2Elements = $form.find('select.select2-hidden-accessible');
            if ($select2Elements.length) {
                $select2Elements.trigger('change.select2');
            }

            // Update price display if price changed
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && params.has('mn_price') && params.get('mn_price').trim() !== '') {
                updatePriceDisplay($minRange);
            }
            if ($maxRange.length && params.has('mx_price') && params.get('mx_price').trim() !== '') {
                updatePriceDisplay($maxRange);
            }

        } catch (error) {
            console.error('Error syncing form state from URL:', error);
        }
    }

    /**
     * Initialize sorting functionality
     */
    function initSorting() {
        // Prevent form submission on pressing Enter
        $('.woocommerce-ordering').on('submit', function (event) {
            event.preventDefault();
        });
        $('.ast-woocommerce-shop-page-modern-style .woocommerce-ordering').on('change', function (e) {
            if ($(e.target).hasClass('orderby')) {
                e.preventDefault(); // Prevent the form submission
                e.stopImmediatePropagation(); // Stop other listeners from being called
                const sortValue = $(this).find('select.orderby').val();
                onsortchange(sortValue);
            }
        });
        $(document).on('change', dapfforwc_FILTER.sortingSelector, function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            const sortValue = $(this).val();
            onsortchange(sortValue);
        });
    }

    function onsortchange(sortValue) {
        // Create or update the orderby hidden input in the filter form
        let $orderbyInput = $('#filter-orderby');
        if ($orderbyInput.length === 0) {
            $orderbyInput = $('<input>').attr({
                type: 'hidden',
                id: 'filter-orderby',
                name: 'orderby',
                value: sortValue
            });
            $(dapfforwc_FILTER.formSelector).append($orderbyInput);
        } else {
            $orderbyInput.val(sortValue);
        }

        // Reset to page 1 when sorting changes
        let $pageInput = $('#filter-page-num');
        if ($pageInput.length) {
            $pageInput.val(1);
        }

        // Trigger filter change with the new sort order
        handleFilterChange($(dapfforwc_FILTER.formSelector));
    }

    /**
     * Set loading state
     */
    function setLoadingState(isLoading) {
        filterState.isLoading = isLoading;
        let isloadingenablebyadmin = dapfforwc_options.show_loader === "on";

        if (isLoading && isloadingenablebyadmin) {
            $('html, body').css('cursor', 'wait');
            showSpinner();
            $(dapfforwc_FILTER.formSelector).addClass(dapfforwc_FILTER.loadingClass);
        } else {
            $('html, body').css('cursor', 'auto');
            hideSpinner();
            $(dapfforwc_FILTER.formSelector).removeClass(dapfforwc_FILTER.loadingClass);
        }
    }

    /**
     * Show loading spinner
     */
    function showSpinner() {
        if (count !== 1) {
            $('#roverlay, #loader').addClass('is-visible');
        }
    }

    /**
     * Hide loading spinner
     */
    function hideSpinner() {
        $('#roverlay, #loader').removeClass('is-visible');
    }

    /**
     * Update price range display
     */
    function updatePriceDisplay($rangeInput) {
        const isMin = $rangeInput.hasClass('range-min');
        const value = Math.ceil(parseFloat($rangeInput.val()));
        const $minInput = $('.range-min');
        const $maxInput = $('.range-max');

        const minValue = Math.floor(parseFloat($minInput.val()) || 0);
        const maxValue = Math.ceil(parseFloat($maxInput.val()) || 0);
        const minPriceDefault = Math.floor(parseFloat($minInput.attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($maxInput.attr('max')) || 100);

        if (isMin) {
            $('#min-price').val(value);
            $('.plugrogress').css('left', ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100) + '%');
        } else {
            $('#max-price').val(value);
            $('.plugrogress').css('right', (100 - ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100)) + '%');
        }

        // Update price display using custom pseudo-element content
        changePseudoElementContent(`${minValue}`, `${maxValue}`, isMin ? 'min' : 'max');

        // Also update the aria-valuetext for accessibility
        if (isMin) {
            $rangeInput.attr('aria-valuetext', `${value}`);
        } else {
            $rangeInput.attr('aria-valuetext', `${value}`);
        }
    }



    function changePseudoElementContent(minValue, maxValue, activeHandle = null) {
        const newLabel = `${minValue}|${maxValue}|${activeHandle || ''}`;
        if (newLabel === lastPriceLabel) return; // nothing changed
        lastPriceLabel = newLabel;

        let styleEl = document.getElementById('price-range-display-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'price-range-display-style';
            document.head.appendChild(styleEl);
        }

        // Set z-index based on which handle is active
        const minZIndex = activeHandle === 'min' ? 10 : 5;
        const maxZIndex = activeHandle === 'max' ? 10 : 5;

        // Calculate percentage positions for min and max handles
        const minPriceDefault = Math.floor(parseFloat($('.range-min').attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($('.range-max').attr('max')) || 100);

        const minPercent = ((minValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;
        const maxPercent = ((maxValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;

        // Check if handles are close to each other (less than 20% apart)
        const areHandlesClose = (maxPercent - minPercent) < 60;


        if (areHandlesClose) {
            let centerPosition;
            // Calculate center position only when handles first get close
            centerPosition = (minPercent + maxPercent) / 2;
            let transform = centerPosition;
            // Prevent the label from going outside the slider bounds
            if (centerPosition < 39) centerPosition = 39;
            if (centerPosition > 70) centerPosition = 0;

            // If handles are close, show combined format in the middle
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue} - ${currencySymbol} ${maxValue}" !important;
                left: ${centerPosition}%;
                transform: translateX(${centerPosition === 0 ? '-' + transform + '%' : '0%'});
                z-index: 10;
            }
            #product-filter .plugrogress-percentage:after {
                content: "" !important;
                display: none;
            }
        `;

        } else {
            // Normal display when handles are far apart
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue}" !important;
                z-index: ${minZIndex};
            }
            #product-filter .plugrogress-percentage:after {
                content: "${currencySymbol} ${maxValue}" !important;
                z-index: ${maxZIndex};
            }
        `;
        }
    }


    function initPriceRangeInputs() {
        const $rangeInputs = $(".range-input input");
        const $priceInputs = $(".price-input input");
        const $range = $(".plugincy_slider .plugrogress");

        if ($rangeInputs.length < 2 || $priceInputs.length < 2) return;

        let minPrice = Math.floor(parseFloat($rangeInputs[0].value) || 0);
        let maxPrice = Math.ceil(parseFloat($rangeInputs[1].value) || 0);
        const minPriceDefault = Math.floor(parseFloat($rangeInputs[0].getAttribute('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($rangeInputs[0].getAttribute('max')) || 100);

        $range.css({
            'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
            'right': 100 - ((maxPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%"
        });

        // Initialize price display
        changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

        // Handle range input changes
        $rangeInputs.off('.pf').on("input.pf", function () {
            // update visual only
            const minVal = Math.floor(parseFloat($rangeInputs.eq(0).val()) || 0);
            const maxVal = Math.ceil(parseFloat($rangeInputs.eq(1).val()) || 0);
            changePseudoElementContent(`${minVal}`, `${maxVal}`);
            $priceInputs.eq(0).val(minVal);
            $priceInputs.eq(1).val(maxVal);
            $range.css({
                'left': ((minVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
                'right': 100 - ((maxVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%"
            });
        });

        $rangeInputs.off('change.pf').on("change.pf", function () {
            if ((!dapfforwc_styleoptions.apply_behavior || !dapfforwc_styleoptions.show_apply_button || !dapfforwc_styleoptions.show_apply_reset_on) || (dapfforwc_styleoptions.show_apply_reset_on && dapfforwc_styleoptions.show_apply_reset_on.reset_btn === "separate") || (dapfforwc_styleoptions.apply_behavior && dapfforwc_styleoptions.apply_behavior.reset_btn !== "only_apply") || (dapfforwc_styleoptions.show_apply_button && dapfforwc_styleoptions.show_apply_button.reset_btn !== "yes")) {

                const $form = $(dapfforwc_FILTER.formSelector);
                debounceRun(function () { handleFilterChange($form); });
            }
        });

        // --- helpers ---
        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function parseNum(v) {
            const n = parseFloat(v);
            return Number.isFinite(n) ? n : NaN;
        }

        function syncUI(minVal, maxVal) {
            // Push values into both text and range inputs
            $priceInputs.eq(0).val(minVal);
            $priceInputs.eq(1).val(maxVal);
            $rangeInputs.eq(0).val(minVal);
            $rangeInputs.eq(1).val(maxVal);

            // Position the filled range relative to [minPriceDefault, maxPriceDefault]
            const span = (maxPriceDefault - minPriceDefault);
            const leftPct = ((minVal - minPriceDefault) / span) * 100;
            const rightPct = ((maxPriceDefault - maxVal) / span) * 100; // fixed calc

            $range.css('left', `${leftPct}%`);
            $range.css('right', `${rightPct}%`);

            // Update bubble/labels
            changePseudoElementContent(String(minVal), String(maxVal));
        }

        function computeClampedPair(rawMin, rawMax) {
            // Start with defaults when NaN
            let minVal = Number.isFinite(rawMin) ? Math.floor(rawMin) : minPriceDefault;
            let maxVal = Number.isFinite(rawMax) ? Math.ceil(rawMax) : maxPriceDefault;

            // Clamp to allowed bounds first
            minVal = clamp(minVal, minPriceDefault, maxPriceDefault);
            maxVal = clamp(maxVal, minPriceDefault, maxPriceDefault);

            // Ensure ordering (min <= max)
            if (minVal > maxVal) {
                // If min overshoots, pull min down to max
                minVal = maxVal;
            }

            return { minVal, maxVal };
        }

        // --- input: let users type anything; do NOT clamp here ---
        $priceInputs.off('.pf').on('input.pf', function () {
            const rawMin = parseNum($priceInputs.eq(0).val());
            const rawMax = parseNum($priceInputs.eq(1).val());

            // Just update the labels live if numbers are present, donâ€™t clamp/rerender range yet
            const liveMin = Number.isFinite(rawMin) ? Math.floor(rawMin) : minPriceDefault;
            const liveMax = Number.isFinite(rawMax) ? Math.ceil(rawMax) : maxPriceDefault;
            changePseudoElementContent(String(liveMin), String(liveMax));
        });

        // --- blur: clamp & apply filter when the user is done ---
        $priceInputs.off('blur.pf').on('blur.pf', function () {
            const rawMin = parseNum($priceInputs.eq(0).val());
            const rawMax = parseNum($priceInputs.eq(1).val());

            const { minVal, maxVal } = computeClampedPair(rawMin, rawMax);
            syncUI(minVal, maxVal);

            if ((!dapfforwc_styleoptions.apply_behavior || !dapfforwc_styleoptions.show_apply_button || !dapfforwc_styleoptions.show_apply_reset_on) || (dapfforwc_styleoptions.show_apply_reset_on && dapfforwc_styleoptions.show_apply_reset_on.reset_btn === "separate") || (dapfforwc_styleoptions.apply_behavior && dapfforwc_styleoptions.apply_behavior.reset_btn !== "only_apply") || (dapfforwc_styleoptions.show_apply_button && dapfforwc_styleoptions.show_apply_button.reset_btn !== "yes")) {

                const $form = $(dapfforwc_FILTER.formSelector);
                handleFilterChange($form);
            }
        });


        // --- enter key: clamp & apply immediately for keyboard submissions ---
        $priceInputs.off('keydown.pf').on('keydown.pf', function (e) {
            if (e.key === 'Enter' || e.which === 13) {
                e.preventDefault();
                const rawMin = parseNum($priceInputs.eq(0).val());
                const rawMax = parseNum($priceInputs.eq(1).val());
                const { minVal, maxVal } = computeClampedPair(rawMin, rawMax);
                syncUI(minVal, maxVal);
                const $form = $(dapfforwc_FILTER.formSelector);
                handleFilterChange($form);
            }
        });

    }


    /**
     * Scroll to products container
     */

    function scrollToProducts() {
        const $t = $(product_selector);
        if (!$t.length) return;
        const targetTop = $t.offset().top - dapfforwc_FILTER.autoScrollOffset;
        const current = window.scrollY || window.pageYOffset;
        if (Math.abs(current - targetTop) < 24) return; // already close
        $('html, body').stop(true).animate({ scrollTop: targetTop }, 300);
    }


    function applyFiltersFromUrl(filtersString) {
        // Check if we're using the new format with attribute types in permalinks
        const urlParams = new URLSearchParams(window.location.search);
        const useNewFormat = urlParams.get('filters') === '1';
        const $form = $(dapfforwc_FILTER.formSelector);

        // Build the query URL
        let currentUrl = window.location.href.split('?')[0];
        currentUrl = currentUrl.replace(/\/filters\/[^?]*/, '/?');

        if (currentUrl.endsWith('?')) {
            currentUrl = currentUrl.slice(0, -1);
        }

        const attrprefix = (dapfforwc_seo_permalinks_options && dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options) || {};
        const searchPrefix = (attrprefix && attrprefix.plugincy_search && attrprefix.plugincy_search !== '') ? attrprefix.plugincy_search : 'title';
        const paginationPrefix = (attrprefix && attrprefix.pagination && attrprefix.pagination !== '') ? attrprefix.pagination : 'paged';
        const pageFromUrl = parsePageNumber(urlParams.get(paginationPrefix))
            || parsePageNumber(urlParams.get('paged'))
            || parsePageNumber(urlParams.get('product-page'))
            || parsePageNumber(urlParams.get('page'));
        if (pageFromUrl) {
            filterState.currentPage = pageFromUrl;
            filterState.pendingPage = pageFromUrl;
            if (typeof window !== 'undefined') {
                window.dapfforwcDnwooCurrentPage = pageFromUrl;
            }
        }

        if (!useNewFormat) {
            const searchFromUrl = urlParams.get(searchPrefix) ?? urlParams.get('title');
            if (searchFromUrl) {
                $("input#plugincy-search-field").val(searchFromUrl);
            }

            const minPriceFromUrl = urlParams.get('mn_price');
            const maxPriceFromUrl = urlParams.get('mx_price');
            if ((minPriceFromUrl && minPriceFromUrl !== '') || (maxPriceFromUrl && maxPriceFromUrl !== '')) {
                const $minRange = $form.find('.range-min');
                const $maxRange = $form.find('.range-max');

                if ($minRange.length && minPriceFromUrl !== null) {
                    $minRange.val(minPriceFromUrl);
                }
                if ($maxRange.length && maxPriceFromUrl !== null) {
                    $maxRange.val(maxPriceFromUrl);
                }

                $form.find('input[name="mn_price"]').val(minPriceFromUrl);
                $form.find('input[name="mx_price"]').val(maxPriceFromUrl);

                if ($minRange.length) updatePriceDisplay($minRange);
                if ($maxRange.length) updatePriceDisplay($maxRange);
            }


            const setRangeFromParam = (minName, maxName, paramName) => {
                const rangeVal = urlParams.get(paramName);
                if (rangeVal && rangeVal.includes('-')) {
                    const [min, max] = rangeVal.split('-');
                    const $minField = $form.find(`input[name="${minName}"]`);
                    const $maxField = $form.find(`input[name="${maxName}"]`);
                    if ($minField.length) $minField.val(min).trigger('change');
                    if ($maxField.length) $maxField.val(max).trigger('change');
                }
            };
            setRangeFromParam('min_length', 'max_length', attrprefix.length ?? 'length');
            setRangeFromParam('min_width', 'max_width', attrprefix.width ?? 'width');
            setRangeFromParam('min_height', 'max_height', attrprefix.height ?? 'height');
            setRangeFromParam('min_weight', 'max_weight', attrprefix.weight ?? 'weight');

            const skuFromUrl = urlParams.get(attrprefix.sku ?? 'sku') || urlParams.get('sku');
            if (skuFromUrl) $form.find('[name="sku"]').val(skuFromUrl);
            const discountFromUrl = urlParams.get(attrprefix.discount ?? 'discount') || urlParams.get('discount');
            if (discountFromUrl) $form.find('[name="discount"]').val(discountFromUrl);
            const dateFromUrl = urlParams.get(attrprefix.date_filter ?? 'date') || urlParams.get('date_filter');
            if (dateFromUrl) $form.find('[name="date_filter"]').val(dateFromUrl);

            const filterValues = filtersString.split(',').map(value => value.trim());
            if (filterValues[0] !== '') filterValues.forEach(value => {
                if ($(`input[value="${value}"]`).length) {
                    $(`input[value="${value}"]`).prop('checked', true);
                } else if ($(`select option[value="${value}"]`).length) {
                    $(`select option[value="${value}"]`).prop('selected', true);
                }
            });
            return;
        }

        // New implementation for attribute type permalinks
        // Process each parameter in the URL
        // Reverse map the prefixes to attribute names for lookup
        const prefixToAttribute = {};
        // Handle category and tag directly
        prefixToAttribute[attrprefix["product-category"] ?? 'cata'] = "product-category[]";
        prefixToAttribute[attrprefix.tag ?? 'tags'] = 'tag';
        prefixToAttribute[attrprefix.price ?? 'price'] = 'price';
        prefixToAttribute[attrprefix.rating ?? 'rating'] = 'rating';
        prefixToAttribute[attrprefix.brand ?? 'brand'] = 'rplurand';
        prefixToAttribute[attrprefix.author ?? 'authors'] = 'rpluthor';
        prefixToAttribute[attrprefix.stock_status ?? 'stockStatus'] = 'rplutock_status';
        prefixToAttribute[attrprefix.sale_status ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.sale_status ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.min_length ?? 'min_length'] = 'min_length';
        prefixToAttribute[attrprefix.max_length ?? 'max_length'] = 'max_length';
        prefixToAttribute[attrprefix.length ?? 'length'] = 'length';
        prefixToAttribute[attrprefix.width ?? 'width'] = 'width';
        prefixToAttribute[attrprefix.height ?? 'height'] = 'height';
        prefixToAttribute[attrprefix.weight ?? 'weight'] = 'weight';
        prefixToAttribute[attrprefix.sku ?? 'sku'] = 'sku';
        prefixToAttribute[attrprefix.discount ?? 'discount'] = 'discount';
        prefixToAttribute[attrprefix.date_filter ?? 'date'] = 'date_filter';
        prefixToAttribute[searchPrefix] = 'plugincy_search';

        // Handle all product attributes
        if (attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }
        if (attrprefix.custom) {
            for (const [customName, prefix] of Object.entries(attrprefix.custom)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = customName;
                }
            }
        }

        for (const [key, value] of urlParams.entries()) {
            if (key === 'filters' || key === paginationPrefix || key === 'paged' || key === 'product-page' || key === 'page') continue; // Skip the format flag and pagination state

            const attributeName = prefixToAttribute[key] ?? key;
            if (attributeName === 'plugincy_search') {
                $("input#plugincy-search-field").val(value);
                continue;
            }

            // Split comma-separated values
            const values = value.split(',').map(v => v.trim());


            if (attributeName) {

                values.forEach(val => {
                    // Look for inputs that have name containing the attribute and value matching the value
                    const $inputs = $form.find(`input[name*="${attributeName}"][value="${val}"]`);
                    // Handle select elements
                    const $options = $form.find(`select[name*="${attributeName}"] option[value="${val}"]`);;
                    if ($options.length) {
                        $options.prop('selected', true);
                    }
                    // Handle price range specially if needed
                    if (!$inputs.length && !$options.length) {
                        if (attributeName === 'price' && val.includes('-')) {
                            const [min, max] = val.split('-');
                            const $minRange = $form.find('.range-min');
                            const $maxRange = $form.find('.range-max');

                            if ($minRange.length) {
                                $minRange.val(min);
                            }
                            if ($maxRange.length) {
                                $maxRange.val(max);
                            }
                            $form.find('input[name="mn_price"]').val(min);
                            $form.find('input[name="mx_price"]').val(max);

                            if ($minRange.length) updatePriceDisplay($minRange);
                            if ($maxRange.length) updatePriceDisplay($maxRange);
                        } else if (['length', 'width', 'height', 'weight'].includes(attributeName) && val.includes('-')) {
                            const [min, max] = val.split('-');
                            const $minField = $form.find(`input[name="min_${attributeName}"]`);
                            const $maxField = $form.find(`input[name="max_${attributeName}"]`);
                            if ($minField.length) $minField.val(min).trigger('change');
                            if ($maxField.length) $maxField.val(max).trigger('change');
                        } else if (attributeName === 'sku') {
                            $form.find('[name="sku"]').val(val).trigger('change');
                        } else if (attributeName === 'discount') {
                            $form.find('[name="discount"]').val(val).trigger('change');
                        } else if (attributeName === 'date_filter') {
                            $form.find('[name="date_filter"]').val(val).trigger('change');
                        }
                    }
                });
            }
        }
    }


    /**
     * Transform standard filter URL to SEO-friendly URL format
     * @param {string} url - The original URL with standard filter parameters
     * @param {object} seoOptions - The SEO permalink configuration options
     * @returns {string} - The transformed SEO-friendly URL
     */
    function transformToSeoUrl(url, seoOptions) {
        if (!url || !seoOptions) {
            return url; // Return the original URL if no SEO options are provided
        }
        // Parse the current URL
        const urlObj = new URL(url);
        const searchParams = urlObj.searchParams;

        // Create new URLSearchParams for our SEO-friendly URL
        const seoParams = new URLSearchParams();
        seoParams.append('filters', '1'); // Add the filters=1 parameter

        // Prefixes config from SEO options
        const prefixes = seoOptions.dapfforwc_permalinks_prefix_options;
        const lengthKey = (prefixes && prefixes.length) ?? "length";
        const widthKey = (prefixes && prefixes.width) ?? "width";
        const heightKey = (prefixes && prefixes.height) ?? "height";
        const weightKey = (prefixes && prefixes.weight) ?? "weight";
        const skuKey = (prefixes && prefixes.sku) ?? "sku";
        const discountKey = (prefixes && prefixes.discount) ?? "discount";
        const dateKey = (prefixes && prefixes.date_filter) ?? "date";
        const searchKey = (prefixes && prefixes.plugincy_search && prefixes.plugincy_search !== '') ? prefixes.plugincy_search : "title";
        const paginationKey = (prefixes && prefixes.pagination && prefixes.pagination !== '') ? prefixes.pagination : "paged";


        // Process category parameters
        if (searchParams.has("product-category")) {
            // Get all category values and remove duplicates
            const categories = Array.from(new Set(searchParams.getAll("product-category")));
            if (categories.length > 0) {
                let catakey = (prefixes && prefixes["product-category"]);
                if (!catakey || catakey === "") {
                    catakey = "cata";
                }
                seoParams.append(catakey, categories.join(','));
            }
        }

        // Process tag parameters
        if (searchParams.has('tags')) {
            // Get all tag values and remove duplicates
            const tags = Array.from(new Set(searchParams.getAll('tags')));
            if (tags.length > 0) {
                let tagskey = (prefixes && prefixes["tag"]) ?? "tags";
                if (!tagskey || tagskey === "") {
                    tagskey = "tags";
                }
                seoParams.append(tagskey, tags.join(','));
            }
        }

        // process brands

        if (searchParams.has('rplurand')) {
            // Get all brand values and remove duplicates
            const brands = Array.from(new Set(searchParams.getAll('rplurand')));
            if (brands.length > 0) {
                let brandskey = (prefixes && prefixes["brand"]) ?? "brand";
                if (!brandskey || brandskey === "") {
                    brandskey = "brand";
                }
                seoParams.append(brandskey, brands.join(','));
            }
        }

        // process authors
        if (searchParams.has('rpluthor')) {
            // Get all author values and remove duplicates
            const authors = Array.from(new Set(searchParams.getAll('rpluthor')));
            if (authors.length > 0) {
                let authorskey = (prefixes && prefixes["author"]) ?? "authors";
                if (!authorskey || authorskey === "") {
                    authorskey = "authors";
                }
                seoParams.append(authorskey, authors.join(','));
            }
        }

        // process stock status
        if (searchParams.has('rplutock_status')) {
            // Get all stock_status values and remove duplicates
            const stock_status = Array.from(new Set(searchParams.getAll('rplutock_status')));
            if (stock_status.length > 0) {
                let stock_statuskey = (prefixes && prefixes["stock_status"]) ?? "stockStatus";
                if (!stock_statuskey || stock_statuskey === "") {
                    stock_statuskey = "stockStatus";
                }
                seoParams.append(stock_statuskey, stock_status.join(','));
            }
        }

        // process sale status
        if (searchParams.has('rpn_sale')) {
            // Get all sale_status values and remove duplicates
            const sale_status = Array.from(new Set(searchParams.getAll('rpn_sale')));
            if (sale_status.length > 0) {
                let sale_statuskey = (prefixes && prefixes["sale_status"]) ?? "saleStatus";
                if (!sale_statuskey || sale_statuskey === "") {
                    sale_statuskey = "saleStatus";
                }
                seoParams.append(sale_statuskey, sale_status.join(','));
            }
        }

        // Process rating parameters
        if (searchParams.has('rating')) {
            const ratings = searchParams.getAll('rating');
            if (ratings.length > 0) {
                let ratingKey = (prefixes && prefixes["rating"]) ?? "rating";
                if (!ratingKey || ratingKey === "") {
                    ratingKey = "rating";
                }
                seoParams.append(ratingKey, ratings.join(','));
            }
        }

        // Process price parameters
        if (searchParams.has('mn_price') || searchParams.has('mx_price')) {
            const currentpageminPrice = $('.range-min').attr('min') || '';
            const currentpagemaxPrice = $('.range-max').attr('max') || '';
            const minPrice = searchParams.get('mn_price') || '';
            const maxPrice = searchParams.get('mx_price') || '';

            if (
                (minPrice || maxPrice) && // at least one is set
                (minPrice >= currentpageminPrice && maxPrice <= currentpagemaxPrice) && // within range
                (minPrice !== currentpageminPrice || maxPrice !== currentpagemaxPrice) // at least one changed
            ) {
                let priceKey = (prefixes && prefixes.price) ?? "price";
                if (!priceKey || priceKey === "") {
                    priceKey = "price";
                }
                seoParams.append(priceKey, `${minPrice}-${maxPrice}`);
            }
        }

        // Process dimensions length parameters
        if (searchParams.has((lengthKey && lengthKey !== "" ? lengthKey : "length"))) {
            const range = searchParams.get(lengthKey && lengthKey !== "" ? lengthKey : "length");
            if (range) {
                seoParams.append(lengthKey && lengthKey !== "" ? lengthKey : "length", range);
            }
        } else if (searchParams.has('min_length') || searchParams.has('max_length')) {
            const min_length = searchParams.get('min_length') || '';
            const max_length = searchParams.get('max_length') || '';
            if (min_length || max_length) {
                const normalizedKey = lengthKey && lengthKey !== "" ? lengthKey : "length";
                seoParams.append(normalizedKey, `${min_length}-${max_length}`);
            }
        }

        // Process dimensions width parameters
        if (searchParams.has((widthKey && widthKey !== "" ? widthKey : "width"))) {
            const range = searchParams.get(widthKey && widthKey !== "" ? widthKey : "width");
            if (range) {
                seoParams.append(widthKey && widthKey !== "" ? widthKey : "width", range);
            }
        } else if (searchParams.has('min_width') || searchParams.has('max_width')) {
            const min_width = searchParams.get('min_width') || '';
            const max_width = searchParams.get('max_width') || '';
            if (min_width || max_width) {
                const normalizedKey = widthKey && widthKey !== "" ? widthKey : "width";
                seoParams.append(normalizedKey, `${min_width}-${max_width}`);
            }
        }

        // Process dimensions height parameters
        if (searchParams.has((heightKey && heightKey !== "" ? heightKey : "height"))) {
            const range = searchParams.get(heightKey && heightKey !== "" ? heightKey : "height");
            if (range) {
                seoParams.append(heightKey && heightKey !== "" ? heightKey : "height", range);
            }
        } else if (searchParams.has('min_height') || searchParams.has('max_height')) {
            const min_height = searchParams.get('min_height') || '';
            const max_height = searchParams.get('max_height') || '';
            if (min_height || max_height) {
                const normalizedKey = heightKey && heightKey !== "" ? heightKey : "height";
                seoParams.append(normalizedKey, `${min_height}-${max_height}`);
            }
        }

        // Process dimensions weight parameters
        if (searchParams.has((weightKey && weightKey !== "" ? weightKey : "weight"))) {
            const range = searchParams.get(weightKey && weightKey !== "" ? weightKey : "weight");
            if (range) {
                seoParams.append(weightKey && weightKey !== "" ? weightKey : "weight", range);
            }
        } else if (searchParams.has('min_weight') || searchParams.has('max_weight')) {
            const min_weight = searchParams.get('min_weight') || '';
            const max_weight = searchParams.get('max_weight') || '';
            if (min_weight || max_weight) {
                const normalizedKey = weightKey && weightKey !== "" ? weightKey : "weight";
                seoParams.append(normalizedKey, `${min_weight}-${max_weight}`);
            }
        }

        // Process search parameter
        const searchVal = searchParams.get(searchKey) || searchParams.get('title') || searchParams.get('plugincy_search');
        if (searchVal) {
            const normalizedSearchKey = searchKey && searchKey !== "" ? searchKey : "title";
            seoParams.append(normalizedSearchKey, searchVal);
        }
        const skuVal = searchParams.get(skuKey && skuKey !== "" ? skuKey : 'sku') || searchParams.get('sku');
        if (skuVal) {
            seoParams.append(skuKey && skuKey !== "" ? skuKey : 'sku', skuVal);
        }
        const discountVal = searchParams.get(discountKey && discountKey !== "" ? discountKey : 'discount') || searchParams.get('discount');
        if (discountVal) {
            seoParams.append(discountKey && discountKey !== "" ? discountKey : 'discount', discountVal);
        }
        const dateVal = searchParams.get(dateKey && dateKey !== "" ? dateKey : 'date') || searchParams.get('date_filter');
        if (dateVal) {
            seoParams.append(dateKey && dateKey !== "" ? dateKey : 'date', dateVal);
        }
        const normalizedPaginationKey = paginationKey && paginationKey !== "" ? paginationKey : "paged";
        const paginationRaw = searchParams.get(normalizedPaginationKey) || searchParams.get('paged') || searchParams.get('product-page') || searchParams.get('page');
        const parsedPage = parsePageNumber(paginationRaw);
        if (parsedPage && parsedPage > 1) {
            seoParams.append(normalizedPaginationKey, String(parsedPage));
        }

        // Process attribute parameters
        const attributeParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an attribute parameter
            if (key.startsWith('rplugpa_') && value !== '') {
                // Extract attribute name, e.g., 'rplugpa_brand' -> 'brand'
                const attributeName = key.replace('rplugpa_', '');

                if (!attributeParams[attributeName]) {
                    attributeParams[attributeName] = [];
                }
                // Only add if not already present
                if (!attributeParams[attributeName].includes(value)) {
                    attributeParams[attributeName].push(value);
                }
            }
        }

        // Add attribute parameters with their SEO prefix
        for (const [attributeName, values] of Object.entries(attributeParams)) {
            // Use prefix from config if available, otherwise use attributeName as the key
            let prefix = (prefixes && prefixes.attribute && prefixes.attribute[attributeName])
                ? prefixes.attribute[attributeName]
                : attributeName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Process custom parameters
        const customParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an custom parameter
            if (key.startsWith('rplugcusf_') && value !== '') {
                // Extract custom name, e.g., 'rplugcusf__brand' -> 'brand'
                const customName = key.replace('rplugcusf_', '');

                if (!customParams[customName]) {
                    customParams[customName] = [];
                }
                // Only add if not already present
                if (!customParams[customName].includes(value)) {
                    customParams[customName].push(value);
                }
            }
        }

        // Add custom parameters with their SEO prefix
        for (const [customName, values] of Object.entries(customParams)) {
            // Use prefix from config if available, otherwise use customName as the key
            let prefix = (prefixes && prefixes.custom && prefixes.custom[customName])
                ? prefixes.custom[customName]
                : customName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Build the new URL
        const baseUrl = urlObj.origin + urlObj.pathname;
        const seoQueryString = (seoParams.toString() === "filters=1") ? '' : seoParams.toString();

        return baseUrl + (seoQueryString ? '?' + seoQueryString : '');
    }

    // Initialize on document ready
    $(document).ready(function () {
        initProductFilter();
        initPriceRangeInputs();

        // Global delegated listener: when the search field is cleared, auto-run the filter (even in apply-button mode)
        $(document).off('input.dapfforwcSearchClearGlobal change.dapfforwcSearchClearGlobal', dapfforwc_FILTER.searchField)
            .on('input.dapfforwcSearchClearGlobal change.dapfforwcSearchClearGlobal', dapfforwc_FILTER.searchField, function () {
                if (($(this).val() || '').trim() !== '') return;
                const $form = $(this).closest(dapfforwc_FILTER.formSelector).length
                    ? $(this).closest(dapfforwc_FILTER.formSelector)
                    : $(dapfforwc_FILTER.formSelector).first();
                if (!$form.length) return;
                filterState.pendingChanges = true;
                selectedValesbyuser = store_selected_values();
                selectedFilterShowProductTop();
                debounceRun(function () {
                    handleFilterChange($form);
                });
            });
    });

    // Expose public API
    window.dapfforwc_FILTER_API = {
        refresh: function () {
            handleFilterChange($(dapfforwc_FILTER.formSelector));
        },
        reset: function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select').prop('selectedIndex', 0);
            $form.find('input[type="text"], input[type="search"]').val('');

            // Reset price range sliders
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                $minRange.val($minRange.attr('min'));
                $maxRange.val($maxRange.attr('max'));
                updatePriceDisplay($minRange);
                updatePriceDisplay($maxRange);
            }

            handleFilterChange($form);
        }
    };

    function initializeSelect2() {
        if (!$.fn || typeof $.fn.select2 !== 'function') return false;

        $(".pluginy_select2.filter-select").each(function () {
            if ($(this).hasClass('select2-hidden-accessible')) return;
            $(this).select2({ placeholder: TEXTS.select2_placeholder, allowClear: true });
        });
        $("select.select2_classic").each(function () {
            if ($(this).hasClass('select2-hidden-accessible')) return;
            $(this).select2({ placeholder: TEXTS.select2_placeholder, allowClear: true });
        });
        return true;
    }

    let select2InitAttempts = 0;
    function initializeSelect2WithRetry() {
        if (initializeSelect2()) return;
        if (select2InitAttempts >= 5) return;
        select2InitAttempts++;
        setTimeout(initializeSelect2WithRetry, 300);
    }

    // Initial initialization
    initializeSelect2WithRetry();



    $(document).ajaxComplete(function () {
        // Check if new options are added before reinitializing
        if ($(".pluginy_select2.filter-select").find("option").length > 0) {
            initializeSelect2WithRetry();
        }
    });
    function initializeCollapsible() {
        const getCurrentForm = () => $(dapfforwc_FILTER.formSelector);
        const usesMobileStyle = () => {
            const $activeForm = getCurrentForm();
            return $activeForm.length && $activeForm.data("mobile-style") === "style_1" && $(window).width() <= COLLAPSE_MOBILE_BP;
        };

        $(COLLAPSE_SELECTORS.title).each(function () {
            const $title = $(this);
            if(!usesMobileStyle() && $title.hasClass("plugincy_collapsable_disabled")){
                return;
            }
            const $group = $title.closest(COLLAPSE_SELECTORS.group);
            const $items = $group.children().not(COLLAPSE_SELECTORS.title);
            const $clickTarget = $title.hasClass("plugincy_collapsable_arrow") ? $title.find(".collaps") : $title;
            const $activeForm = getCurrentForm();
            const layout = ($(window).width() > COLLAPSE_MOBILE_BP && $activeForm.length) ? ($activeForm.data("layout") || "sidebar") : "sidebar";
            const startCollapsed = usesMobileStyle() || $title.hasClass("plugincy_collapsable_minimize_initial") || layout === "top_view";

            if (startCollapsed) {
                collapseItems($items);
                if ($activeForm.length) $activeForm.removeClass("plugincy_layout_top_view");
            } else {
                expandItems($items);
            }

            $clickTarget.off("click.dapfforwcCollapse").on("click.dapfforwcCollapse", function (e) {
                e.stopPropagation();
                const wasCollapsed = $items.hasClass("dapfforwc-hidden-important");
                const mobileBehavior = usesMobileStyle();

                if (mobileBehavior) {
                    collapseAllSections(getCurrentForm());
                }

                if (wasCollapsed) {
                    expandItems($items);
                    $title.find("svg").addClass("rotated");
                } else {
                    collapseItems($items);
                    $title.find("svg").removeClass("rotated");
                }
            });
        });

        $(document).off("click.dapfforwcCollapseOutside").on("click.dapfforwcCollapseOutside", function (event) {
            const $target = $(event.target);
            if ($target.closest(dapfforwc_FILTER.formSelector).length) return;
            const $latestForm = getCurrentForm();
            const isMobile = $(window).width() <= COLLAPSE_MOBILE_BP;
            const layout = (!isMobile && $latestForm.length) ? ($latestForm.data("layout") || "sidebar") : "sidebar";
            const allowCollapse = (layout === "top_view" && !isMobile) || usesMobileStyle();
            if (!allowCollapse) return;
            collapseAllSections($latestForm.length ? $latestForm : document);
        });

        if (!collapseMediaQueryBound) {
            const mq = window.matchMedia(`(max-width: ${COLLAPSE_MOBILE_BP}px)`);
            const mqHandler = () => {
                const $latestForm = getCurrentForm();
                collapseAllSections($latestForm.length ? $latestForm : document);
                initializeCollapsible();
            };
            if (mq.addEventListener) {
                mq.addEventListener("change", mqHandler);
            } else if (mq.addListener) {
                mq.addListener(mqHandler);
            }
            collapseMediaQueryBound = true;
        }
    }

    // Initialize collapsible elements
    initializeCollapsible();

    // Reinitialize collapsibles after AJAX content is loaded
    $(document).ajaxComplete(function () {
        initializeCollapsible();
        restoreCollapseState();
    });

    // Ensure suggestions stay wired after dynamic DOM changes on keyup
    $(document).on('keyup', 'input#plugincy-search-field', function () {
        const $form = $(this).closest(dapfforwc_FILTER.formSelector).length
            ? $(this).closest(dapfforwc_FILTER.formSelector)
            : $(dapfforwc_FILTER.formSelector);
    });

    window.re_initSelect2_Collaps = function () {
        initializeSelect2();
        initializeCollapsible();
        restoreCollapseState();
    };


    $(document).on('click', '.show-sub-cata', function (event) {
        event.preventDefault();
        event.stopPropagation();
        const $btn = $(this);

        // Try multiple strategies to find the child categories container
        let $childCategories = $btn.closest('.dapfforwcpro-category-row').next('.child-categories');
        if (!$childCategories.length) $childCategories = $btn.closest('.dapfforwcpro-category-row').siblings('.child-categories').first();
        if (!$childCategories.length) $childCategories = $btn.closest('label').next('.child-categories');
        if (!$childCategories.length) $childCategories = $btn.closest('label').siblings('.child-categories').first();
        if (!$childCategories.length) $childCategories = $btn.closest('label').find('.child-categories').first();

        if (!$childCategories.length) return;

        // Use a duration and a normal function callback (or captured $btn) to update the button text reliably
        $childCategories.slideToggle(200, function () {
            $btn.text($childCategories.is(':visible') ? '-' : '+');
            $btn.attr('aria-expanded', $childCategories.is(':visible') ? 'true' : 'false');
        });
    });

    $(document).on('click', '.search_terms', function (event) {
        event.preventDefault();
        const $btn = $(this);

        // on click .search_terms get closest .plugincy-filter-group. in the plugincy-filter-group .items > .search-container toggle display: flex !Important
        const $filterGroup = $btn.closest('.plugincy-filter-group');
        const $title = $filterGroup.find(COLLAPSE_SELECTORS.title).first();
        const $items = $filterGroup.children().not(COLLAPSE_SELECTORS.title);
        if ($items.hasClass("dapfforwc-hidden-important")) {
            expandItems($items);
            $title.find("svg").addClass("rotated");
            $searchContainer.addClass('dapfforwc-search-inactive');
        }
        const $searchContainer = $filterGroup.find('.items > .search-container');
        $searchContainer.toggleClass('dapfforwc-search-inactive');
    });

    $(document)
        .off('click.dapfforwcTooltip touchend.dapfforwcTooltip', '.tooltip-icon')
        .on('click.dapfforwcTooltip touchend.dapfforwcTooltip', '.tooltip-icon', function (event) {
            event.preventDefault();
            event.stopPropagation();
            showTooltipBubble(this);
        });

    $(document).off('click.dapfforwcTooltipDismiss').on('click.dapfforwcTooltipDismiss', function (event) {
        if ($(event.target).closest('.tooltip-icon, .dapfforwc-tooltip-bubble').length) return;
        hideTooltipBubble();
    });

    $(window).off('scroll.dapfforwcTooltip resize.dapfforwcTooltip').on('scroll.dapfforwcTooltip resize.dapfforwcTooltip', hideTooltipBubble);

    $(document).on('keyup', '.search-container input.search-terms', function () {
        const searchValue = $(this).val().toLowerCase().trim();
        const $filterGroup = $(this).closest('.plugincy-filter-group');
        const $labels = $filterGroup.find('.items label');

        $labels.each(function () {
            const $label = $(this);
            const labelText = $label.find('.option_title').text().toLowerCase();

            if (searchValue === '') {
                // Show all labels if search is empty
                if ($label.hasClass("filterout-label")) {
                    $label.removeClass("filterout-label");
                }
            } else {
                // Show label only if it matches the search value
                if (labelText.indexOf(searchValue) !== -1) {
                    if ($label.hasClass("filterout-label")) {
                        $label.removeClass("filterout-label");
                    }
                } else {
                    if (!$label.hasClass("filterout-label")) {
                        $label.addClass("filterout-label");
                    }
                }
            }
        });
    });

    $(document).on('click', '.plugincy-term-search-submit', function (event) {
        event.preventDefault();
    });

})(jQuery);
