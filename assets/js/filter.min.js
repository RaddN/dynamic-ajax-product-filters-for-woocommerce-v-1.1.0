/**
 * Product Filter - Frontend JavaScript
 */
(function ($) {
    'use strict';

    // Configuration options
    const dapfforwc_FILTER = {
        formSelector: '#product-filter',
        productSelector: '.products',
        paginationSelector: 'nav.woocommerce-pagination',
        sortingSelector: 'form.woocommerce-ordering select',
        filterTriggers: 'input[type="checkbox"], input[type="radio"], select, input[type="range"]',
        searchField: '#plugincy-search-field',
        searchButton: '.plugincy-search-submit',
        spinnerClass: 'dapfforwc-spinner',
        loadingClass: 'dapfforwc-loading',
        debounceTime: 500, // ms to wait before processing input changes
        autoScrollOffset: 100
    };
    let count;
    let advancesettings, dapfforwc_options, dapfforwc_seo_permalinks_options, dapfforwc_styleoptions, shopPageUrl, isProductArchive, currencySymbol, isHomePage;
    let front_page_slug;
    let debounceTimer;

    // Extract data from configuration objects using destructuring when available
    if (typeof dapfforwc_data !== 'undefined') {
        ({
            dapfforwc_advance_settings: advancesettings,
            dapfforwc_front_page_slug: front_page_slug,
            dapfforwc_options,
            dapfforwc_seo_permalinks_options,
            dapfforwc_styleoptions
        } = dapfforwc_data);
    }

    if (typeof dapfforwc_ajax !== 'undefined') {
        ({
            shopPageUrl,
            isProductArchive,
            currencySymbol,
            isHomePage
        } = dapfforwc_ajax);
    }

    plugincydebugLog("Form Manage Settings : ", dapfforwc_options);
    plugincydebugLog("Form Style Settings : ", dapfforwc_styleoptions);
    plugincydebugLog("SEO setup Settings : ", dapfforwc_seo_permalinks_options);
    plugincydebugLog("Advanced Settings : ", advancesettings);

    var rfilterbuttonsId = $('.rfilterbuttons').attr('id');

    /**
     * Determines the appropriate product selector based on priority order:
     * 1. Shortcode-defined selector
     * 2. Global settings selector
     * 3. Custom class selectors (fallback options)
     * 
     * @returns {string} The product selector string
     */
    function getProductSelector() {
        const DEFAULT_SELECTOR = '.products';

        // Check if shortcode defines a custom selector
        const formElement = $(dapfforwc_FILTER.formSelector);
        const shortcodeSelector = formElement.data('product_selector');

        const validPatterns = [
            /^[a-zA-Z][a-zA-Z0-9\-_]*$/,                    // Element
            /^\.[a-zA-Z][a-zA-Z0-9\-_]*$/,                  // Class
            /^#[a-zA-Z][a-zA-Z0-9\-_]*$/,                   // ID
            /^\[[a-zA-Z][a-zA-Z0-9\-_]*(\=[^\]]+)?\]$/,     // Attribute
            /^[a-zA-Z0-9\s\.\#\[\]\=\:\-\_\,\>\+\~\*\(\)]+$/ // Complex
        ];

        let isValidSelector = shortcodeSelector ? validPatterns.some(pattern => pattern.test(shortcodeSelector)) : false;
        if (!isValidSelector && shortcodeSelector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        if (isValidSelector && $(shortcodeSelector).length > 0) {
            return shortcodeSelector;
        }


        isValidSelector = advancesettings &&
            advancesettings.product_selector ? validPatterns.some(pattern => pattern.test(advancesettings.product_selector)) : false;
        if (!isValidSelector && advancesettings &&
            advancesettings.product_selector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        // Check global settings for custom selector
        if (isValidSelector &&
            $(advancesettings.product_selector).length > 0) {
            return advancesettings.product_selector;
        }

        // Fallback to custom class selectors in priority order
        const fallbackSelectors = [
            '.plugincy-filter-products',
            '.plugincy-filter-products-wrapper > ul',
            '.plugincy-filter-products-wrapper > div'
        ];

        for (let i = 0; i < fallbackSelectors.length; i++) {
            const selector = fallbackSelectors[i];
            if ($(selector).length > 0) {
                return selector;
            }
        }

        // Final fallback: find parent of plugincy-filter-product-item
        const productItemElement = $('.plugincy-filter-product-item');
        if (productItemElement.length > 0) {
            const parentElement = productItemElement.parent();
            if (parentElement.length > 0) {
                const parentTag = parentElement.get(0).tagName.toLowerCase();
                const parentClass = parentElement.attr('class');
                const parentId = parentElement.attr('id');

                let parentSelector = parentTag;
                if (parentId) {
                    parentSelector = `#${parentId}`;
                } else if (parentClass) {
                    parentSelector = `${parentTag}.${parentClass.split(' ').join('.')}`;
                }
                return parentSelector;
            }
        }
        return DEFAULT_SELECTOR;
    }

    window.getProductSelector = $(getProductSelector()).length > 0;
    window.getProductSelectorString = getProductSelector();

    const product_selector = getProductSelector();

    let pagination_selector = ".plugincy-filter-pagination";
    let paginationSelector_shortcode = $('#product-filter').data('pagination_selector');

    if (paginationSelector_shortcode && $(paginationSelector_shortcode).length) {

        pagination_selector = paginationSelector_shortcode;

    } else if (advancesettings && advancesettings["pagination_selector"] && $(advancesettings["pagination_selector"]).length) {

        pagination_selector = advancesettings["pagination_selector"];

    } else if ($('ul.page-numbers').length) {

        pagination_selector = 'ul.page-numbers';

    } else if ($('.pagination').length) {

        pagination_selector = '.pagination';

    }


    function attachPaginationEvents() {
        const $form = $(dapfforwc_FILTER.formSelector);
        $(document).on('click', `${pagination_selector} a`, function (e) {
            e.preventDefault(); // Prevent the default anchor click behavior

            const url = $(this).attr('href'); // Get the URL from the link
            const fullUrl = new URL(url, window.location.origin); // Ensure a valid URL
            const urlParams = fullUrl.searchParams;
            // Try to extract the page number from query params or from the URL path (pretty permalinks)
            let page = urlParams.get('paged') || urlParams.get('product-page');
            if (!page) {
                // Try to match /page/2/ or /product-page/2/ in the URL path
                const match = fullUrl.pathname.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
                if (match && match[1]) {
                    page = match[1];
                }
            }
            $('#roverlay').show();
            $('#loader').show();
            handleFilterChange($form, page); // Fetch products for the selected page
        });
    }

    // Call this function after updating the product listings
    if ($('#product-filter').length) {
        attachPaginationEvents();
    }

    // Store the current filter state
    let filterState = {
        currentRequest: null,
        isLoading: false,
        pendingChanges: false
    };

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('filters')) {
        count = 1;
        applyFiltersFromUrl(urlParams.get('filters'));
        count = 0;

    }
    /**
     * Initialize the filter functionality
     */
    function initProductFilter() {
        const $form = $(dapfforwc_FILTER.formSelector);

        if ($form.length === 0) {
            return;
        }

        // Bind events to filter elements
        bindFilterEvents($form);

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function (event) {
            // Only handle our own state changes
            if (event.state && event.state.dapfforwcFilter) {
                window.location.reload();
            }
        });

        initSorting();
    }
    // single filter handle
    syncCheckboxSelections();
    function syncCheckboxSelections() {
        const $list = $('.rfilterbuttons ul').empty();
        $('#product-filter #' + rfilterbuttonsId + ' input').each(function () {
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;
            $list.append(createCheckboxListItem(value, checked, type));
        });
        $('#product-filter #' + rfilterbuttonsId + ' option').each(function (index) {
            // Skip the first option (index 0)
            if (index === 0) {
                return; // Skip this iteration
            }
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;

            $list.append(createCheckboxListItem(value, checked, type));
        });
        attachCheckboxClickEvents();
        attachMainFilterChangeEvents();
    }
    function createCheckboxListItem(value, checked, type) {
        const formattedLabel = value.split('-').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        return $('<li></li>').addClass(checked ? 'checked' : '').append(
            $('<input>', {
                name: 'attribute[' + rfilterbuttonsId + '][]',
                id: 'text_' + value,
                type: 'checkbox',
                value: value,
                checked: checked
            }).on('change', syncToMainFilter),
            $('<label></label>', {
                for: 'text_' + value,
                text: formattedLabel
            })
        );
    }

    function syncToMainFilter() {
        $(`#product-filter #${rfilterbuttonsId} input[value="${$(this).val()}"]`).prop('checked', $(this).is(':checked'));
        $(`#product-filter #${rfilterbuttonsId} select option[value="${$(this).val()}"]`).prop('selected', $(this).is(':checked'));
    }

    function attachCheckboxClickEvents() {
        $('.rfilterbuttons ul').off('click', 'li').on('click', 'li', function () {
            const checkbox = $(this).find('input');
            checkbox.prop('checked', !checkbox.is(':checked')).trigger('change');
            $(this).toggleClass('checked', checkbox.is(':checked'));
        });
    }

    function attachMainFilterChangeEvents() {
        $('#' + rfilterbuttonsId + ' input').on('change', function () {
            const relatedCheckbox = $(`.rfilterbuttons ul li input[value="${$(this).val()}"]`);
            relatedCheckbox.prop('checked', $(this).is(':checked')).closest('li').toggleClass('checked', $(this).is(':checked'));
        });
    }

    function store_selected_values() {
        const filtersByType = {};
        const options_selector = "#product-filter input:checked:not('.default_values input')";
        // Handle checked checkboxes and radios
        $(options_selector).each(function () {
            const value = $(this).val();
            const name = $(this).attr('name');
            if (!filtersByType[name]) {
                filtersByType[name] = [];
            }
            if (!filtersByType[name].includes(value)) {
                filtersByType[name].push(value);
            }
        });
        // Handle selected options in select elements (excluding default/empty)
        $('#product-filter select').each(function () {
            const name = $(this).attr('name');
            const selectedValues = $(this).val();
            if (selectedValues && selectedValues.length > 0) {
                if (!filtersByType[name]) {
                    filtersByType[name] = [];
                }
                if (Array.isArray(selectedValues)) {
                    selectedValues.forEach(v => {
                        if (v !== "" && v !== "Any" && !filtersByType[name].includes(v)) {
                            filtersByType[name].push(v);
                        }
                    });
                } else if (selectedValues !== "" && selectedValues !== "Any" && !filtersByType[name].includes(selectedValues)) {
                    filtersByType[name].push(selectedValues);
                }
            }
        });
        return filtersByType;
    }

    // create list of current selected filter
    function selectedFilterShowProductTop() {
        let selectedValesbyuser = store_selected_values();
        // Clear existing content
        $('.rfilterselected ul').empty();
        if (Array.isArray(selectedValesbyuser)) {
            for (let value of selectedValesbyuser) {
                $('.rfilterselected ul').append(`
            <li class="checked">
                <input id="selected_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
            </li>`);
            }
        } else if (typeof selectedValesbyuser === 'object' && selectedValesbyuser !== null) {
            for (let key in selectedValesbyuser) {
                for (let value of selectedValesbyuser[key]) {
                    $('.rfilterselected ul').append(`
                <li class="checked">
                <input id="selected_${key}_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${key}_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
                </li>`);
                }
            }
        }

        let search_value = $('input#plugincy-search-field').val();

        if (search_value) {
            $('.rfilterselected ul').append(`
                <li class="checked checked-plugincy-search-field">
                <input id="selected_search" type="checkbox" value="${search_value}" checked>
                <label for="selected_search">Searched: ${search_value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
                </li>`);
        }
    }

    // pagination handle

    let selectedValesbyuser = store_selected_values();

    selectedFilterShowProductTop();

    /**
     * Bind events to filter form elements
     */
    function bindFilterEvents($form) {
        // Handle filter changes with debounce
        let debounceTimer;

        // Track checkbox and radio changes
        $form.on('change', dapfforwc_FILTER.filterTriggers, function () {
            clearTimeout(debounceTimer);
            filterState.pendingChanges = true;

            selectedValesbyuser = store_selected_values();

            selectedFilterShowProductTop();

            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, dapfforwc_FILTER.debounceTime);
        });

        $('.rfilterbuttons').on('change', function () {
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });

        // Handle price range inputs
        $form.on('input', 'input[type="range"]', function () {
            updatePriceDisplay($(this));
        });

        // Handle search button click
        $form.on('click', dapfforwc_FILTER.searchButton, function (e) {
            e.preventDefault();
            handleFilterChange($form);
        });

        // Handle search on enter key
        $(dapfforwc_FILTER.searchField).on('keypress', function (e) {
            if (e.which === 13) {
                e.preventDefault();
                handleFilterChange($form);
            }
        });

        // // Reset rating filter
        // // Reset rating filter
        // $form.on('click', '.reset-value', function () {
        //     const $ratingInputs = $form.find('input[name="rating[]"]');
        //     $ratingInputs.prop('checked', false);
        //     handleFilterChange($form);
        // });

        // Reset all filters in the same .filter-group as the clicked .close button
        $(document).on('click', '.reset-value', function () {
            const $filterGroup = $(this).closest('.filter-group');
            $filterGroup.find('.items input').each(function () {
                if (this.type === 'checkbox' || this.type === 'radio') {
                    $(this).prop('checked', false);
                }
            });
            $filterGroup.find('select.items').each(function () {
                $(this).prop('selectedIndex', 0);
            });
            $filterGroup.find('.items input[type="text"], .items input[type="search"]').each(function () {
                $(this).val('');
            });
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });
    }

    $('.rfilterselected').on('change', 'li', function (e) {
        const $form = $(dapfforwc_FILTER.formSelector);
        const value = $(this).find('input').val();
        if ($(this).hasClass('checked-plugincy-search-field')) {
            $('input#plugincy-search-field').val('');
        } else {
            $(`#product-filter input[value="${value}"]`).prop('checked', false);
        }
        selectedValesbyuser = store_selected_values();
        selectedFilterShowProductTop();
        handleFilterChange($form);
    });

    $('#product-filter').on('change', 'input', function () {
        const name = $(this).attr('name');
        const value = $(this).val();
        const checked = $(this).is(':checked');
        // Find all inputs with same name and value, except the one just changed
        $(`#product-filter input[name="${name}"][value="${value}"]`).not(this).prop('checked', checked);
    });

    /**
     * Handle changes to filter form elements
     */
    function handleFilterChange($form, $page = 1) {
        filterState.pendingChanges = false;

        // Check if we're already processing a request
        if (filterState.isLoading) {
            return;
        }

        // Get the serialized form data
        // Serialize form data, but remove fields where value is "any"
        let formArray = $form.serializeArray().filter(function (item) {
            return item.value !== "Any";
        });
        // Merge duplicate fields (e.g., product-category[]) into comma-separated values
        const merged = {};
        formArray.forEach(function (item) {
            if (merged[item.name]) {
                merged[item.name].push(item.value);
            } else {
                merged[item.name] = [item.value];
            }
        });

        // Build param string with comma-separated values for arrays
        const mergedArray = [];
        for (const key in merged) {
            // Remove duplicate values for each key
            const uniqueValues = Array.from(new Set(merged[key]));
            if (uniqueValues.length > 1) {
                mergedArray.push({
                    name: key,
                    value: uniqueValues.join(',')
                });
            } else {
                mergedArray.push({
                    name: key,
                    value: uniqueValues[0]
                });
            }
        }
        const formData = $.param(mergedArray);

        let product_show_settings = $form.data("product_show_settings");
        if (typeof product_show_settings === "string") {
            try {
                product_show_settings = JSON.parse(product_show_settings);
            } catch (e) {
                product_show_settings = {};
            }
        } else if (typeof product_show_settings !== "object" || product_show_settings === null) {
            product_show_settings = {};
        }

        // Access each value
        let perPage = product_show_settings.per_page;          // "5"
        let orderBy = $(dapfforwc_FILTER.sortingSelector).val() === "menu_order" ? product_show_settings.orderby : $(dapfforwc_FILTER.sortingSelector).val();          // "date"
        let order = product_show_settings.order;               // "DESC"
        let operatorSecond = product_show_settings.operator_second; // "in"

        // Build the query URL
        let currentUrl = window.location.href.split('?')[0];
        currentUrl = currentUrl.replace(/\/filters\/[^?]*/, '/?');
        // Remove any trailing "?" if no query follows
        if (currentUrl.endsWith('?')) {
            currentUrl = currentUrl.slice(0, -1);
        }
        const queryString = formData
            .replace(/\+/g, '%20')
            .replace(/%5B/g, '')
            .replace(/%5D/g, '')
            .replace(/attribute/g, 'rplugpa_')
            .replace(/custom_meta/g, 'rplugcusf_')
            ;
        let fullUrl;
        fullUrl = currentUrl + (queryString ? '?' + queryString : '');
        if ($page != null) {
            const pageParam = `paged=${$page}`;
            fullUrl += (queryString ? '&' : '?') + pageParam;
        }
        if (!isProductArchive) {
            if (perPage) {
                fullUrl += `&per_page=${perPage}`;
            }
            if (operatorSecond) {
                fullUrl += `&operator_second=${operatorSecond}`;
            }
            if (orderBy) {
                fullUrl += `&orderby=${orderBy}`;
            }
            if (order) {
                fullUrl += `&order=${order}`;
            }
        }
        loadFilteredContentAjax(fullUrl, formData, currentUrl);
    }

    /**
     * Load filtered content via AJAX
     */
    function loadFilteredContentAjax(url, formData, currentUrl) {
        plugincydebugLog("Data Fatching From", url);
        const $form = $(dapfforwc_FILTER.formSelector);
        // Abort any pending request
        if (filterState.currentRequest) {
            filterState.currentRequest.abort();
        }

        // Set loading state
        setLoadingState(true);


        // Add X-Requested-With header for WordPress to detect AJAX
        filterState.currentRequest = $.ajax({
            url: url,
            method: 'GET',
            success: function (response) {
                // Create a temporary DOM element to parse the fetched HTML
                const tempDiv = $('<div>').html(response);
                if (dapfforwc_options.use_url_filter !== "ajax") {
                    // Update browser history / url with transformed URL if necessary
                    if (dapfforwc_seo_permalinks_options &&
                        dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks !== "on") {
                        let selectedValuesByUser = store_selected_values(); // Assuming this returns an object

                        // Extract values from the object
                        let filtersArray = [];

                        // Loop through the object and collect values
                        for (let key in selectedValuesByUser) {
                            if (Array.isArray(selectedValuesByUser[key])) {
                                filtersArray.push(...selectedValuesByUser[key]); // Spread values into the filters array
                            }
                        }

                        // Convert to a comma-separated string
                        let filters = filtersArray.join(',');
                        let searchval = $("input#plugincy-search-field").val();

                        // Construct the new URL
                        let url = currentUrl;
                        url += filters && filters !== '' ? `?filters=${filters}` : (searchval && searchval !== '' ? "?filters" : "");
                        url += searchval && searchval !== '' ? '&title=' + searchval : '';

                        // Update the browser history
                        window.history.pushState({ dapfforwcFilter: true }, '', url);
                    }
                    if (dapfforwc_seo_permalinks_options &&
                        dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks === "on") {
                        url = currentUrl + url.substring(url.indexOf('?'));
                        // Transform the URL to SEO format
                        let seoUrl = transformToSeoUrl(url, dapfforwc_seo_permalinks_options).replace(/%2C/g, ',');

                        // Update the browser history
                        window.history.pushState({ dapfforwcFilter: true }, '', seoUrl);
                    }
                }

                // Sources from the fetched tempDiv
                const $srcProducts = tempDiv.find(product_selector);
                const $srcPaginations = tempDiv.find(pagination_selector);
                const updatedform = tempDiv.find(dapfforwc_FILTER.formSelector);
                const $srcResultCount = tempDiv.find('.woocommerce-result-count');

                // Update each .products by index
                $(product_selector).each(function (i) {
                    let $src;

                    // If we have multiple sources, use index mapping
                    // If we have only one source, use it for all targets
                    if ($srcProducts.length > 1) {
                        $src = $srcProducts.eq(i);
                    } else {
                        $src = $srcProducts.eq(0); // Use the first (and likely only) source
                    }

                    if ($src.length && $src.children().length) {
                        $(this).html($src.html());
                    } else {
                        // No corresponding source: show empty state for THIS container only
                        $(this).html('<p class="woocommerce-info">No products were found matching your selection.</p>');
                        // If you want to remove ordering next to THIS products block only:
                        $(this).closest('.woocommerce').find('.woocommerce-ordering').remove();
                    }
                });

                // Update each .paginations by index
                $(pagination_selector).each(function (i) {

                    let $src;

                    // If we have multiple sources, use index mapping
                    // If we have only one source, use it for all targets
                    if ($srcPaginations.length > 1) {
                        $src = $srcPaginations.eq(i);
                    } else {
                        $src = $srcPaginations.eq(0); // Use the first (and likely only) source
                    }



                    if ($src.length) {
                        $(this).html($src.html());
                    } else {
                        $(this).empty();
                    }
                });

                // Update result counts by index (if there are multiple)
                const $targetsResultCount = $('.woocommerce-result-count');
                const $productCountSm = $('#rcountproduct');

                $targetsResultCount.each(function (i) {
                    let $src;

                    // If we have multiple sources, use index mapping
                    // If we have only one source, use it for all targets
                    if ($srcResultCount.length > 1) {
                        $src = $srcResultCount.eq(i);
                    } else {
                        $src = $srcResultCount.eq(0); // Use the first (and likely only) source
                    }

                    if ($src.length) {
                        $(this).html($src.html());
                        $productCountSm.html($src.html());
                    } else {
                        $(this).empty();
                        $productCountSm.empty();
                    }
                });


                if (dapfforwc_options["update_filter_options"] === "on") {
                    // Keep the first 3 children, remove the rest
                    $form.children().slice(3).remove();
                    // Insert updated form children after the third child, skipping the first 3 children of updatedform
                    $form.children().eq(2).after(updatedform.children().slice(3));
                }

                selectedFilterShowProductTop();
                syncCheckboxSelections();
                initPriceRangeInputs();

                // Auto-scroll to products container                
                scrollToProducts();

                // Trigger events for other scripts
                $(document).trigger('dapfforwc_filters_updated');
                $(window).trigger('scroll');
                $(window).trigger('resize');
            },
            error: function (xhr, status, error) {
                if (status !== 'abort') {
                    console.error('Filter request failed:', error);
                }
            },
            complete: function () {
                setLoadingState(false);
                filterState.currentRequest = null;
            }
        });
    }

    /**
     * Initialize sorting functionality
     */
    function initSorting() {
        // Prevent form submission on pressing Enter
        $('.woocommerce-ordering').on('submit', function (event) {
            event.preventDefault();
        });
        $('.ast-woocommerce-shop-page-modern-style .woocommerce-ordering').on('change', function (e) {
            if ($(e.target).hasClass('orderby')) {
                e.preventDefault(); // Prevent the form submission
                e.stopImmediatePropagation(); // Stop other listeners from being called
                const sortValue = $(this).find('select.orderby').val();
                onsortchange(sortValue);
            }
        });
        $(document).on('change', dapfforwc_FILTER.sortingSelector, function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            const sortValue = $(this).val();
            onsortchange(sortValue);
        });
    }

    function onsortchange(sortValue) {
        // Create or update the orderby hidden input in the filter form
        let $orderbyInput = $('#filter-orderby');
        if ($orderbyInput.length === 0) {
            $orderbyInput = $('<input>').attr({
                type: 'hidden',
                id: 'filter-orderby',
                name: 'orderby',
                value: sortValue
            });
            $(dapfforwc_FILTER.formSelector).append($orderbyInput);
        } else {
            $orderbyInput.val(sortValue);
        }

        // Reset to page 1 when sorting changes
        let $pageInput = $('#filter-page-num');
        if ($pageInput.length) {
            $pageInput.val(1);
        }

        // Trigger filter change with the new sort order
        handleFilterChange($(dapfforwc_FILTER.formSelector));
    }

    /**
     * Set loading state
     */
    function setLoadingState(isLoading) {
        filterState.isLoading = isLoading;
        let isloadingenablebyadmin = dapfforwc_options.show_loader === "on";

        if (isLoading && isloadingenablebyadmin) {
            $('html, body').css('cursor', 'wait');
            showSpinner();
            $(dapfforwc_FILTER.formSelector).addClass(dapfforwc_FILTER.loadingClass);
        } else {
            $('html, body').css('cursor', 'auto');
            hideSpinner();
            $(dapfforwc_FILTER.formSelector).removeClass(dapfforwc_FILTER.loadingClass);
        }
    }

    /**
     * Show loading spinner
     */
    function showSpinner() {
        if (count !== 1) {
            $('#roverlay').show();
            $('#loader').show();
        }
    }

    /**
     * Hide loading spinner
     */
    function hideSpinner() {
        $('#roverlay').hide();
        $('#loader').hide();
    }

    /**
     * Update price range display
     */
    function updatePriceDisplay($rangeInput) {
        const isMin = $rangeInput.hasClass('range-min');
        const value = Math.ceil(parseFloat($rangeInput.val()));
        const $minInput = $('.range-min');
        const $maxInput = $('.range-max');

        const minValue = Math.floor(parseFloat($minInput.val()) || 0);
        const maxValue = Math.ceil(parseFloat($maxInput.val()) || 0);
        const minPriceDefault = Math.floor(parseFloat($minInput.attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($maxInput.attr('max')) || 100);

        if (isMin) {
            $('#min-price').val(value);
            $('.plugrogress').css('left', ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100) + '%');
        } else {
            $('#max-price').val(value);
            $('.plugrogress').css('right', (100 - (value / maxPriceDefault * 100)) + '%');
        }

        // Update price display using custom pseudo-element content
        changePseudoElementContent(`${minValue}`, `${maxValue}`, isMin ? 'min' : 'max');

        // Also update the aria-valuetext for accessibility
        if (isMin) {
            $rangeInput.attr('aria-valuetext', `${value}`);
        } else {
            $rangeInput.attr('aria-valuetext', `${value}`);
        }
    }

    function changePseudoElementContent(minValue, maxValue, activeHandle = null) {
        // Create a style element if it doesn't exist
        let styleEl = document.getElementById('price-range-display-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'price-range-display-style';
            document.head.appendChild(styleEl);
        }

        // Set z-index based on which handle is active
        const minZIndex = activeHandle === 'min' ? 10 : 5;
        const maxZIndex = activeHandle === 'max' ? 10 : 5;

        // Calculate percentage positions for min and max handles
        const minPriceDefault = Math.floor(parseFloat($('.range-min').attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($('.range-max').attr('max')) || 100);

        const minPercent = ((minValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;
        const maxPercent = ((maxValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;

        // Check if handles are close to each other (less than 20% apart)
        const areHandlesClose = (maxPercent - minPercent) < 60;


        if (areHandlesClose) {
            let centerPosition;
            // Calculate center position only when handles first get close
            centerPosition = (minPercent + maxPercent) / 2;
            let transform = centerPosition;
            // Prevent the label from going outside the slider bounds
            if (centerPosition < 39) centerPosition = 39;
            if (centerPosition > 70) centerPosition = 0;

            // If handles are close, show combined format in the middle
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue} - ${currencySymbol} ${maxValue}" !important;
                left: ${centerPosition}%;
                transform: translateX(${centerPosition === 0 ? '-' + transform + '%' : '0%'});
                z-index: 10;
            }
            #product-filter .plugrogress-percentage:after {
                content: "" !important;
                display: none;
            }
        `;

        } else {
            // Normal display when handles are far apart
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue}" !important;
                z-index: ${minZIndex};
            }
            #product-filter .plugrogress-percentage:after {
                content: "${currencySymbol} ${maxValue}" !important;
                z-index: ${maxZIndex};
            }
        `;
        }
    }


    function initPriceRangeInputs() {
        const $rangeInputs = $(".range-input input");
        const $priceInputs = $(".price-input input");
        const $range = $(".plugincy_slider .plugrogress");

        if ($rangeInputs.length < 2 || $priceInputs.length < 2) return;

        let minPrice = Math.floor(parseFloat($rangeInputs[0].value) || 0);
        let maxPrice = Math.ceil(parseFloat($rangeInputs[1].value) || 0);
        const minPriceDefault = Math.floor(parseFloat($rangeInputs[0].getAttribute('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($rangeInputs[0].getAttribute('max')) || 100);

        $range.css({
            'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
            'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
        });

        // Initialize price display
        changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

        // Handle range input changes
        $rangeInputs.on("input", function () {
            const isMin = $(this).hasClass('range-min');
            minPrice = Math.floor(parseFloat($rangeInputs.eq(0).val()) || 0);
            maxPrice = Math.ceil(parseFloat($rangeInputs.eq(1).val()) || 0);

            changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

            $priceInputs.eq(0).val(minPrice);
            $priceInputs.eq(1).val(maxPrice);

            $range.css({
                'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
                'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
            });

            // Trigger debounced filter update
            const $form = $(dapfforwc_FILTER.formSelector);
            filterState.pendingChanges = true;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, dapfforwc_FILTER.debounceTime);
        });

        // Handle direct price input changes
        $priceInputs.on("input", function () {
            const isMin = $(this).hasClass('input-min');
            let minVal = Math.floor(parseFloat($priceInputs.eq(0).val()) || minPriceDefault);
            let maxVal = Math.ceil(parseFloat($priceInputs.eq(1).val()) || maxPriceDefault);

            // If max is greater than allowed max, set to default max
            if (maxVal > maxPriceDefault) {
                maxVal = maxPriceDefault;
                $priceInputs.eq(1).val(maxVal);
                $rangeInputs.eq(1).val(maxVal);
            }
            // If max is less than min, set to min
            if (maxVal < minVal) {
                maxVal = minVal;
                $priceInputs.eq(1).val(maxVal);
                $rangeInputs.eq(1).val(maxVal);
            }
            // If min is less than allowed min, set to default min
            if (minVal < minPriceDefault) {
                minVal = minPriceDefault;
                $priceInputs.eq(0).val(minVal);
                $rangeInputs.eq(0).val(minVal);
            }
            // If min is greater than max, set to max
            if (minVal > maxVal) {
                minVal = maxVal;
                $priceInputs.eq(0).val(minVal);
                $rangeInputs.eq(0).val(minVal);
            }

            $range.css('left', ((minVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%");
            $range.css('right', 100 - (maxVal / maxPriceDefault) * 100 + "%");

            changePseudoElementContent(`${minVal}`, `${maxVal}`);
        });

        // Update filter on price input blur
        $priceInputs.on("blur", function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            handleFilterChange($form);
        });
    }


    /**
     * Scroll to products container
     */
    function scrollToProducts() {
        const $target = $(product_selector);

        if ($target.length > 0) {
            $('html, body').animate({
                scrollTop: $target.offset().top - dapfforwc_FILTER.autoScrollOffset
            }, 500);
        }
    }


    function applyFiltersFromUrl(filtersString) {
        // Check if we're using the new format with attribute types in permalinks
        const urlParams = new URLSearchParams(window.location.search);
        const useNewFormat = urlParams.get('filters') === '1';
        const $form = $(dapfforwc_FILTER.formSelector);

        const attrprefix = dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options;

        if (!useNewFormat) {
            for (const [key, value] of urlParams.entries()) {
                if (key === 'title') {
                    $("input#plugincy-search-field").val(value);
                    break;
                }
            }

            const filterValues = filtersString.split(',').map(value => value.trim());
            if (filterValues[0] !== '') filterValues.forEach(value => {
                if ($(`input[value="${value}"]`).length) {
                    $(`input[value="${value}"]`).prop('checked', true);
                } else if ($(`select option[value="${value}"]`).length) {
                    $(`select option[value="${value}"]`).prop('selected', true);
                }
            });

            handleFilterChange($form);
            return;
        }

        // New implementation for attribute type permalinks
        // Process each parameter in the URL
        // Reverse map the prefixes to attribute names for lookup
        const prefixToAttribute = {};
        // Handle category and tag directly
        prefixToAttribute[attrprefix["product-category"] ?? 'cata'] = "product-category[]";
        prefixToAttribute[attrprefix.tag ?? 'tags'] = 'tag';
        prefixToAttribute[attrprefix.price ?? 'price'] = 'price';
        prefixToAttribute[attrprefix.rating ?? 'rating'] = 'rating';
        prefixToAttribute[attrprefix.brand ?? 'brand'] = 'rplurand';
        prefixToAttribute[attrprefix.author ?? 'authors'] = 'rpluthor';
        prefixToAttribute[attrprefix.stockStatus ?? 'stockStatus'] = 'rplutock_status';
        prefixToAttribute[attrprefix.saleStatus ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.saleStatus ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.min_length ?? 'min_length'] = 'min_length';
        prefixToAttribute[attrprefix.max_length ?? 'max_length'] = 'max_length';
        prefixToAttribute[attrprefix.sku ?? 'sku'] = 'sku';
        prefixToAttribute[attrprefix.discount ?? 'discount'] = 'discount';
        prefixToAttribute[attrprefix.date_filter ?? 'date'] = 'date_filter';

        // Handle all product attributes
        if (attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }
        if (attrprefix.custom) {
            for (const [customName, prefix] of Object.entries(attrprefix.custom)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = customName;
                }
            }
        }

        for (const [key, value] of urlParams.entries()) {
            if (key === 'title') {
                $("input#plugincy-search-field").val(value);
            }

            if (key === 'filters' || key === 'title') continue; // Skip the format flag and search parameter

            // Split comma-separated values
            const values = value.split(',').map(v => v.trim());

            // Find the attribute name this prefix corresponds to
            const attributeName = prefixToAttribute[key] ?? key;


            if (attributeName) {

                values.forEach(val => {
                    // Look for inputs that have name containing the attribute and value matching the value
                    const $inputs = $form.find(`input[name*="${attributeName}"][value="${val}"]`);
                    // Handle select elements
                    const $options = $form.find(`select[name*="${attributeName}"] option[value="${val}"]`);
                    const $inputtext = $form.find(`input[name*="${attributeName}"]`);
                    if ($inputs.length) {
                        $inputs.prop('checked', true);
                    }
                    else if ($options.length) {
                        $options.prop('selected', true);
                    }
                    // Handle price range specially if needed
                    else if (attributeName === 'price' && val.includes('-')) {
                        const [min, max] = val.split('-');
                        const $minInput = $form.find('input.dapfforwc-filters-range-min');
                        const $maxInput = $form.find('input.dapfforwc-filters-range-max');

                        if ($minInput.length && $maxInput.length) {
                            $minInput.val(min);
                            $maxInput.val(max);
                        }
                    } else if ($inputtext.length) {
                        $inputtext.val(value);
                    }
                });
            }
        }

        // Trigger filter change event to update the UI
        handleFilterChange($form);
    }


    /**
     * Transform standard filter URL to SEO-friendly URL format
     * @param {string} url - The original URL with standard filter parameters
     * @param {object} seoOptions - The SEO permalink configuration options
     * @returns {string} - The transformed SEO-friendly URL
     */
    function transformToSeoUrl(url, seoOptions) {
        if (!url || !seoOptions) {
            return url; // Return the original URL if no SEO options are provided
        }
        // Parse the current URL
        const urlObj = new URL(url);
        const searchParams = urlObj.searchParams;

        // Create new URLSearchParams for our SEO-friendly URL
        const seoParams = new URLSearchParams();
        seoParams.append('filters', '1'); // Add the filters=1 parameter

        // Prefixes config from SEO options
        const prefixes = seoOptions.dapfforwc_permalinks_prefix_options;

        // Process category parameters
        if (searchParams.has("product-category")) {
            // Get all category values and remove duplicates
            const categories = Array.from(new Set(searchParams.getAll("product-category")));
            if (categories.length > 0) {
                let catakey = (prefixes && prefixes["product-category"]);
                if (!catakey || catakey === "") {
                    catakey = "cata";
                }
                seoParams.append(catakey, categories.join(','));
            }
        }

        // Process tag parameters
        if (searchParams.has('tags')) {
            // Get all tag values and remove duplicates
            const tags = Array.from(new Set(searchParams.getAll('tags')));
            if (tags.length > 0) {
                let tagskey = (prefixes && prefixes["tag"]) ?? "tags";
                if (!tagskey || tagskey === "") {
                    tagskey = "tags";
                }
                seoParams.append(tagskey, tags.join(','));
            }
        }

        // process brands

        if (searchParams.has('rplurand')) {
            // Get all brand values and remove duplicates
            const brands = Array.from(new Set(searchParams.getAll('rplurand')));
            if (brands.length > 0) {
                let brandskey = (prefixes && prefixes["brand"]) ?? "brand";
                if (!brandskey || brandskey === "") {
                    brandskey = "brand";
                }
                seoParams.append(brandskey, brands.join(','));
            }
        }

        // process authors
        if (searchParams.has('rpluthor')) {
            // Get all author values and remove duplicates
            const authors = Array.from(new Set(searchParams.getAll('rpluthor')));
            if (authors.length > 0) {
                let authorskey = (prefixes && prefixes["author"]) ?? "authors";
                if (!authorskey || authorskey === "") {
                    authorskey = "authors";
                }
                seoParams.append(authorskey, authors.join(','));
            }
        }

        // process stock status
        if (searchParams.has('rplutock_status')) {
            // Get all stock_status values and remove duplicates
            const stock_status = Array.from(new Set(searchParams.getAll('rplutock_status')));
            if (stock_status.length > 0) {
                let stock_statuskey = (prefixes && prefixes["stock_status"]) ?? "stockStatus";
                if (!stock_statuskey || stock_statuskey === "") {
                    stock_statuskey = "stockStatus";
                }
                seoParams.append(stock_statuskey, stock_status.join(','));
            }
        }

        // process sale status
        if (searchParams.has('rpn_sale')) {
            // Get all sale_status values and remove duplicates
            const sale_status = Array.from(new Set(searchParams.getAll('rpn_sale')));
            if (sale_status.length > 0) {
                let sale_statuskey = (prefixes && prefixes["sale_status"]) ?? "saleStatus";
                if (!sale_statuskey || sale_statuskey === "") {
                    sale_statuskey = "saleStatus";
                }
                seoParams.append(sale_statuskey, sale_status.join(','));
            }
        }

        // Process rating parameters
        if (searchParams.has('rating')) {
            const ratings = searchParams.getAll('rating');
            if (ratings.length > 0) {
                let ratingKey = (prefixes && prefixes["rating"]) ?? "rating";
                if (!ratingKey || ratingKey === "") {
                    ratingKey = "rating";
                }
                seoParams.append(ratingKey, ratings.join(','));
            }
        }

        // Process price parameters
        if (searchParams.has('mn_price') || searchParams.has('mx_price')) {
            const currentpageminPrice = $("input#min-price").attr('min') || '';
            const currentpagemaxPrice = $("input#max-price").attr('max') || '';
            const minPrice = searchParams.get('mn_price') || '';
            const maxPrice = searchParams.get('mx_price') || '';

            if (
                (minPrice || maxPrice) && // at least one is set
                (minPrice >= currentpageminPrice && maxPrice <= currentpagemaxPrice) && // within range
                (minPrice !== currentpageminPrice || maxPrice !== currentpagemaxPrice) // at least one changed
            ) {
                let priceKey = (prefixes && prefixes.price) ?? "price";
                if (!priceKey || priceKey === "") {
                    priceKey = "price";
                }
                seoParams.append(priceKey, `${minPrice}-${maxPrice}`);
            }
        }

        // Process dimensions length parameters
        if (searchParams.has('min_length') || searchParams.has('max_length')) {
            const min_length = searchParams.get('min_length') || '';
            const max_length = searchParams.get('max_length') || '';
            if (min_length || max_length) {
                let lengthKey = (prefixes && prefixes.length) ?? "length";
                if (!lengthKey || lengthKey === "") {
                    lengthKey = "length";
                }
                seoParams.append(lengthKey, `${min_length}-${max_length}`);
            }
        }

        // Process dimensions width parameters
        if (searchParams.has('min_width') || searchParams.has('max_width')) {
            const min_width = searchParams.get('min_width') || '';
            const max_width = searchParams.get('max_width') || '';
            if (min_width || max_width) {
                let widthKey = (prefixes && prefixes.width) ?? "width";
                if (!widthKey || widthKey === "") {
                    widthKey = "width";
                }
                seoParams.append(widthKey, `${min_width}-${max_width}`);
            }
        }

        // Process dimensions height parameters
        if (searchParams.has('min_height') || searchParams.has('max_height')) {
            const min_height = searchParams.get('min_height') || '';
            const max_height = searchParams.get('max_height') || '';
            if (min_height || max_height) {
                let heightKey = (prefixes && prefixes.height) ?? "height";
                if (!heightKey || heightKey === "") {
                    heightKey = "height";
                }
                seoParams.append(heightKey, `${min_height}-${max_height}`);
            }
        }

        // Process dimensions weight parameters
        if (searchParams.has('min_weight') || searchParams.has('max_weight')) {
            const min_weight = searchParams.get('min_weight') || '';
            const max_weight = searchParams.get('max_weight') || '';
            if (min_weight || max_weight) {
                let weightKey = (prefixes && prefixes.weight) ?? "weight";
                if (!weightKey || weightKey === "") {
                    weightKey = "weight";
                }
                seoParams.append(weightKey, `${min_weight}-${max_weight}`);
            }
        }

        // Process search parameter
        if (searchParams.has('plugincy_search') && searchParams.get('plugincy_search') !== '') {
            seoParams.append('title', searchParams.get('plugincy_search'));
        }
        if (searchParams.has('sku') && searchParams.get('sku') !== '') {
            seoParams.append('sku', searchParams.get('sku'));
        }
        if (searchParams.has('discount') && searchParams.get('discount') !== '') {
            seoParams.append('discount', searchParams.get('discount'));
        }
        if (searchParams.has('date_filter') && searchParams.get('date_filter') !== '') {
            seoParams.append('date', searchParams.get('date_filter'));
        }

        // Process attribute parameters
        const attributeParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an attribute parameter
            if (key.startsWith('rplugpa_') && value !== '') {
                // Extract attribute name, e.g., 'rplugpa_brand' -> 'brand'
                const attributeName = key.replace('rplugpa_', '');

                if (!attributeParams[attributeName]) {
                    attributeParams[attributeName] = [];
                }
                // Only add if not already present
                if (!attributeParams[attributeName].includes(value)) {
                    attributeParams[attributeName].push(value);
                }
            }
        }

        // Add attribute parameters with their SEO prefix
        for (const [attributeName, values] of Object.entries(attributeParams)) {
            // Use prefix from config if available, otherwise use attributeName as the key
            let prefix = (prefixes && prefixes.attribute && prefixes.attribute[attributeName])
                ? prefixes.attribute[attributeName]
                : attributeName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Process custom parameters
        const customParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an custom parameter
            if (key.startsWith('rplugcusf_') && value !== '') {
                // Extract custom name, e.g., 'rplugcusf__brand' -> 'brand'
                const customName = key.replace('rplugcusf_', '');

                if (!customParams[customName]) {
                    customParams[customName] = [];
                }
                // Only add if not already present
                if (!customParams[customName].includes(value)) {
                    customParams[customName].push(value);
                }
            }
        }

        // Add custom parameters with their SEO prefix
        for (const [customName, values] of Object.entries(customParams)) {
            // Use prefix from config if available, otherwise use customName as the key
            let prefix = (prefixes && prefixes.custom && prefixes.custom[customName])
                ? prefixes.custom[customName]
                : customName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Build the new URL
        const baseUrl = urlObj.origin + urlObj.pathname;
        const seoQueryString = (seoParams.toString() === "filters=1") ? '' : seoParams.toString();

        return baseUrl + (seoQueryString ? '?' + seoQueryString : '');
    }

    // Initialize on document ready
    $(document).ready(function () {
        initProductFilter();
        initPriceRangeInputs();
    });

    // Expose public API
    window.dapfforwc_FILTER_API = {
        refresh: function () {
            handleFilterChange($(dapfforwc_FILTER.formSelector));
        },
        reset: function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select').prop('selectedIndex', 0);
            $form.find('input[type="text"], input[type="search"]').val('');

            // Reset price range sliders
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                $minRange.val($minRange.attr('min'));
                $maxRange.val($maxRange.attr('max'));
                updatePriceDisplay($minRange);
                updatePriceDisplay($maxRange);
            }

            handleFilterChange($form);
        }
    };

})(jQuery);

// cateogry hide & show manage for herichical
jQuery(document).ready(function ($) {
    $(document).on('click', '.show-sub-cata', function (event) {
        event.preventDefault();
        const $childCategories = $(this).closest('div').next('.child-categories');
        $childCategories.slideToggle(() => {
            $(this).text($childCategories.is(':visible') ? '-' : '+');
        });
    });
});










jQuery(document).ready(function ($) {

    function initializeSelect2() {
        $(".select2.filter-select").select2({
            placeholder: "Select Options",
            allowClear: true
        });
        $("select.select2_classic").select2({
            placeholder: "Select Options",
            allowClear: true
        });
    }

    // Initial initialization
    initializeSelect2();

    $(document).ajaxComplete(function () {
        // Check if new options are added before reinitializing
        if ($(".select2.filter-select").find("option").length > 0) {
            initializeSelect2();
        }
    });
    function initializeCollapsible() {
        $(".title").each(function () {
            const $this = $(this);
            const $form = $("form#product-filter");
            let $form_layout = "sidebar";
            if ($(window).width() > 768) {
                if ($form) {
                    $form_layout = $form.data("layout") || "sidebar";
                }
            }
            const $items = $this.parent().children().not(".title");

            if ($form.length && $form.data("mobile-style") === "style_1" && $(window).width() <= 768) {
                $items.addClass("dapfforwc-hidden-important");
                $form.removeClass("plugincy_layout_top_view");
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }
            // Hide items initially if the title has a specific class
            else if ($this.hasClass("plugincy_collapsable_minimize_initial") || $form_layout === "top_view") {
                $items.addClass("dapfforwc-hidden-important");
                $form.removeClass("plugincy_layout_top_view");
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });

            }

            else if ($this.hasClass("plugincy_collapsable_no_arrow")) {
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }

            else if ($this.hasClass("plugincy_collapsable_arrow")) {
                $this.find(".collaps").off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }

        });
    }

    // Initialize collapsible elements
    initializeCollapsible();

    // Reinitialize collapsibles after AJAX content is loaded
    $(document).ajaxComplete(function () {
        initializeCollapsible();
    });
});