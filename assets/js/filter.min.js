/**
 * Product Filter - Frontend JavaScript
 */
(function ($) {
    'use strict';

    // Configuration options
    const dapfforwc_FILTER = {
        formSelector: '#product-filter',
        productSelector: '.products',
        paginationSelector: 'nav.woocommerce-pagination',
        sortingSelector: 'form.woocommerce-ordering select',
        filterTriggers: 'input[type="checkbox"], input[type="radio"], select, input[type="range"]',
        searchField: '#plugincy-search-field',
        searchButton: '.plugincy-search-submit',
        spinnerClass: 'dapfforwc-spinner',
        loadingClass: 'dapfforwc-loading',
        debounceTime: 500, // ms to wait before processing input changes
        autoScrollOffset: 100
    };
    let count;
    let advancesettings, dapfforwc_options, dapfforwc_seo_permalinks_options, shopPageUrl, isProductArchive, currencySymbol, isHomePage;
    let front_page_slug;
    let debounceTimer;

    // Extract data from configuration objects using destructuring when available
    if (typeof dapfforwc_data !== 'undefined') {
        ({
            dapfforwc_advance_settings: advancesettings,
            dapfforwc_front_page_slug: front_page_slug,
            dapfforwc_options,
            dapfforwc_seo_permalinks_options
        } = dapfforwc_data);
    }

    if (typeof dapfforwc_ajax !== 'undefined') {
        ({
            shopPageUrl,
            isProductArchive,
            currencySymbol,
            isHomePage
        } = dapfforwc_ajax);
    }

    var rfilterbuttonsId = $('.rfilterbuttons').attr('id');

    /**
     * Determines the appropriate product selector based on priority order:
     * 1. Shortcode-defined selector
     * 2. Global settings selector
     * 3. Custom class selectors (fallback options)
     * 
     * @returns {string} The product selector string
     */
    function getProductSelector() {
        const DEFAULT_SELECTOR = '.products';

        // Check if shortcode defines a custom selector
        const formElement = $(dapfforwc_FILTER.formSelector);
        const shortcodeSelector = formElement.data('product_selector');

        const validPatterns = [
            /^[a-zA-Z][a-zA-Z0-9\-_]*$/,                    // Element
            /^\.[a-zA-Z][a-zA-Z0-9\-_]*$/,                  // Class
            /^#[a-zA-Z][a-zA-Z0-9\-_]*$/,                   // ID
            /^\[[a-zA-Z][a-zA-Z0-9\-_]*(\=[^\]]+)?\]$/,     // Attribute
            /^[a-zA-Z0-9\s\.\#\[\]\=\:\-\_\,\>\+\~\*\(\)]+$/ // Complex
        ];

        let isValidSelector = shortcodeSelector ? validPatterns.some(pattern => pattern.test(shortcodeSelector)) : false;
        if (!isValidSelector && shortcodeSelector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        if (isValidSelector && $(shortcodeSelector).length > 0) {
            return shortcodeSelector;
        }


        isValidSelector = advancesettings &&
            advancesettings.product_selector ? validPatterns.some(pattern => pattern.test(advancesettings.product_selector)) : false;
        if (!isValidSelector && advancesettings &&
            advancesettings.product_selector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        // Check global settings for custom selector
        if (isValidSelector &&
            $(advancesettings.product_selector).length > 0) {
            return advancesettings.product_selector;
        }

        // Fallback to custom class selectors in priority order
        const fallbackSelectors = [
            '.plugincy-filter-products',
            '.plugincy-filter-products-wrapper > ul',
            '.plugincy-filter-products-wrapper > div'
        ];

        for (let i = 0; i < fallbackSelectors.length; i++) {
            const selector = fallbackSelectors[i];
            if ($(selector).length > 0) {
                return selector;
            }
        }

        // Final fallback: find parent of plugincy-filter-product-item
        const productItemElement = $('.plugincy-filter-product-item');
        if (productItemElement.length > 0) {
            const parentElement = productItemElement.parent();
            if (parentElement.length > 0) {
                const parentTag = parentElement.get(0).tagName.toLowerCase();
                const parentClass = parentElement.attr('class');
                const parentId = parentElement.attr('id');

                let parentSelector = parentTag;
                if (parentId) {
                    parentSelector = `#${parentId}`;
                } else if (parentClass) {
                    parentSelector = `${parentTag}.${parentClass.split(' ').join('.')}`;
                }
                return parentSelector;
            }
        }
        return DEFAULT_SELECTOR;
    }

    window.getProductSelector = $(getProductSelector()).length > 0;

    const product_selector = getProductSelector();

    let pagination_selector = advancesettings ? advancesettings["pagination_selector"] ?? 'ul.page-numbers' : 'ul.page-numbers';
    let paginationSelector_shortcode = $('#product-filter').data('pagination_selector');

    function attachPaginationEvents() {
        const $form = $(dapfforwc_FILTER.formSelector);
        $(document).on('click', `${paginationSelector_shortcode ?? pagination_selector} a.page-numbers`, function (e) {
            e.preventDefault(); // Prevent the default anchor click behavior

            const url = $(this).attr('href'); // Get the URL from the link
            const fullUrl = new URL(url, window.location.origin); // Ensure a valid URL
            const urlParams = fullUrl.searchParams;
            // Try to extract the page number from query params or from the URL path (pretty permalinks)
            let page = urlParams.get('paged') || urlParams.get('product-page');
            if (!page) {
                // Try to match /page/2/ or /product-page/2/ in the URL path
                const match = fullUrl.pathname.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
                if (match && match[1]) {
                    page = match[1];
                }
            }
            $('#roverlay').show();
            $('#loader').show();
            handleFilterChange($form, page); // Fetch products for the selected page
        });
    }

    // Call this function after updating the product listings
    if ($('#product-filter').length) {
        attachPaginationEvents();
    }

    // Store the current filter state
    let filterState = {
        currentRequest: null,
        isLoading: false,
        pendingChanges: false
    };

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('filters')) {
        count = 1;
        applyFiltersFromUrl(urlParams.get('filters'));
        count = 0;

    }
    /**
     * Initialize the filter functionality
     */
    function initProductFilter() {
        const $form = $(dapfforwc_FILTER.formSelector);

        if ($form.length === 0) {
            return;
        }

        // Bind events to filter elements
        bindFilterEvents($form);

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function (event) {
            // Only handle our own state changes
            if (event.state && event.state.dapfforwcFilter) {
                window.location.reload();
            }
        });

        initSorting();
    }
    // single filter handle
    syncCheckboxSelections();
    function syncCheckboxSelections() {
        const $list = $('.rfilterbuttons ul').empty();
        $('#product-filter #' + rfilterbuttonsId + ' input').each(function () {
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;
            $list.append(createCheckboxListItem(value, checked, type));
        });
        $('#product-filter #' + rfilterbuttonsId + ' option').each(function (index) {
            // Skip the first option (index 0)
            if (index === 0) {
                return; // Skip this iteration
            }
            const value = $(this).val();
            const checked = $(this).is(':checked');
            const type = this.type;

            $list.append(createCheckboxListItem(value, checked, type));
        });
        attachCheckboxClickEvents();
        attachMainFilterChangeEvents();
    }
    function createCheckboxListItem(value, checked, type) {
        const formattedLabel = value.split('-').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        return $('<li></li>').addClass(checked ? 'checked' : '').append(
            $('<input>', {
                name: 'attribute[' + rfilterbuttonsId + '][]',
                id: 'text_' + value,
                type: 'checkbox',
                value: value,
                checked: checked
            }).on('change', syncToMainFilter),
            $('<label></label>', {
                for: 'text_' + value,
                text: formattedLabel
            })
        );
    }

    function syncToMainFilter() {
        $(`#product-filter #${rfilterbuttonsId} input[value="${$(this).val()}"]`).prop('checked', $(this).is(':checked'));
        $(`#product-filter #${rfilterbuttonsId} select option[value="${$(this).val()}"]`).prop('selected', $(this).is(':checked'));
    }

    function attachCheckboxClickEvents() {
        $('.rfilterbuttons ul').off('click', 'li').on('click', 'li', function () {
            const checkbox = $(this).find('input');
            checkbox.prop('checked', !checkbox.is(':checked')).trigger('change');
            $(this).toggleClass('checked', checkbox.is(':checked'));
        });
    }

    function attachMainFilterChangeEvents() {
        $('#' + rfilterbuttonsId + ' input').on('change', function () {
            const relatedCheckbox = $(`.rfilterbuttons ul li input[value="${$(this).val()}"]`);
            relatedCheckbox.prop('checked', $(this).is(':checked')).closest('li').toggleClass('checked', $(this).is(':checked'));
        });
    }

    function store_selected_values() {
        const filtersByType = {};
        const options_selector = advancesettings && advancesettings.default_value_selected ? "#product-filter input:checked":"#product-filter input:checked:not('.default_values input')";
        // Handle checked checkboxes and radios
        $(options_selector).each(function () {
            const value = $(this).val();
            const name = $(this).attr('name');
            if (!filtersByType[name]) {
                filtersByType[name] = [];
            }
            if (!filtersByType[name].includes(value)) {
                filtersByType[name].push(value);
            }
        });
        // Handle selected options in select elements (excluding default/empty)
        $('#product-filter select').each(function () {
            const name = $(this).attr('name');
            const selectedValues = $(this).val();
            if (selectedValues && selectedValues.length > 0) {
                if (!filtersByType[name]) {
                    filtersByType[name] = [];
                }
                if (Array.isArray(selectedValues)) {
                    selectedValues.forEach(v => {
                        if (v !== "" && v !== "Any" && !filtersByType[name].includes(v)) {
                            filtersByType[name].push(v);
                        }
                    });
                } else if (selectedValues !== "" && selectedValues !== "Any" && !filtersByType[name].includes(selectedValues)) {
                    filtersByType[name].push(selectedValues);
                }
            }
        });
        return filtersByType;
    }

    // create list of current selected filter
    function selectedFilterShowProductTop() {
        let selectedValesbyuser = store_selected_values();
        // Clear existing content
        $('.rfilterselected ul').empty();
        if (Array.isArray(selectedValesbyuser)) {
            for (let value of selectedValesbyuser) {
                $('.rfilterselected ul').append(`
            <li class="checked">
                <input id="selected_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
            </li>`);
            }
        } else if (typeof selectedValesbyuser === 'object' && selectedValesbyuser !== null) {
            for (let key in selectedValesbyuser) {
                for (let value of selectedValesbyuser[key]) {
                    $('.rfilterselected ul').append(`
                <li class="checked">
                <input id="selected_${key}_${value}" type="checkbox" value="${value}" checked>
                <label for="selected_${key}_${value}">${value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
                </li>`);
                }
            }
        }

        let search_value = $('input#plugincy-search-field').val();

        if (search_value) {
            $('.rfilterselected ul').append(`
                <li class="checked checked-plugincy-search-field">
                <input id="selected_search" type="checkbox" value="${search_value}" checked>
                <label for="selected_search">Searched: ${search_value.replace(/-/g, ' ')}</label>
                <label style="font-size:12px;margin-left:5px;">x</label>
                </li>`);
        }
    }

    // pagination handle

    let selectedValesbyuser = store_selected_values();

    selectedFilterShowProductTop();

    /**
     * Bind events to filter form elements
     */
    function bindFilterEvents($form) {
        // Handle filter changes with debounce
        let debounceTimer;

        // Track checkbox and radio changes
        $form.on('change', dapfforwc_FILTER.filterTriggers, function () {
            clearTimeout(debounceTimer);
            filterState.pendingChanges = true;

            selectedValesbyuser = store_selected_values();

            selectedFilterShowProductTop();

            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, dapfforwc_FILTER.debounceTime);
        });

        $('.rfilterbuttons').on('change', function () {
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });

        // Handle price range inputs
        $form.on('input', 'input[type="range"]', function () {
            updatePriceDisplay($(this));
        });

        // Handle search button click
        $form.on('click', dapfforwc_FILTER.searchButton, function (e) {
            e.preventDefault();
            handleFilterChange($form);
        });

        // Handle search on enter key
        $(dapfforwc_FILTER.searchField).on('keypress', function (e) {
            if (e.which === 13) {
                e.preventDefault();
                handleFilterChange($form);
            }
        });

        // // Reset rating filter
        // // Reset rating filter
        // $form.on('click', '.reset-value', function () {
        //     const $ratingInputs = $form.find('input[name="rating[]"]');
        //     $ratingInputs.prop('checked', false);
        //     handleFilterChange($form);
        // });

        // Reset all filters in the same .filter-group as the clicked .close button
        $(document).on('click', '.reset-value', function () {
            const $filterGroup = $(this).closest('.filter-group');
            $filterGroup.find('.items input').each(function () {
                if (this.type === 'checkbox' || this.type === 'radio') {
                    $(this).prop('checked', false);
                }
            });
            $filterGroup.find('select.items').each(function () {
                $(this).prop('selectedIndex', 0);
            });
            $filterGroup.find('.items input[type="text"], .items input[type="search"]').each(function () {
                $(this).val('');
            });
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });
    }

    $('.rfilterselected').on('change', 'li', function (e) {
        const $form = $(dapfforwc_FILTER.formSelector);
        const value = $(this).find('input').val();
        if ($(this).hasClass('checked-plugincy-search-field')) {
            $('input#plugincy-search-field').val('');
        } else {
            $(`#product-filter input[value="${value}"]`).prop('checked', false);
        }
        selectedValesbyuser = store_selected_values();
        selectedFilterShowProductTop();
        handleFilterChange($form);
    });

    $('#product-filter').on('change', 'input', function () {
        const name = $(this).attr('name');
        const value = $(this).val();
        const checked = $(this).is(':checked');
        // Find all inputs with same name and value, except the one just changed
        $(`#product-filter input[name="${name}"][value="${value}"]`).not(this).prop('checked', checked);
    });

    /**
     * Handle changes to filter form elements
     */
    function handleFilterChange($form, $page = 1) {
        filterState.pendingChanges = false;

        // Check if we're already processing a request
        if (filterState.isLoading) {
            return;
        }

        // Get the serialized form data
        // Serialize form data, but remove fields where value is "any"
        let formArray = $form.serializeArray().filter(function (item) {
            return item.value !== "Any";
        });
        const formData = $.param(formArray);

        const product_show_settings = JSON.parse($form.data("product_show_settings"));

        // Access each value
        let perPage = product_show_settings.per_page;          // "5"
        let orderBy = $(dapfforwc_FILTER.sortingSelector).val() === "menu_order" ? product_show_settings.orderby : $(dapfforwc_FILTER.sortingSelector).val();          // "date"
        let order = product_show_settings.order;               // "DESC"
        let operatorSecond = product_show_settings.operator_second; // "in"

        // Build the query URL
        const currentUrl = window.location.href.split('?')[0];
        const queryString = formData.replace(/\+/g, '%20');
        let fullUrl;
        fullUrl = (shopPageUrl || window.location.origin) + (queryString ? '?' + queryString : '');
        if ($page != null) {
            const pageParam = `paged=${$page}`;
            fullUrl += (queryString ? '&' : '?') + pageParam;
        }
        if (!isProductArchive) {
            fullUrl += `&per_page=${perPage}&operator_second=${operatorSecond}&orderby=${orderBy}&order=${order}`;
        }
        fullUrl += `&post_type=product`;
        loadFilteredContentAjax(fullUrl, formData, currentUrl);
    }

    /**
     * Load filtered content via AJAX
     */
    function loadFilteredContentAjax(url, formData, currentUrl) {
        const $form = $(dapfforwc_FILTER.formSelector);
        // Abort any pending request
        if (filterState.currentRequest) {
            filterState.currentRequest.abort();
        }

        // Set loading state
        setLoadingState(true);

        // Add X-Requested-With header for WordPress to detect AJAX
        filterState.currentRequest = $.ajax({
            url: url,
            data: formData,
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            },
            success: function (response) {
                if (response.success) {
                    if (dapfforwc_options.use_url_filter !== "ajax") {
                        // Update browser history / url with transformed URL if necessary
                        if (dapfforwc_seo_permalinks_options &&
                            dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks !== "on") {
                            let selectedValuesByUser = store_selected_values(); // Assuming this returns an object

                            // Extract values from the object
                            let filtersArray = [];

                            // Loop through the object and collect values
                            for (let key in selectedValuesByUser) {
                                if (Array.isArray(selectedValuesByUser[key])) {
                                    filtersArray.push(...selectedValuesByUser[key]); // Spread values into the filters array
                                }
                            }

                            // Convert to a comma-separated string
                            let filters = filtersArray.join(',');
                            let searchval = $("input#plugincy-search-field").val();

                            // Construct the new URL
                            let url = currentUrl + `?filters=${filters}` + (searchval && searchval !== '' ? '&title=' + searchval : '');

                            // Update the browser history
                            window.history.pushState({ dapfforwcFilter: true }, '', url);
                        }
                        if (dapfforwc_seo_permalinks_options &&
                            dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks === "on") {
                            url = currentUrl + url.substring(url.indexOf('?'));
                            // Transform the URL to SEO format
                            let seoUrl = transformToSeoUrl(url, dapfforwc_seo_permalinks_options).replace(/%2C/g, ',');

                            // Update the browser history
                            window.history.pushState({ dapfforwcFilter: true }, '', seoUrl);
                        }
                    }

                    // Update the products container
                    $(product_selector).html(response.data.html);
                    $(paginationSelector_shortcode ?? pagination_selector).html(response.data.pagination);
                    if (dapfforwc_options["update_filter_options"] === "on") {
                        $form.children().not(':first').remove();
                        $form.children().first().after(response.data.updated_form);
                    }


                    // Update product count if element exists
                    if ($('.woocommerce-result-count').length) {
                        $('.woocommerce-result-count').text('Showing 1-' +
                            Math.min(response.data.found, 12) + ' of ' + response.data.found + ' results');
                    }

                    selectedFilterShowProductTop();
                    syncCheckboxSelections();
                    initPriceRangeInputs();

                    // Auto-scroll to products container                
                    scrollToProducts();

                    // Trigger events for other scripts
                    $(document).trigger('dapfforwc_filters_updated');
                    $(window).trigger('scroll');
                    $(window).trigger('resize');

                } else {
                    console.error('Filter request failed');
                }
            },
            error: function (xhr, status, error) {
                if (status !== 'abort') {
                    console.error('Filter request failed:', error);
                }
            },
            complete: function () {
                setLoadingState(false);
                filterState.currentRequest = null;
            }
        });
    }

    /**
     * Initialize sorting functionality
     */
    function initSorting() {
        // Prevent form submission on pressing Enter
        $('.woocommerce-ordering').on('submit', function (event) {
            event.preventDefault();
        });
        $('.ast-woocommerce-shop-page-modern-style .woocommerce-ordering').on('change', function (e) {
            if ($(e.target).hasClass('orderby')) {
                e.preventDefault(); // Prevent the form submission
                e.stopImmediatePropagation(); // Stop other listeners from being called
                const sortValue = $(this).find('select.orderby').val();
                onsortchange(sortValue);
            }
        });
        $(document).on('change', dapfforwc_FILTER.sortingSelector, function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            const sortValue = $(this).val();
            onsortchange(sortValue);
        });
    }

    function onsortchange(sortValue) {
        // Create or update the orderby hidden input in the filter form
        let $orderbyInput = $('#filter-orderby');
        if ($orderbyInput.length === 0) {
            $orderbyInput = $('<input>').attr({
                type: 'hidden',
                id: 'filter-orderby',
                name: 'orderby',
                value: sortValue
            });
            $(dapfforwc_FILTER.formSelector).append($orderbyInput);
        } else {
            $orderbyInput.val(sortValue);
        }

        // Reset to page 1 when sorting changes
        let $pageInput = $('#filter-page-num');
        if ($pageInput.length) {
            $pageInput.val(1);
        }

        // Trigger filter change with the new sort order
        handleFilterChange($(dapfforwc_FILTER.formSelector));
    }

    /**
     * Set loading state
     */
    function setLoadingState(isLoading) {
        filterState.isLoading = isLoading;
        let isloadingenablebyadmin = dapfforwc_options.show_loader === "on";

        if (isLoading && isloadingenablebyadmin) {
            $('html, body').css('cursor', 'wait');
            showSpinner();
            $(dapfforwc_FILTER.formSelector).addClass(dapfforwc_FILTER.loadingClass);
        } else {
            $('html, body').css('cursor', 'auto');
            hideSpinner();
            $(dapfforwc_FILTER.formSelector).removeClass(dapfforwc_FILTER.loadingClass);
        }
    }

    /**
     * Show loading spinner
     */
    function showSpinner() {
        if (count !== 1) {
            $('#roverlay').show();
            $('#loader').show();
        }
    }

    /**
     * Hide loading spinner
     */
    function hideSpinner() {
        $('#roverlay').hide();
        $('#loader').hide();
    }

    /**
     * Update price range display
     */
    function updatePriceDisplay($rangeInput) {
        const isMin = $rangeInput.hasClass('range-min');
        const value = Math.ceil(parseFloat($rangeInput.val()));
        const $minInput = $('.range-min');
        const $maxInput = $('.range-max');

        const minValue = Math.floor(parseFloat($minInput.val()) || 0);
        const maxValue = Math.ceil(parseFloat($maxInput.val()) || 0);
        const minPriceDefault = Math.floor(parseFloat($minInput.attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($maxInput.attr('max')) || 100);

        if (isMin) {
            $('#min-price').val(value);
            $('.progress').css('left', ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100) + '%');
        } else {
            $('#max-price').val(value);
            $('.progress').css('right', (100 - (value / maxPriceDefault * 100)) + '%');
        }

        // Update price display using custom pseudo-element content
        changePseudoElementContent(`${minValue}`, `${maxValue}`, isMin ? 'min' : 'max');

        // Also update the aria-valuetext for accessibility
        if (isMin) {
            $rangeInput.attr('aria-valuetext', `${value}`);
        } else {
            $rangeInput.attr('aria-valuetext', `${value}`);
        }
    }

    function changePseudoElementContent(minValue, maxValue, activeHandle = null) {
        // Create a style element if it doesn't exist
        let styleEl = document.getElementById('price-range-display-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'price-range-display-style';
            document.head.appendChild(styleEl);
        }

        // Set z-index based on which handle is active
        const minZIndex = activeHandle === 'min' ? 10 : 5;
        const maxZIndex = activeHandle === 'max' ? 10 : 5;

        // Calculate percentage positions for min and max handles
        const minPriceDefault = Math.floor(parseFloat($('.range-min').attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($('.range-max').attr('max')) || 100);

        const minPercent = ((minValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;
        const maxPercent = ((maxValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;

        // Check if handles are close to each other (less than 20% apart)
        const areHandlesClose = (maxPercent - minPercent) < 60;


        if (areHandlesClose) {
            let centerPosition;
            // Calculate center position only when handles first get close
            centerPosition = (minPercent + maxPercent) / 2;
            let transform = centerPosition;
            // Prevent the label from going outside the slider bounds
            if (centerPosition < 39) centerPosition = 39;
            if (centerPosition > 70) centerPosition = 0;

            // If handles are close, show combined format in the middle
            styleEl.textContent = `
            #product-filter .progress-percentage:before {
                content: "${currencySymbol} ${minValue} - ${currencySymbol} ${maxValue}" !important;
                left: ${centerPosition}%;
                transform: translateX(${centerPosition === 0 ? '-' + transform + '%' : '0%'});
                z-index: 10;
            }
            #product-filter .progress-percentage:after {
                content: "" !important;
                display: none;
            }
        `;

        } else {
            // Normal display when handles are far apart
            styleEl.textContent = `
            #product-filter .progress-percentage:before {
                content: "${currencySymbol} ${minValue}" !important;
                z-index: ${minZIndex};
            }
            #product-filter .progress-percentage:after {
                content: "${currencySymbol} ${maxValue}" !important;
                z-index: ${maxZIndex};
            }
        `;
        }
    }


    function initPriceRangeInputs() {
        const $rangeInputs = $(".range-input input");
        const $priceInputs = $(".price-input input");
        const $range = $(".slider .progress");

        if ($rangeInputs.length < 2 || $priceInputs.length < 2) return;

        let minPrice = Math.floor(parseFloat($rangeInputs[0].value) || 0);
        let maxPrice = Math.ceil(parseFloat($rangeInputs[1].value) || 0);
        const minPriceDefault = Math.floor(parseFloat($rangeInputs[0].getAttribute('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($rangeInputs[0].getAttribute('max')) || 100);

        $range.css({
            'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
            'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
        });

        // Initialize price display
        changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

        // Handle range input changes
        $rangeInputs.on("input", function () {
            const isMin = $(this).hasClass('range-min');
            minPrice = Math.floor(parseFloat($rangeInputs.eq(0).val()) || 0);
            maxPrice = Math.ceil(parseFloat($rangeInputs.eq(1).val()) || 0);

            changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

            $priceInputs.eq(0).val(minPrice);
            $priceInputs.eq(1).val(maxPrice);

            $range.css({
                'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
                'right': 100 - (maxPrice / maxPriceDefault) * 100 + "%"
            });

            // Trigger debounced filter update
            const $form = $(dapfforwc_FILTER.formSelector);
            filterState.pendingChanges = true;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(function () {
                if (filterState.pendingChanges) {
                    handleFilterChange($form);
                }
            }, dapfforwc_FILTER.debounceTime);
        });

        // Handle direct price input changes
        $priceInputs.on("input", function () {
            const isMin = $(this).hasClass('input-min');
            let minVal = Math.floor(parseFloat($priceInputs.eq(0).val()) || 0);
            let maxVal = Math.ceil(parseFloat($priceInputs.eq(1).val()) || 0);

            // Ensure min <= max
            if (isMin) {
                minVal = Math.min(minVal, maxVal);
                $priceInputs.eq(0).val(minVal);
                $rangeInputs.eq(0).val(minVal);
                $range.css('left', ((minVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%");
            } else {
                maxVal = Math.max(minVal, maxVal);
                $priceInputs.eq(1).val(maxVal);
                $rangeInputs.eq(1).val(maxVal);
                $range.css('right', 100 - (maxVal / maxPriceDefault) * 100 + "%");
            }

            changePseudoElementContent(`${minVal}`, `${maxVal}`);
        });

        // Update filter on price input blur
        $priceInputs.on("blur", function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            handleFilterChange($form);
        });
    }


    /**
     * Scroll to products container
     */
    function scrollToProducts() {
        const $target = $(product_selector);

        if ($target.length > 0) {
            $('html, body').animate({
                scrollTop: $target.offset().top - dapfforwc_FILTER.autoScrollOffset
            }, 500);
        }
    }


    function applyFiltersFromUrl(filtersString) {
        // Check if we're using the new format with attribute types in permalinks
        const urlParams = new URLSearchParams(window.location.search);
        const useNewFormat = urlParams.get('filters') === '1';
        const $form = $(dapfforwc_FILTER.formSelector);

        const attrprefix = dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options;

        if (!useNewFormat) {
            for (const [key, value] of urlParams.entries()) {
                if (key === 'title') {
                    $("input#plugincy-search-field").val(value);
                    break;
                }
            }
            // Original implementation for simple filter string
            if (!filtersString) {
                const newUrl = `/${currentPage}/`;
                history.replaceState(null, '', newUrl);
                handleFilterChange($form);
                return;
            }

            const filterValues = filtersString.split(',').map(value => value.trim());
            filterValues.forEach(value => {
                if ($(`input[value="${value}"]`).length) {
                    $(`input[value="${value}"]`).prop('checked', true);
                } else if ($(`select option[value="${value}"]`).length) {
                    $(`select option[value="${value}"]`).prop('selected', true);
                }
            });

            handleFilterChange($form);
            return;
        }

        // New implementation for attribute type permalinks
        // Process each parameter in the URL
        // Reverse map the prefixes to attribute names for lookup
        const prefixToAttribute = {};
        // Handle category and tag directly
        prefixToAttribute[attrprefix["product-category"]] = "cata";
        prefixToAttribute[attrprefix.tag] = 'tag';
        prefixToAttribute[attrprefix.price] = 'price';
        prefixToAttribute[attrprefix.rating] = 'rating';

        // Handle all product attributes
        if (attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }

        for (const [key, value] of urlParams.entries()) {
            if (key === 'title') {
                $("input#plugincy-search-field").val(value);
            }
            if (key === 'filters' || key === 'title') continue; // Skip the format flag and search parameter

            // Split comma-separated values
            const values = value.split(',').map(v => v.trim());

            // Find the attribute name this prefix corresponds to
            const attributeName = prefixToAttribute[key];

            if (attributeName) {

                values.forEach(val => {
                    // Look for inputs that have name containing the attribute and value matching the value
                    const $inputs = $form.find(`input[name*="${attributeName}"][value="${val}"]`);
                    if ($inputs.length) {
                        $inputs.prop('checked', true);
                    }

                    // Handle select elements
                    const $options = $form.find(`select[name*="${attributeName}"] option[value="${val}"]`);
                    if ($options.length) {
                        $options.prop('selected', true);
                    }

                    // Handle price range specially if needed
                    if (attributeName === 'price' && val.includes('-')) {
                        const [min, max] = val.split('-');
                        const $minInput = $form.find('input.dapfforwc-filters-range-min');
                        const $maxInput = $form.find('input.dapfforwc-filters-range-max');

                        if ($minInput.length && $maxInput.length) {
                            $minInput.val(min);
                            $maxInput.val(max);
                        }
                    }
                });
            }
        }

        // Trigger filter change event to update the UI
        handleFilterChange($form);
    }


    /**
     * Transform standard filter URL to SEO-friendly URL format
     * @param {string} url - The original URL with standard filter parameters
     * @param {object} seoOptions - The SEO permalink configuration options
     * @returns {string} - The transformed SEO-friendly URL
     */
    function transformToSeoUrl(url, seoOptions) {
        if (!url || !seoOptions) {
            return url; // Return the original URL if no SEO options are provided
        }
        // Parse the current URL
        const urlObj = new URL(url);
        const searchParams = urlObj.searchParams;

        // Create new URLSearchParams for our SEO-friendly URL
        const seoParams = new URLSearchParams();
        seoParams.append('filters', '1'); // Add the filters=1 parameter

        // Prefixes config from SEO options
        const prefixes = seoOptions.dapfforwc_permalinks_prefix_options;

        // Process category parameters
        if (searchParams.has("product-category[]")) {
            // Get all category values and remove duplicates
            const categories = Array.from(new Set(searchParams.getAll("product-category[]")));
            if (categories.length > 0) {
                let catakey = (prefixes && prefixes["product-category"]);
                if (!catakey || catakey === "") {
                    catakey = "cata";
                }
                seoParams.append(catakey, categories.join(','));
            }
        }

        // Process tag parameters
        if (searchParams.has('tags[]')) {
            // Get all tag values and remove duplicates
            const tags = Array.from(new Set(searchParams.getAll('tags[]')));
            if (tags.length > 0) {
                let tagskey = (prefixes && prefixes["tag"]) ?? "tags";
                if (!tagskey || tagskey === "") {
                    tagskey = "tags";
                }
                seoParams.append(tagskey, tags.join(','));
            }
        }

        // Process rating parameters
        if (searchParams.has('rating[]')) {
            const ratings = searchParams.getAll('rating[]');
            if (ratings.length > 0) {
                let ratingKey = (prefixes && prefixes["rating"]) ?? "rating";
                if (!ratingKey || ratingKey === "") {
                    ratingKey = "rating";
                }
                seoParams.append(ratingKey, ratings.join(','));
            }
        }

        // Process price parameters
        if (searchParams.has('min_price') || searchParams.has('max_price')) {
            const minPrice = searchParams.get('min_price') || '';
            const maxPrice = searchParams.get('max_price') || '';
            if (minPrice || maxPrice) {
                let priceKey = (prefixes && prefixes.price) ?? "price";
                if (!priceKey || priceKey === "") {
                    priceKey = "price";
                }
                seoParams.append(priceKey, `${minPrice}-${maxPrice}`);
            }
        }
        // Process search parameter
        if (searchParams.has('s') && searchParams.get('s') !== '') {
            seoParams.append('title', searchParams.get('s'));
        }

        // Process attribute parameters
        const attributeParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an attribute parameter
            if (key.startsWith('attribute[') && key.endsWith('][]')) {
                // Extract attribute name, e.g., 'attribute[brand][]' -> 'brand'
                const attributeName = key.replace('attribute[', '').replace('][]', '');

                if (!attributeParams[attributeName]) {
                    attributeParams[attributeName] = [];
                }
                // Only add if not already present
                if (!attributeParams[attributeName].includes(value)) {
                    attributeParams[attributeName].push(value);
                }
            }
        }

        // Add attribute parameters with their SEO prefix
        for (const [attributeName, values] of Object.entries(attributeParams)) {
            // Use prefix from config if available, otherwise use attributeName as the key
            let prefix = (prefixes && prefixes.attribute && prefixes.attribute[attributeName])
                ? prefixes.attribute[attributeName]
                : attributeName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Build the new URL
        const baseUrl = urlObj.origin + urlObj.pathname;
        const seoQueryString = seoParams.toString();

        return baseUrl + (seoQueryString ? '?' + seoQueryString : '');
    }

    // Initialize on document ready
    $(document).ready(function () {
        initProductFilter();
        initPriceRangeInputs();
    });

    // Expose public API
    window.dapfforwc_FILTER_API = {
        refresh: function () {
            handleFilterChange($(dapfforwc_FILTER.formSelector));
        },
        reset: function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select').prop('selectedIndex', 0);
            $form.find('input[type="text"], input[type="search"]').val('');

            // Reset price range sliders
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                $minRange.val($minRange.attr('min'));
                $maxRange.val($maxRange.attr('max'));
                updatePriceDisplay($minRange);
                updatePriceDisplay($maxRange);
            }

            handleFilterChange($form);
        }
    };

})(jQuery);

// cateogry hide & show manage for herichical
jQuery(document).ready(function ($) {
    $('.show-sub-cata').on('click', function (event) {
        event.preventDefault();
        const $childCategories = $(this).closest('div').next('.child-categories');
        $childCategories.slideToggle(() => {
            $(this).text($childCategories.is(':visible') ? '-' : '+');
        });
    });
});