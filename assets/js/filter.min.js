/**
 * Product Filter - Frontend JavaScript
 */
(function ($) {
    'use strict';

    // Configuration options
    const dapfforwc_FILTER = {
        formSelector: '#product-filter',
        productSelector: '.products',
        paginationSelector: 'nav.woocommerce-pagination',
        sortingSelector: 'form.woocommerce-ordering select',
        filterTriggers: 'input[type="checkbox"], input[type="radio"], select, input[type="range"]',
        searchField: '#plugincy-search-field',
        searchButton: '.plugincy-search-submit',
        spinnerClass: 'dapfforwc-spinner',
        loadingClass: 'dapfforwc-loading',
        debounceTime: 500, // ms to wait before processing input changes
        autoScrollOffset: 100
    };
    window.re_initSelect2_Collaps = function () {
        // these will be no-ops until theyâ€™re defined later,
        // but once the later ready block runs it will overwrite this body.
    };
    let count;
    let advancesettings, dapfforwc_options, dapfforwc_seo_permalinks_options, dapfforwc_styleoptions, shopPageUrl, isProductArchive, currencySymbol, isHomePage;
    let front_page_slug;
    let debounceTimer;
    let lastMirrorSig = '';
    let lastPriceLabel = '';

    const DEBOUNCE_MS = Math.max(180, Math.min(dapfforwc_FILTER.debounceTime || 500, 400)); // clamp ~180-400ms
    let globalDebounceTimer = null;

    const plugincyResponseCache = new Map();
    const CACHE_MAX = 25;




    function debounceRun(fn) {
        clearTimeout(globalDebounceTimer);
        globalDebounceTimer = setTimeout(fn, DEBOUNCE_MS);
    }

    // Extract data from configuration objects using destructuring when available
    if (typeof dapfforwc_data !== 'undefined') {
        ({
            dapfforwc_advance_settings: advancesettings,
            dapfforwc_front_page_slug: front_page_slug,
            dapfforwc_options,
            dapfforwc_seo_permalinks_options,
            dapfforwc_styleoptions
        } = dapfforwc_data);
    }

    if (typeof dapfforwc_ajax !== 'undefined') {
        ({
            shopPageUrl,
            isProductArchive,
            currencySymbol,
            isHomePage
        } = dapfforwc_ajax);
    }

    plugincydebugLog("Form Manage Settings : ", dapfforwc_options);
    plugincydebugLog("Form Style Settings : ", dapfforwc_styleoptions);
    plugincydebugLog("SEO setup Settings : ", dapfforwc_seo_permalinks_options);
    plugincydebugLog("Advanced Settings : ", advancesettings);

    var rfilterbuttonsId = $('.rfilterbuttons').attr('id');

    /**
     * Determines the appropriate product selector based on priority order:
     * 1. Shortcode-defined selector
     * 2. Global settings selector
     * 3. Custom class selectors (fallback options)
     * 
     * @returns {string} The product selector string
     */
    function getProductSelector() {
        const DEFAULT_SELECTOR = '.products';

        // Check if shortcode defines a custom selector
        const formElement = $(dapfforwc_FILTER.formSelector);
        const shortcodeSelector = formElement.data('product_selector');

        const validPatterns = [
            /^[a-zA-Z][a-zA-Z0-9\-_]*$/,                    // Element
            /^\.[a-zA-Z][a-zA-Z0-9\-_]*$/,                  // Class
            /^#[a-zA-Z][a-zA-Z0-9\-_]*$/,                   // ID
            /^\[[a-zA-Z][a-zA-Z0-9\-_]*(\=[^\]]+)?\]$/,     // Attribute
            /^[a-zA-Z0-9\s\.\#\[\]\=\:\-\_\,\>\+\~\*\(\)]+$/ // Complex
        ];

        let isValidSelector = shortcodeSelector ? validPatterns.some(pattern => pattern.test(shortcodeSelector)) : false;
        if (!isValidSelector && shortcodeSelector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        if (isValidSelector && $(shortcodeSelector).length > 0) {
            return shortcodeSelector;
        }


        isValidSelector = advancesettings &&
            advancesettings.product_selector ? validPatterns.some(pattern => pattern.test(advancesettings.product_selector)) : false;
        if (!isValidSelector && advancesettings &&
            advancesettings.product_selector) {
            console.warn("provided selector is wrong. using fallback selector.");
        }

        // Check global settings for custom selector
        if (isValidSelector &&
            $(advancesettings.product_selector).length > 0) {
            return advancesettings.product_selector;
        }

        // Fallback to custom class selectors in priority order
        const fallbackSelectors = [
            '.plugincy-filter-products',
            '.plugincy-filter-products-wrapper > ul',
            '.plugincy-filter-products-wrapper > div'
        ];

        for (let i = 0; i < fallbackSelectors.length; i++) {
            const selector = fallbackSelectors[i];
            if ($(selector).length > 0) {
                return selector;
            }
        }

        // Final fallback: find parent of plugincy-filter-product-item
        const productItemElement = $('.plugincy-filter-product-item');
        if (productItemElement.length > 0) {
            const parentElement = productItemElement.parent();
            if (parentElement.length > 0) {
                const parentTag = parentElement.get(0).tagName.toLowerCase();
                const parentClass = parentElement.attr('class');
                const parentId = parentElement.attr('id');

                let parentSelector = parentTag;
                if (parentId) {
                    parentSelector = `#${parentId}`;
                } else if (parentClass) {
                    parentSelector = `${parentTag}.${parentClass.split(' ').join('.')}`;
                }
                return parentSelector;
            }
        }
        return DEFAULT_SELECTOR;
    }

    window.getProductSelector = $(getProductSelector()).length > 0;
    window.getProductSelectorString = getProductSelector();

    const product_selector = getProductSelector();

    const PAGINATION_INTERACTIVE_TARGETS = 'a, button, span, [role="button"], [data-page], [data-pagination], [data-next-page], [data-page-url], [data-url], [data-load-page], [data-target-page], [data-goto], .load-more-button, .plugincy-load-more, .woocommerce-load-more, .infinite-scroll-trigger, .jet-load-more__link, .elementor-pagination__link, .page-numbers li';
    const LOAD_MORE_CLASS_HINTS = [
        'load-more',
        'loadmore',
        'load_more',
        'plugincy-load-more',
        'plugincy_load_more',
        'woocommerce-load-more',
        'products-load-more',
        'products_load_more',
        'ajax-load-more',
        'infinite-scroll',
        'infinite_scroll',
        'infinite-scroll-trigger',
        'infinite_scroll_trigger',
        'jet-load-more',
        'jet_load_more',
        'elementor-load-more',
        'elementor_load_more',
        'yith-infs',
        'yith-wcan',
        'wcl-load-more',
        'flatsome-load-more',
        'astra-load-more',
        'woodmart-load-more'
    ];
    const LOAD_MORE_DATA_HINTS = [
        'load',
        'append',
        'infinite',
        'lazy',
        'next',
        'more',
        'scroll'
    ];
    const LOAD_MORE_WRAPPER_HINTS = [
        '.plugincy-load-more-wrapper',
        '.plugincy-load-more',
        '.woocommerce-load-more',
        '.products-load-more',
        '.load-more',
        '.loadmore',
        '.infinite-scroll',
        '.infinite-scroll-trigger',
        '.jet-load-more',
        '.jet-woo-builder__load-more',
        '.yith-wcan-infinite-scroll',
        '.yith-wcan-load-more',
        '.wcl-load-more',
        '.elementor-pagination',
        '.elementor-load-more',
        '.woolentor-load-more',
        '.flatsome-load-more'
    ];
    const LOAD_MORE_TEXT_HINTS = [
        'load more',
        'show more',
        'view more',
        'more products',
        'more items',
        'more results',
        'more goods',
        'more posts',
        'next page',
        'next products',
        'next items'
    ];

    function coerceTojQuery(element) {
        if (!element) return null;
        if (element.jquery) return element;
        if (element instanceof $) return element;
        if (element.nodeType || element === window || element === document) return $(element);
        if (typeof element === 'string') {
            try {
                const $el = $(element);
                return $el.length ? $el : null;
            } catch (_error) {
                return null;
            }
        }
        return null;
    }

    function createPaginationInteraction(overrides) {
        const base = {
            mode: 'replace',
            trigger: null,
            wrapper: null,
            reason: 'paginate'
        };
        if (!overrides) return base;
        const clone = Object.assign({}, base, overrides);
        clone.trigger = coerceTojQuery(clone.trigger);
        clone.wrapper = coerceTojQuery(clone.wrapper);
        clone.mode = clone.mode === 'append' ? 'append' : 'replace';
        return clone;
    }

    let paginationInteraction = createPaginationInteraction();

    function setPaginationInteractionState(options) {
        paginationInteraction = createPaginationInteraction(options);
        if (paginationInteraction.mode === 'append' && (!paginationInteraction.trigger || !paginationInteraction.trigger.length) && paginationInteraction.wrapper && paginationInteraction.wrapper.length) {
            paginationInteraction.trigger = paginationInteraction.wrapper;
        }
        if (paginationInteraction.mode === 'append' && paginationInteraction.trigger && paginationInteraction.trigger.length) {
            setLoadMoreButtonState(paginationInteraction.trigger, true);
        }
    }

    function resetPaginationInteractionState() {
        if (paginationInteraction && paginationInteraction.trigger && paginationInteraction.trigger.length) {
            setLoadMoreButtonState(paginationInteraction.trigger, false);
        }
        paginationInteraction = createPaginationInteraction();
    }

    function ensureLoadMoreInlineStyles() {
        if (document.getElementById('dapfforwc-load-more-style')) return;
        const style = document.createElement('style');
        style.id = 'dapfforwc-load-more-style';
        style.textContent = '.dapfforwc-load-more-loading{position:relative;} .dapfforwc-load-more-spinner{display:inline-block;width:1em;height:1em;border:2px solid currentColor;border-top-color:transparent;border-radius:50%;animation:dapfforwc_spin .65s linear infinite;margin-left:.5em;vertical-align:middle;}@keyframes dapfforwc_spin{to{transform:rotate(360deg);}}';
        document.head.appendChild(style);
    }

    function setLoadMoreButtonState($button, isLoading) {
        $button = coerceTojQuery($button);
        if (!$button || !$button.length) return;
        ensureLoadMoreInlineStyles();
        const isInteractive = $button.is('button, input, [role="button"], a');
        if (isLoading) {
            $button.addClass('dapfforwc-load-more-loading').attr('aria-busy', 'true');
            if (isInteractive && $button.is('button, input, [role="button"]')) {
                $button.prop('disabled', true);
            }
            if ($button.is('a')) {
                $button.attr('aria-disabled', 'true');
            }
            if (!$button.find('> .dapfforwc-load-more-spinner').length) {
                $button.append('<span class="dapfforwc-load-more-spinner" aria-hidden="true"></span>');
            }
        } else {
            $button.removeClass('dapfforwc-load-more-loading').attr('aria-busy', 'false');
            if (isInteractive && $button.is('button, input, [role="button"]')) {
                $button.prop('disabled', false);
            }
            if ($button.is('a')) {
                $button.removeAttr('aria-disabled');
            }
            $button.find('> .dapfforwc-load-more-spinner').remove();
        }
    }

    function elementHasClassHint($element, hints) {
        if (!$element || !$element.length) return false;
        const cls = ($element.attr('class') || '').toLowerCase();
        return hints.some(hint => cls.indexOf(hint) !== -1);
    }

    function elementHasDataHint(element, hints) {
        if (!element) return false;
        const el = element.jquery ? element.get(0) : element;
        if (!el) return false;
        const dataset = el.dataset || {};
        for (const key in dataset) {
            if (!Object.prototype.hasOwnProperty.call(dataset, key)) continue;
            const normalizedKey = key.toLowerCase();
            const value = String(dataset[key]).toLowerCase();
            if (hints.some(h => normalizedKey.indexOf(h) !== -1 || value.indexOf(h) !== -1)) {
                return true;
            }
        }
        return false;
    }

    function elementAttrHasHint($element, attrNames, hints) {
        if (!$element || !$element.length) return false;
        for (const attr of attrNames) {
            const value = ($element.attr(attr) || '').toLowerCase();
            if (!value) continue;
            if (hints.some(h => value.indexOf(h) !== -1)) {
                return true;
            }
        }
        return false;
    }

    function isLoadMoreTrigger($element, $wrapper, detail) {
        if (detail && (detail.mode === 'append' || detail.append === true || detail.infinite === true)) {
            return true;
        }
        if ($element && elementHasClassHint($element, LOAD_MORE_CLASS_HINTS)) {
            return true;
        }
        if ($wrapper && elementHasClassHint($wrapper, LOAD_MORE_CLASS_HINTS)) {
            return true;
        }
        if ($element && elementAttrHasHint($element, ['rel', 'data-action', 'data-behavior', 'data-trigger', 'data-pagination', 'data-pagination-type', 'data-pagination-mode', 'data-mode', 'data-load', 'data-loader'], LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($wrapper && elementAttrHasHint($wrapper, ['data-pagination', 'data-mode', 'data-load'], LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($element && elementHasDataHint($element, LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($wrapper && elementHasDataHint($wrapper, LOAD_MORE_DATA_HINTS)) {
            return true;
        }
        if ($element && $element.attr('rel') && $element.attr('rel').toLowerCase() === 'next') {
            return true;
        }
        // Direct selector hints for wrappers (even if no classes on elements)
        if ($wrapper) {
            const matchesHint = LOAD_MORE_WRAPPER_HINTS.some(function (selector) {
                try {
                    return $wrapper.is(selector) || $wrapper.find(selector).length > 0;
                } catch (_error) {
                    return false;
                }
            });
            if (matchesHint) return true;
        }
        if ($element) {
            const matchesHint = LOAD_MORE_WRAPPER_HINTS.some(function (selector) {
                try {
                    return $element.is(selector) || $element.closest(selector).length > 0;
                } catch (_error) {
                    return false;
                }
            });
            if (matchesHint) return true;
        }
        if ($element && LOAD_MORE_TEXT_HINTS.length) {
            const txt = ($element.text() || '').toLowerCase();
            if (txt && LOAD_MORE_TEXT_HINTS.some(function (hint) { return txt.indexOf(hint) !== -1; })) {
                return true;
            }
        }
        return false;
    }

    function normalizePaginationSelectorInput(value) {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (typeof value !== 'string') return [];

        const selectors = [];
        let current = '';
        let depth = 0;

        for (let i = 0; i < value.length; i++) {
            const char = value[i];
            if (char === '(' || char === '[') {
                depth++;
                current += char;
            } else if (char === ')' || char === ']') {
                depth = Math.max(0, depth - 1);
                current += char;
            } else if (char === ',' && depth === 0) {
                if (current.trim()) {
                    selectors.push(current.trim());
                }
                current = '';
            } else {
                current += char;
            }
        }

        if (current.trim()) {
            selectors.push(current.trim());
        }

        return selectors;
    }

    function selectorExists(selector) {
        if (!selector || typeof selector !== 'string') return false;
        try {
            return document.querySelector(selector) !== null;
        } catch (error) {
            plugincydebugLog('Invalid pagination selector detected:', selector, error);
            return false;
        }
    }

    function isValidJquerySelector(selector) {
        if (!selector || typeof selector !== 'string') return false;
        try {
            $(selector);
            return true;
        } catch (error) {
            plugincydebugLog('Invalid pagination selector detected:', selector, error);
            return false;
        }
    }

    function collectPaginationSelectors() {
        const selectors = new Set();
        const addSelector = (selector, requirePresence = false) => {
            if (!selector || typeof selector !== 'string') return;
            const trimmed = selector.trim();
            if (!trimmed) return;
            if (!isValidJquerySelector(trimmed)) return;
            if (requirePresence && !selectorExists(trimmed)) return;
            selectors.add(trimmed);
        };

        const paginationSelector_shortcode = $('#product-filter').data('pagination_selector');
        normalizePaginationSelectorInput(paginationSelector_shortcode).forEach(sel => addSelector(sel));

        if (advancesettings && advancesettings["pagination_selector"]) {
            normalizePaginationSelectorInput(advancesettings["pagination_selector"]).forEach(sel => addSelector(sel));
        }

        addSelector('.plugincy-filter-pagination');

        const fallbackSelectors = [
            'nav.woocommerce-pagination',
            '.woocommerce-pagination',
            '.woocommerce nav.navigation',
            '.woocommerce .navigation',
            '.woocommerce .nav-links',
            '.woocommerce .pagination',
            '.woocommerce .paginate_links',
            '.woocommerce .paginate-links',
            '.wc-block-pagination',
            '.wp-block-query-pagination',
            '.products + .navigation',
            '.woocommerce-result-count + .navigation',
            'ul.page-numbers',
            '.page-numbers',
            '.pagination',
            '.woocommerce .load-more',
            '.woocommerce .load-more-button',
            '.woocommerce .products-load-more',
            '.woocommerce .ajax-load-more',
            '.woocommerce .woocommerce-load-more',
            '.woocommerce .elementor-pagination',
            '.woocommerce .jet-load-more',
            '.woocommerce .jet-woo-builder__load-more',
            '.woocommerce .yith-infs-nav',
            '.woocommerce .yith-wcan-infinite-scroll',
            '.woocommerce .yith-wcan-load-more',
            '.woocommerce .infinite-scroll',
            '.woocommerce .infinite-scroll-trigger',
            '.woocommerce .wcl-pagination',
            '.woocommerce .woo-pagination'
        ];

        fallbackSelectors.forEach(sel => addSelector(sel, true));

        if (!selectors.size) {
            addSelector('.plugincy-filter-pagination');
        }

        return Array.from(selectors);
    }

    function parsePageNumber(value, increment = 0) {
        if (value === undefined || value === null || value === '') return null;
        let numeric;
        if (typeof value === 'number') {
            numeric = value;
        } else {
            const match = String(value).match(/-?\d+/);
            numeric = match ? parseInt(match[0], 10) : NaN;
        }
        if (isNaN(numeric)) return null;
        numeric += increment;
        if (numeric < 1) return null;
        return numeric;
    }

    function readPaginationDataAttr($element, attrName) {
        if (!$element || !$element.length || !attrName) return null;
        const el = $element.get(0);
        if (!el) return null;
        const normalizedAttr = attrName.replace(/^data-/, '');
        const datasetKey = normalizedAttr.replace(/-([a-z])/g, function (_match, chr) {
            return chr.toUpperCase();
        });
        if (typeof $element.data === 'function') {
            const dataValue = $element.data(datasetKey);
            if (dataValue !== undefined) return dataValue;
        }
        if (el.dataset && Object.prototype.hasOwnProperty.call(el.dataset, datasetKey)) {
            return el.dataset[datasetKey];
        }
        const attrVariants = attrName.startsWith('data-') ? [attrName, normalizedAttr] : [attrName, `data-${normalizedAttr}`];
        for (const attr of attrVariants) {
            if (el.hasAttribute && el.hasAttribute(attr)) {
                return el.getAttribute(attr);
            }
        }
        return null;
    }

    function extractPageFromUrl(rawUrl) {
        if (!rawUrl) return null;
        try {
            const parsed = new URL(rawUrl, window.location.origin);
            const params = parsed.searchParams;
            const queryPage = params.get('paged') || params.get('page') || params.get('product-page');
            const parsedQuery = parsePageNumber(queryPage);
            if (parsedQuery) return parsedQuery;
            const pathMatch = parsed.pathname.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
            if (pathMatch && pathMatch[1]) {
                return parsePageNumber(pathMatch[1]);
            }
        } catch (_error) {
            const fallbackPath = rawUrl.match(/(?:\/page\/|\/product-page\/)(\d+)/i);
            if (fallbackPath && fallbackPath[1]) {
                return parsePageNumber(fallbackPath[1]);
            }
            const fallbackQuery = rawUrl.match(/[?&](?:paged|page|product-page)=(\d+)/i);
            if (fallbackQuery && fallbackQuery[1]) {
                return parsePageNumber(fallbackQuery[1]);
            }
        }
        return null;
    }

    function getPageFromElement($element, $wrapper) {
        const attrGroups = [
            { names: ['target-page', 'page-target', 'goto', 'go-to', 'go_to', 'pageToLoad', 'page-to-load'], increment: 0 },
            { names: ['next-page', 'nextpage', 'next_page', 'next', 'load-page', 'loadpage', 'load_page', 'upcoming-page', 'upcomingPage'], increment: 0 },
            { names: ['page', 'paged', 'pagination', 'page-num', 'page-number', 'pageindex', 'pageIndex', 'page-id', 'pageId'], increment: 0 },
            { names: ['current', 'current-page', 'current_page', 'currentPage'], increment: 1 }
        ];
        const sources = [$element, $wrapper];
        for (const group of attrGroups) {
            for (const src of sources) {
                if (!src || !src.length) continue;
                for (const name of group.names) {
                    const value = readPaginationDataAttr(src, name);
                    const parsed = parsePageNumber(value, group.increment);
                    if (parsed) return parsed;
                }
            }
        }

        const valueAttr = $element ? $element.attr('value') : null;
        const pageFromValue = parsePageNumber(valueAttr);
        if (pageFromValue) return pageFromValue;

        const textContent = $element && typeof $element.text === 'function' ? $element.text() : '';
        const pageFromText = parsePageNumber(textContent);
        if (pageFromText) return pageFromText;

        if ($wrapper && $wrapper.length) {
            const $current = $wrapper.find('.current, .is-active, .active').last();
            const fromCurrent = parsePageNumber($current.text(), 1);
            if (fromCurrent) return fromCurrent;
        }

        return null;
    }

    function getUrlFromElement($element, $wrapper) {
        const attrNames = ['href', 'data-url', 'data-href', 'data-link', 'data-target', 'data-page-url', 'data-next-url', 'data-load-url', 'data-pagination-url'];
        const sources = [$element, $wrapper];
        for (const src of sources) {
            if (!src || !src.length) continue;
            for (const attr of attrNames) {
                let value = null;
                if (attr === 'href') {
                    value = src.attr(attr);
                } else {
                    value = readPaginationDataAttr(src, attr);
                }
                if (value && value !== '#' && !String(value).startsWith('javascript')) {
                    return value;
                }
            }
        }
        return null;
    }

    function buildPaginationPayload($element, $wrapper) {
        const inferredPage = getPageFromElement($element, $wrapper);
        const url = getUrlFromElement($element, $wrapper);
        return {
            page: inferredPage || extractPageFromUrl(url),
            url: url || null
        };
    }

    function dispatchFilteredPaginationRequest(payload, interactionOptions) {
        if (!payload) return;
        const $form = $(dapfforwc_FILTER.formSelector);
        if (!$form.length) return;

        let targetPage = parsePageNumber(payload.page) || extractPageFromUrl(payload.url) || null;
        const isAppendMode = interactionOptions && interactionOptions.mode === 'append';
        if (!targetPage && isAppendMode) {
            const current = parsePageNumber(filterState.currentPage) || 1;
            targetPage = current + 1;
        }
        if (!targetPage || targetPage < 1) {
            targetPage = 1;
        }

        if (filterState.isLoading) {
            return;
        }

        setPaginationInteractionState(interactionOptions);
        $('#roverlay').show();
        $('#loader').show();
        const started = handleFilterChange($form, targetPage);
        if (!started) {
            resetPaginationInteractionState();
            $('#roverlay').hide();
            $('#loader').hide();
        }
    }

    function registerExternalPaginationAPI() {
        window.dapfforwcLoadPage = function (pageOrPayload, maybeUrlOrOptions, maybeOptions) {
            let payload = {};
            let interaction = null;

            if (pageOrPayload && typeof pageOrPayload === 'object' && !Array.isArray(pageOrPayload)) {
                payload.page = pageOrPayload.page || pageOrPayload.paged || pageOrPayload.nextPage || pageOrPayload.targetPage || null;
                payload.url = pageOrPayload.url || pageOrPayload.href || pageOrPayload.link || null;
                interaction = pageOrPayload;
            } else {
                payload.page = pageOrPayload;
                if (typeof maybeUrlOrOptions === 'string') {
                    payload.url = maybeUrlOrOptions;
                    interaction = (maybeOptions && typeof maybeOptions === 'object') ? maybeOptions : null;
                } else if (maybeUrlOrOptions && typeof maybeUrlOrOptions === 'object') {
                    payload.url = maybeUrlOrOptions.url || maybeUrlOrOptions.href || null;
                    interaction = maybeUrlOrOptions;
                } else {
                    payload.url = null;
                    interaction = null;
                }
            }

            dispatchFilteredPaginationRequest(payload, interaction);
        };

        $(document)
            .off('.dapfforwcPaginationBridge')
            .on('dapfforwc:loadPage.dapfforwcPaginationBridge plugincy:loadPage.dapfforwcPaginationBridge dapfforwc:paginate.dapfforwcPaginationBridge', function (_event, detail) {
                if (detail === undefined || detail === null) return;

                let payload;
                if (typeof detail === 'number') {
                    payload = { page: detail };
                } else if (typeof detail === 'string') {
                    payload = { url: detail };
                } else {
                    payload = {
                        page: detail.page || detail.paged || detail.nextPage || detail.targetPage || detail.index || null,
                        url: detail.url || detail.href || detail.link || null
                    };
                }

                if (!payload || (payload.page === null || payload.page === undefined) && !payload.url) {
                    return;
                }

                dispatchFilteredPaginationRequest(payload, typeof detail === 'object' ? detail : null);
            });
    }

    const paginationSelectors = collectPaginationSelectors();
    const pagination_selector = paginationSelectors.length ? paginationSelectors.join(', ') : '.plugincy-filter-pagination';

    registerExternalPaginationAPI();


    function attachPaginationEvents() {
        if (!pagination_selector) return;
        $(document).off('click.dapfforwcPagination');
        const delegateSelector = `${pagination_selector}, ${pagination_selector} ${PAGINATION_INTERACTIVE_TARGETS}`;
        $(document).on('click.dapfforwcPagination', delegateSelector, function (e) {
            const $target = $(e.target);
            if (!$target || !$target.length) return;
            const $wrapper = $target.closest(pagination_selector);
            if (!$wrapper.length) return;
            let $clickable = $target.closest(PAGINATION_INTERACTIVE_TARGETS);
            if (!$clickable.length || !$clickable.closest($wrapper).length) {
                $clickable = $wrapper;
            }

            const payload = buildPaginationPayload($clickable, $wrapper);
            const isLoadMore = isLoadMoreTrigger($clickable, $wrapper);
            if ((!payload.page && !payload.url) && !isLoadMore) {
                return;
            }
            if (!payload.page && !payload.url && isLoadMore) {
                payload.page = parsePageNumber(
                    readPaginationDataAttr($wrapper, 'next-page') ||
                    readPaginationDataAttr($wrapper, 'next') ||
                    readPaginationDataAttr($wrapper, 'page') ||
                    readPaginationDataAttr($wrapper, 'paged') ||
                    readPaginationDataAttr($wrapper, 'current-page') ||
                    readPaginationDataAttr($wrapper, 'current')
                ) || parsePageNumber(filterState.currentPage, 1) || 1;
                payload.url = payload.url || readPaginationDataAttr($wrapper, 'url') || readPaginationDataAttr($wrapper, 'href') || null;
            }
            if (!payload.page && !payload.url) return;

            const interactionOptions = {
                mode: isLoadMore ? 'append' : 'replace',
                trigger: isLoadMore ? $clickable : null,
                wrapper: $wrapper,
                reason: isLoadMore ? 'load-more' : 'paginate'
            };

            e.preventDefault();
            e.stopPropagation();
            dispatchFilteredPaginationRequest(payload, interactionOptions);
        });
    }

    // Call this function after updating the product listings
    if ($('#product-filter').length) {
        attachPaginationEvents();
    }

    // Store the current filter state
    let filterState = {
        currentRequest: null,
        isLoading: false,
        pendingChanges: false,
        currentPage: 1,
        pendingPage: 1
    };

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('filters')) {
        count = 1;
        applyFiltersFromUrl(urlParams.get('filters'));
        count = 0;

    } else {
        const $form = $(dapfforwc_FILTER.formSelector);
        handleFilterChange($form, 1, true);
    }
    /**
     * Initialize the filter functionality
     */
    function initProductFilter() {
        const $form = $(dapfforwc_FILTER.formSelector);

        if ($form.length === 0) {
            return;
        }

        // Bind events to filter elements
        bindFilterEvents($form);

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function (event) {
            // Only handle our own state changes
            if (event.state && event.state.dapfforwcFilter) {
                window.location.reload();
            }
        });

        initSorting();
    }
    // single filter handle
    syncCheckboxSelections();

    function syncCheckboxSelections() {
        const $container = $('.rfilterbuttons ul');
        if (!$container.length) return;

        // Make a stable signature of current inputs to avoid needless rebuilds
        const sig = $('#product-filter #' + rfilterbuttonsId + ' input, #product-filter #' + rfilterbuttonsId + ' option')
            .map(function () { return this.name + ':' + this.value + ':' + (this.checked || this.selected); })
            .get().join('|');

        if (sig === lastMirrorSig) return;
        lastMirrorSig = sig;

        $container.empty();
        const frag = document.createDocumentFragment();

        $('#product-filter #' + rfilterbuttonsId + ' input').each(function () {
            frag.appendChild(createCheckboxListItem($(this).val(), $(this).is(':checked'), this.type)[0]);
        });

        $('#product-filter #' + rfilterbuttonsId + ' option').each(function (i) {
            if (i === 0) return;
            frag.appendChild(createCheckboxListItem($(this).val(), $(this).is(':checked'), this.type)[0]);
        });
        $container[0].appendChild(frag);
        attachCheckboxClickEvents();
        attachMainFilterChangeEvents();
    }
    function createCheckboxListItem(value, checked, type) {
        const formattedLabel = value.split('-').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        return $('<li></li>').addClass(checked ? 'checked' : '').append(
            $('<input>', {
                name: 'attribute[' + rfilterbuttonsId + '][]',
                id: 'text_' + value,
                type: 'checkbox',
                value: value,
                checked: checked
            }).on('change', syncToMainFilter),
            $('<label></label>', {
                for: 'text_' + value,
                text: formattedLabel
            })
        );
    }

    function syncToMainFilter() {
        $(`#product-filter #${rfilterbuttonsId} input[value="${$(this).val()}"]`).prop('checked', $(this).is(':checked'));
        $(`#product-filter #${rfilterbuttonsId} select option[value="${$(this).val()}"]`).prop('selected', $(this).is(':checked'));
    }

    function attachCheckboxClickEvents() {
        $('.rfilterbuttons ul').off('click', 'li').on('click', 'li', function () {
            const checkbox = $(this).find('input');
            checkbox.prop('checked', !checkbox.is(':checked')).trigger('change');
            $(this).toggleClass('checked', checkbox.is(':checked'));
        });
    }

    function attachMainFilterChangeEvents() {
        $('#' + rfilterbuttonsId + ' input').on('change', function () {
            const relatedCheckbox = $(`.rfilterbuttons ul li input[value="${$(this).val()}"]`);
            relatedCheckbox.prop('checked', $(this).is(':checked')).closest('li').toggleClass('checked', $(this).is(':checked'));
        });
    }

    function store_selected_values() {
        const filtersByType = {};
        const options_selector = "#product-filter input:checked:not('.default_values input')";
        // Handle checked checkboxes and radios
        $(options_selector).each(function () {
            const value = $(this).val();
            const name = $(this).attr('name');
            if (!filtersByType[name]) {
                filtersByType[name] = [];
            }
            if (!filtersByType[name].includes(value)) {
                filtersByType[name].push(value);
            }
        });
        // Handle selected options in select elements (excluding default/empty)
        $('#product-filter select').each(function () {
            const name = $(this).attr('name');
            const selectedValues = $(this).val();
            if (selectedValues && selectedValues.length > 0) {
                if (!filtersByType[name]) {
                    filtersByType[name] = [];
                }
                if (Array.isArray(selectedValues)) {
                    selectedValues.forEach(v => {
                        if (v !== "" && v !== "Any" && !filtersByType[name].includes(v)) {
                            filtersByType[name].push(v);
                        }
                    });
                } else if (selectedValues !== "" && selectedValues !== "Any" && !filtersByType[name].includes(selectedValues)) {
                    filtersByType[name].push(selectedValues);
                }
            }
        });
        return filtersByType;
    }

    // create list of current selected filter
    function selectedFilterShowProductTop() {
        const list = document.querySelector('.rfilterselected ul');
        if (!list) return;
        const frag = document.createDocumentFragment();

        const selected = store_selected_values();
        const add = (id, label, value, extraCls = '') => {
            const li = document.createElement('li');
            li.className = `checked ${extraCls}`.trim();
            li.innerHTML =
                `<input id="${id}" type="checkbox" value="${value}" checked>
       <label for="${id}">${label}</label>
       <label style="font-size:12px;margin-left:5px;">x</label>`;
            frag.appendChild(li);
        };

        if (Array.isArray(selected)) {
            for (const v of selected) add(`selected_${v}`, v.replace(/-/g, ' '), v);
        } else if (selected && typeof selected === 'object') {
            for (const k in selected) {
                for (const v of selected[k]) add(`selected_${k}_${v}`, v.replace(/-/g, ' '), v);
            }
        }

        const sv = $('input#plugincy-search-field').val();
        if (sv) add('selected_search', `Searched: ${sv.replace(/-/g, ' ')}`, sv, 'checked-plugincy-search-field');

        // Replace children in one go
        list.replaceChildren(frag);
    }


    // pagination handle

    let selectedValesbyuser = store_selected_values();

    selectedFilterShowProductTop();

    /**
     * Bind events to filter form elements
     */
    function bindFilterEvents($form) {
        // Handle filter changes with debounce
        let debounceTimer;

        // Track checkbox and radio changes
        $form.on('change', dapfforwc_FILTER.filterTriggers, function () {
            filterState.pendingChanges = true;

            selectedValesbyuser = store_selected_values();

            selectedFilterShowProductTop();

            debounceRun(function () {
                if (filterState.pendingChanges) handleFilterChange($form);
            });
        });

        $('.rfilterbuttons').on('change', function () {
            selectedFilterShowProductTop();
            filterState.pendingChanges = true;
            debounceRun(function () {
                if (filterState.pendingChanges) handleFilterChange($form);
            });
        });

        // Handle price range inputs
        $form.on('input', 'input[type="range"]', function () {
            updatePriceDisplay($(this));
        });

        // Handle search button click
        $form.on('click', dapfforwc_FILTER.searchButton, function (e) {
            e.preventDefault();
            handleFilterChange($form);
        });

        // Handle search on enter key
        $(dapfforwc_FILTER.searchField).on('keypress', function (e) {
            if (e.which === 13) {
                e.preventDefault();
                handleFilterChange($form);
            }
        });

        // // Reset rating filter
        // // Reset rating filter
        // $form.on('click', '.reset-value', function () {
        //     const $ratingInputs = $form.find('input[name="rating[]"]');
        //     $ratingInputs.prop('checked', false);
        //     handleFilterChange($form);
        // });

        // Reset all filters in the same .filter-group as the clicked .close button
        $(document).on('click', '.reset-value', function () {
            const $filterGroup = $(this).closest('.filter-group');
            $filterGroup.find('.items input').each(function () {
                if (this.type === 'checkbox' || this.type === 'radio') {
                    $(this).prop('checked', false);
                }
            });
            $filterGroup.find('.items select').each(function () {
                $(this).prop('selectedIndex', 0);
            });
            $filterGroup.find('.items input[type="text"], .items input[type="search"]').each(function () {
                $(this).val('');
            });
            selectedFilterShowProductTop();
            handleFilterChange($form);
        });
    }

    $('.rfilterselected').on('change', 'li', function (e) {
        const $form = $(dapfforwc_FILTER.formSelector);
        const value = $(this).find('input').val();
        if ($(this).hasClass('checked-plugincy-search-field')) {
            $('input#plugincy-search-field').val('');
        } else {
            $(`#product-filter input[value="${value}"]`).prop('checked', false);
        }
        selectedValesbyuser = store_selected_values();
        selectedFilterShowProductTop();
        handleFilterChange($form);
    });

    $('#product-filter').on('change', 'input', function () {
        const name = $(this).attr('name');
        const value = $(this).val();
        const checked = $(this).is(':checked');
        // Find all inputs with same name and value, except the one just changed
        $(`#product-filter input[name="${name}"][value="${value}"]`).not(this).prop('checked', checked);
    });

    /**
     * Handle changes to filter form elements
     */
    function handleFilterChange($form, $page = 1, $isCacheOnly = false) {
        filterState.pendingChanges = false;
        const normalizedPage = parsePageNumber($page) || 1;
        filterState.pendingPage = normalizedPage;

        // Check if we're already processing a request
        if (filterState.isLoading) {
            return false;
        }

        // Get the serialized form data
        // Serialize form data, but remove fields where value is "any"
        let formArray = $form.serializeArray().filter(function (item) {
            return item.value !== "Any";
        });

        // Get current price range values
        const $minRange = $form.find('.range-min');
        const $maxRange = $form.find('.range-max');

        if ($minRange.length && $maxRange.length) {
            // Get default min/max prices
            const defaultMinPrice = $minRange.attr('min') || '';
            const defaultMaxPrice = $maxRange.attr('max') || '';

            // Get current min/max prices
            const currentMinPrice = $minRange.val() || defaultMinPrice;
            const currentMaxPrice = $maxRange.val() || defaultMaxPrice;

            // Check if price has changed from defaults
            const priceHasChanged = (
                currentMinPrice !== defaultMinPrice ||
                currentMaxPrice !== defaultMaxPrice
            );

            // Filter out price parameters if they haven't changed
            if (!priceHasChanged) {
                formArray = formArray.filter(function (item) {
                    return item.name !== 'mn_price' && item.name !== 'mx_price';
                });
            }
        }

        // Merge duplicate fields (e.g., product-category[]) into comma-separated values
        const merged = {};
        formArray.forEach(function (item) {
            if (merged[item.name]) {
                merged[item.name].push(item.value);
            } else {
                merged[item.name] = [item.value];
            }
        });

        // Build param string with comma-separated values for arrays
        const mergedArray = [];
        for (const key in merged) {
            // Remove duplicate values for each key
            const uniqueValues = Array.from(new Set(merged[key]));
            if (uniqueValues.length > 1) {
                mergedArray.push({
                    name: key,
                    value: uniqueValues.join(',')
                });
            } else {
                mergedArray.push({
                    name: key,
                    value: uniqueValues[0]
                });
            }
        }
        const formData = $.param(mergedArray);

        let product_show_settings = $form.data("product_show_settings");
        if (typeof product_show_settings === "string") {
            try {
                product_show_settings = JSON.parse(product_show_settings);
            } catch (e) {
                product_show_settings = {};
            }
        } else if (typeof product_show_settings !== "object" || product_show_settings === null) {
            product_show_settings = {};
        }

        // Access each value
        let perPage = product_show_settings.per_page;          // "5"
        let orderBy = $(dapfforwc_FILTER.sortingSelector).val() === "menu_order" ? product_show_settings.orderby : $(dapfforwc_FILTER.sortingSelector).val();          // "date"
        let order = product_show_settings.order;               // "DESC"
        let operatorSecond = product_show_settings.operator_second; // "in"

        // Build the query URL
        let currentUrl = window.location.href.split('?')[0];
        currentUrl = currentUrl.replace(/\/filters\/[^?]*/, '/?');
        // Remove any trailing "?" if no query follows
        if (currentUrl.endsWith('?')) {
            currentUrl = currentUrl.slice(0, -1);
        }
        const queryString = formData
            .replace(/\+/g, '%20')
            .replace(/%5B/g, '')
            .replace(/%5D/g, '')
            .replace(/attribute/g, 'rplugpa_')
            .replace(/custom_meta/g, 'rplugcusf_');

        let fullUrl;
        fullUrl = currentUrl + (queryString ? '?' + queryString : '');
        if ($page != null) {
            const pageParam = `paged=${$page}&product-page=${$page}`;
            fullUrl += (queryString ? '&' : '?') + pageParam;
        }
        if (orderBy) {
            fullUrl += `&orderby=${orderBy}`;
        }
        if (!isProductArchive) {
            if (perPage) {
                fullUrl += `&per_page=${perPage}`;
            }
            if (operatorSecond) {
                fullUrl += `&operator_second=${operatorSecond}`;
            }
            if (order) {
                fullUrl += `&order=${order}`;
            }
        }

        if ($isCacheOnly) {
            // Get the full HTML of the current document
            const outerHTML = document.documentElement.outerHTML;
            plugincyResponseCache.set(fullUrl, outerHTML);
        } else {
            loadFilteredContentAjax(fullUrl, formData, currentUrl);
        }
        return true;
    }
    /**
     * Load filtered content via AJAX
     */

    function loadFilteredContentAjax(url, formData, currentUrl) {
        plugincydebugLog("Data Fetching From", url);
        const $form = $(dapfforwc_FILTER.formSelector);
        // Abort any pending request
        if (filterState.currentRequest) {
            filterState.currentRequest.abort();
        }

        // Set loading state
        setLoadingState(true);

        if (plugincyResponseCache.has(url)) {
            renderAjaxHTML(plugincyResponseCache.get(url), currentUrl, url); // new helper below
            window.re_initSelect2_Collaps();
            resetPaginationInteractionState();
            setTimeout(() => {
                setLoadingState(false);
            }, 200); // 1000 milliseconds = 1 second
            return;
        }


        // Add X-Requested-With header for WordPress to detect AJAX
        filterState.currentRequest = $.ajax({
            url: url,
            method: 'GET',
            dataType: 'html',
            cache: true,
            ifModified: false,
            headers: { 'X-Requested-With': 'XMLHttpRequest' },
            dapfforwc: true,
            success: function (response) {
                plugincyResponseCache.set(url, response);
                if (plugincyResponseCache.size > CACHE_MAX) {
                    const firstKey = plugincyResponseCache.keys().next().value;
                    plugincyResponseCache.delete(firstKey);
                }

                renderAjaxHTML(response, currentUrl, url);
            },
            error: function (xhr, status, error) {
                if (status !== 'abort') {
                    console.error('Filter request failed:', error);
                }
            },
            complete: function (_jqXHR, _status) {
                setLoadingState(false);
                filterState.currentRequest = null;
                resetPaginationInteractionState();
                // If the user changed something during the request, immediately run the latest state.
                if (filterState.pendingChanges) {
                    debounceRun(function () {
                        handleFilterChange($(dapfforwc_FILTER.formSelector));
                    });
                }
            }


        });
    }

    function gmPfWakeLazyImgs() {
        var root = document;
        var imgs = root.querySelectorAll('img.gm-pf-lazy[data-src]');
        if (!imgs.length) return;

        if ('IntersectionObserver' in window) {
            var io = new IntersectionObserver(function (entries) {
                entries.forEach(function (e) {
                    if (e.isIntersecting) {
                        var el = e.target;
                        el.src = el.dataset.src;
                        el.removeAttribute('data-src');
                        // remove gm-pf-lazy class to prevent re-initialization loops in case of dynamic content load
                        el.classList.remove('gm-pf-lazy');
                        io.unobserve(el);
                    }
                });
            });
            imgs.forEach(function (i) { io.observe(i); });
        } else {
            imgs.forEach(function (i) {
                i.src = i.dataset.src;
                i.removeAttribute('data-src');
                // remove gm-pf-lazy class to prevent re-initialization loops in case of dynamic content load
                i.classList.remove('gm-pf-lazy');
            });
        }
    }


    function renderAjaxHTML(response, currentUrl, url) {
        // Create a temporary DOM element to parse the fetched HTML
        const tempDiv = $('<div>').html(response);
        if (dapfforwc_options.use_url_filter !== "ajax") {
            // Update browser history / url with transformed URL if necessary
            if (dapfforwc_seo_permalinks_options &&
                dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks !== "on") {
                let selectedValuesByUser = store_selected_values(); // Assuming this returns an object

                // Extract values from the object
                let filtersArray = [];

                // Loop through the object and collect values
                for (let key in selectedValuesByUser) {
                    if (Array.isArray(selectedValuesByUser[key])) {
                        filtersArray.push(...selectedValuesByUser[key]); // Spread values into the filters array
                    }
                }

                // Convert to a comma-separated string
                let filters = filtersArray.join(',');
                let searchval = $("input#plugincy-search-field").val();

                // Construct the new URL
                let url = currentUrl;
                url += filters && filters !== '' ? `?filters=${filters}` : (searchval && searchval !== '' ? "?filters" : "");
                url += searchval && searchval !== '' ? '&title=' + searchval : '';

                // Update the browser history
                window.history.pushState({ dapfforwcFilter: true }, '', url);
            }
            if (dapfforwc_seo_permalinks_options &&
                dapfforwc_seo_permalinks_options.use_attribute_type_in_permalinks === "on") {
                url = currentUrl + url.substring(url.indexOf('?'));
                // Transform the URL to SEO format
                let seoUrl = transformToSeoUrl(url, dapfforwc_seo_permalinks_options).replace(/%2C/g, ',');

                // Update the browser history
                window.history.pushState({ dapfforwcFilter: true }, '', seoUrl);
            }
        }

        const isAppendMode = paginationInteraction && paginationInteraction.mode === 'append';
        const appendedProductTargets = new Set();

        // Sources from the fetched tempDiv
        const $srcProducts = tempDiv.find(product_selector);
        const $updatedForm = tempDiv.find(dapfforwc_FILTER.formSelector);
        const $srcResultCount = tempDiv.find('.woocommerce-result-count');

        // Update each .products by index
        const $targetsProducts = $(product_selector);
        if ($targetsProducts.length) {
            if (isAppendMode) {
                $targetsProducts.each(function (i) {
                    const $target = $(this);
                    let $source = $srcProducts.eq(i);
                    if (!$source.length) {
                        $source = $srcProducts.eq(0);
                    }
                    if (!$source || !$source.length) return;
                    const $newItems = $source.children().clone();
                    if ($newItems.length) {
                        $target.append($newItems);
                        appendedProductTargets.add($target.get(0));
                    }
                });
            } else {
                const html = $srcProducts.length ? $srcProducts.eq(0).html() : '<p class="woocommerce-info">No products were found matching your selection.</p>';
                // If there are N targets but only 1 source, reuse its HTML
                $targetsProducts.each(function (i) {
                    $(this).html($srcProducts.length > 1 ? $srcProducts.eq(i).html() : html);
                });
            }
        }
        
        filterState.currentPage = filterState.pendingPage || filterState.currentPage || 1;

        // Update each pagination / load-more container individually
        const paginationTargetsList = paginationSelectors.length ? paginationSelectors : ['.plugincy-filter-pagination'];
        paginationTargetsList.forEach(function (selector) {
            if (!selector) return;
            let $targets;
            let $sources;
            try {
                $targets = $(selector);
                $sources = tempDiv.find(selector);
            } catch (_error) {
                return;
            }
            if (!$targets.length) return;
            const pg = $sources.length ? $sources.eq(0).html() : '';
            $targets.each(function (i) {
                $(this).html($sources.length > 1 ? $sources.eq(i).html() : pg);
            });
        });



        // Update result counts by index (if there are multiple)
        const $targetsResultCount = $('.woocommerce-result-count');
        const $productCountSm = $('#rcountproduct');

        if ($targetsResultCount.length) {
            const rc = $srcResultCount.length ? $srcResultCount.eq(0).html() : '';
            $targetsResultCount.html(rc);
            $productCountSm.html(rc);
        }

        if (dapfforwc_options["update_filter_options"] === "on" && $updatedForm.length) {
            const $children = $updatedForm.children().slice(3);
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.children().slice(3).remove();
            $form.children().eq(2).after($children);
        }

        selectedFilterShowProductTop();
        syncCheckboxSelections();
        initPriceRangeInputs();

        gmPfWakeLazyImgs();

        // Auto-scroll to products container                
        // cheaper scroll (skip if already near)
        requestAnimationFrame(scrollToProducts);

        // Trigger events for other scripts
        $(document).trigger('dapfforwc_filters_updated');
        requestAnimationFrame(function () { $(window).trigger('scroll'); });

    }

    /**
     * Initialize sorting functionality
     */
    function initSorting() {
        // Prevent form submission on pressing Enter
        $('.woocommerce-ordering').on('submit', function (event) {
            event.preventDefault();
        });
        $('.ast-woocommerce-shop-page-modern-style .woocommerce-ordering').on('change', function (e) {
            if ($(e.target).hasClass('orderby')) {
                e.preventDefault(); // Prevent the form submission
                e.stopImmediatePropagation(); // Stop other listeners from being called
                const sortValue = $(this).find('select.orderby').val();
                onsortchange(sortValue);
            }
        });
        $(document).on('change', dapfforwc_FILTER.sortingSelector, function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            const sortValue = $(this).val();
            onsortchange(sortValue);
        });
    }

    function onsortchange(sortValue) {
        // Create or update the orderby hidden input in the filter form
        let $orderbyInput = $('#filter-orderby');
        if ($orderbyInput.length === 0) {
            $orderbyInput = $('<input>').attr({
                type: 'hidden',
                id: 'filter-orderby',
                name: 'orderby',
                value: sortValue
            });
            $(dapfforwc_FILTER.formSelector).append($orderbyInput);
        } else {
            $orderbyInput.val(sortValue);
        }

        // Reset to page 1 when sorting changes
        let $pageInput = $('#filter-page-num');
        if ($pageInput.length) {
            $pageInput.val(1);
        }

        // Trigger filter change with the new sort order
        handleFilterChange($(dapfforwc_FILTER.formSelector));
    }

    /**
     * Set loading state
     */
    function setLoadingState(isLoading) {
        filterState.isLoading = isLoading;
        let isloadingenablebyadmin = dapfforwc_options.show_loader === "on";

        if (isLoading && isloadingenablebyadmin) {
            $('html, body').css('cursor', 'wait');
            showSpinner();
            $(dapfforwc_FILTER.formSelector).addClass(dapfforwc_FILTER.loadingClass);
        } else {
            $('html, body').css('cursor', 'auto');
            hideSpinner();
            $(dapfforwc_FILTER.formSelector).removeClass(dapfforwc_FILTER.loadingClass);
        }
    }

    /**
     * Show loading spinner
     */
    function showSpinner() {
        if (count !== 1) {
            $('#roverlay, #loader').addClass('is-visible');
        }
    }

    /**
     * Hide loading spinner
     */
    function hideSpinner() {
        $('#roverlay, #loader').removeClass('is-visible');
    }

    /**
     * Update price range display
     */
    function updatePriceDisplay($rangeInput) {
        const isMin = $rangeInput.hasClass('range-min');
        const value = Math.ceil(parseFloat($rangeInput.val()));
        const $minInput = $('.range-min');
        const $maxInput = $('.range-max');

        const minValue = Math.floor(parseFloat($minInput.val()) || 0);
        const maxValue = Math.ceil(parseFloat($maxInput.val()) || 0);
        const minPriceDefault = Math.floor(parseFloat($minInput.attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($maxInput.attr('max')) || 100);

        if (isMin) {
            $('#min-price').val(value);
            $('.plugrogress').css('left', ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100) + '%');
        } else {
            $('#max-price').val(value);
            $('.plugrogress').css('right', (100 - ((value - minPriceDefault) / (maxPriceDefault - minPriceDefault) * 100)) + '%');
        }

        // Update price display using custom pseudo-element content
        changePseudoElementContent(`${minValue}`, `${maxValue}`, isMin ? 'min' : 'max');

        // Also update the aria-valuetext for accessibility
        if (isMin) {
            $rangeInput.attr('aria-valuetext', `${value}`);
        } else {
            $rangeInput.attr('aria-valuetext', `${value}`);
        }
    }



    function changePseudoElementContent(minValue, maxValue, activeHandle = null) {
        const newLabel = `${minValue}|${maxValue}|${activeHandle || ''}`;
        if (newLabel === lastPriceLabel) return; // nothing changed
        lastPriceLabel = newLabel;

        let styleEl = document.getElementById('price-range-display-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'price-range-display-style';
            document.head.appendChild(styleEl);
        }

        // Set z-index based on which handle is active
        const minZIndex = activeHandle === 'min' ? 10 : 5;
        const maxZIndex = activeHandle === 'max' ? 10 : 5;

        // Calculate percentage positions for min and max handles
        const minPriceDefault = Math.floor(parseFloat($('.range-min').attr('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($('.range-max').attr('max')) || 100);

        const minPercent = ((minValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;
        const maxPercent = ((maxValue - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100;

        // Check if handles are close to each other (less than 20% apart)
        const areHandlesClose = (maxPercent - minPercent) < 60;


        if (areHandlesClose) {
            let centerPosition;
            // Calculate center position only when handles first get close
            centerPosition = (minPercent + maxPercent) / 2;
            let transform = centerPosition;
            // Prevent the label from going outside the slider bounds
            if (centerPosition < 39) centerPosition = 39;
            if (centerPosition > 70) centerPosition = 0;

            // If handles are close, show combined format in the middle
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue} - ${currencySymbol} ${maxValue}" !important;
                left: ${centerPosition}%;
                transform: translateX(${centerPosition === 0 ? '-' + transform + '%' : '0%'});
                z-index: 10;
            }
            #product-filter .plugrogress-percentage:after {
                content: "" !important;
                display: none;
            }
        `;

        } else {
            // Normal display when handles are far apart
            styleEl.textContent = `
            #product-filter .plugrogress-percentage:before {
                content: "${currencySymbol} ${minValue}" !important;
                z-index: ${minZIndex};
            }
            #product-filter .plugrogress-percentage:after {
                content: "${currencySymbol} ${maxValue}" !important;
                z-index: ${maxZIndex};
            }
        `;
        }
    }


    function initPriceRangeInputs() {
        const $rangeInputs = $(".range-input input");
        const $priceInputs = $(".price-input input");
        const $range = $(".plugincy_slider .plugrogress");

        if ($rangeInputs.length < 2 || $priceInputs.length < 2) return;

        let minPrice = Math.floor(parseFloat($rangeInputs[0].value) || 0);
        let maxPrice = Math.ceil(parseFloat($rangeInputs[1].value) || 0);
        const minPriceDefault = Math.floor(parseFloat($rangeInputs[0].getAttribute('min')) || 0);
        const maxPriceDefault = Math.ceil(parseFloat($rangeInputs[0].getAttribute('max')) || 100);

        $range.css({
            'left': ((minPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
            'right': 100 - ((maxPrice - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%"
        });

        // Initialize price display
        changePseudoElementContent(`${minPrice}`, `${maxPrice}`);

        // Handle range input changes
        $rangeInputs.off('.pf').on("input.pf", function () {
            // update visual only
            const minVal = Math.floor(parseFloat($rangeInputs.eq(0).val()) || 0);
            const maxVal = Math.ceil(parseFloat($rangeInputs.eq(1).val()) || 0);
            changePseudoElementContent(`${minVal}`, `${maxVal}`);
            $priceInputs.eq(0).val(minVal);
            $priceInputs.eq(1).val(maxVal);
            $range.css({
                'left': ((minVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%",
                'right': 100 - ((maxVal - minPriceDefault) / (maxPriceDefault - minPriceDefault)) * 100 + "%"
            });
        });

        $rangeInputs.off('change.pf').on("change.pf", function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            debounceRun(function () { handleFilterChange($form); });
        });

        // --- helpers ---
        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function parseNum(v) {
            const n = parseFloat(v);
            return Number.isFinite(n) ? n : NaN;
        }

        function syncUI(minVal, maxVal) {
            // Push values into both text and range inputs
            $priceInputs.eq(0).val(minVal);
            $priceInputs.eq(1).val(maxVal);
            $rangeInputs.eq(0).val(minVal);
            $rangeInputs.eq(1).val(maxVal);

            // Position the filled range relative to [minPriceDefault, maxPriceDefault]
            const span = (maxPriceDefault - minPriceDefault);
            const leftPct = ((minVal - minPriceDefault) / span) * 100;
            const rightPct = ((maxPriceDefault - maxVal) / span) * 100; // fixed calc

            $range.css('left', `${leftPct}%`);
            $range.css('right', `${rightPct}%`);

            // Update bubble/labels
            changePseudoElementContent(String(minVal), String(maxVal));
        }

        function computeClampedPair(rawMin, rawMax) {
            // Start with defaults when NaN
            let minVal = Number.isFinite(rawMin) ? Math.floor(rawMin) : minPriceDefault;
            let maxVal = Number.isFinite(rawMax) ? Math.ceil(rawMax) : maxPriceDefault;

            // Clamp to allowed bounds first
            minVal = clamp(minVal, minPriceDefault, maxPriceDefault);
            maxVal = clamp(maxVal, minPriceDefault, maxPriceDefault);

            // Ensure ordering (min <= max)
            if (minVal > maxVal) {
                // If min overshoots, pull min down to max
                minVal = maxVal;
            }

            return { minVal, maxVal };
        }

        // --- input: let users type anything; do NOT clamp here ---
        $priceInputs.off('.pf').on('input.pf', function () {
            const rawMin = parseNum($priceInputs.eq(0).val());
            const rawMax = parseNum($priceInputs.eq(1).val());

            // Just update the labels live if numbers are present, donâ€™t clamp/rerender range yet
            const liveMin = Number.isFinite(rawMin) ? Math.floor(rawMin) : minPriceDefault;
            const liveMax = Number.isFinite(rawMax) ? Math.ceil(rawMax) : maxPriceDefault;
            changePseudoElementContent(String(liveMin), String(liveMax));
        });

        // --- blur: clamp & apply filter when the user is done ---
        $priceInputs.off('blur.pf').on('blur.pf', function () {
            const rawMin = parseNum($priceInputs.eq(0).val());
            const rawMax = parseNum($priceInputs.eq(1).val());

            const { minVal, maxVal } = computeClampedPair(rawMin, rawMax);
            syncUI(minVal, maxVal);

            const $form = $(dapfforwc_FILTER.formSelector);
            handleFilterChange($form);
        });

    }


    /**
     * Scroll to products container
     */

    function scrollToProducts() {
        const $t = $(product_selector);
        if (!$t.length) return;
        const targetTop = $t.offset().top - dapfforwc_FILTER.autoScrollOffset;
        const current = window.scrollY || window.pageYOffset;
        if (Math.abs(current - targetTop) < 24) return; // already close
        $('html, body').stop(true).animate({ scrollTop: targetTop }, 300);
    }


    function applyFiltersFromUrl(filtersString) {
        // Check if we're using the new format with attribute types in permalinks
        const urlParams = new URLSearchParams(window.location.search);
        const useNewFormat = urlParams.get('filters') === '1';
        const $form = $(dapfforwc_FILTER.formSelector);

        const attrprefix = dapfforwc_seo_permalinks_options.dapfforwc_permalinks_prefix_options;

        if (!useNewFormat) {

            for (const [key, value] of urlParams.entries()) {
                if (key === 'title') {
                    $("input#plugincy-search-field").val(value);
                    break;
                }
            }

            const filterValues = filtersString.split(',').map(value => value.trim());
            if (filterValues[0] !== '') filterValues.forEach(value => {
                if ($(`input[value="${value}"]`).length) {
                    $(`input[value="${value}"]`).prop('checked', true);
                } else if ($(`select option[value="${value}"]`).length) {
                    $(`select option[value="${value}"]`).prop('selected', true);
                }
            });



            handleFilterChange($form);
            return;
        }

        // New implementation for attribute type permalinks
        // Process each parameter in the URL
        // Reverse map the prefixes to attribute names for lookup
        const prefixToAttribute = {};
        // Handle category and tag directly
        prefixToAttribute[attrprefix["product-category"] ?? 'cata'] = "product-category[]";
        prefixToAttribute[attrprefix.tag ?? 'tags'] = 'tag';
        prefixToAttribute[attrprefix.price ?? 'price'] = 'price';
        prefixToAttribute[attrprefix.rating ?? 'rating'] = 'rating';
        prefixToAttribute[attrprefix.brand ?? 'brand'] = 'rplurand';
        prefixToAttribute[attrprefix.author ?? 'authors'] = 'rpluthor';
        prefixToAttribute[attrprefix.stockStatus ?? 'stockStatus'] = 'rplutock_status';
        prefixToAttribute[attrprefix.saleStatus ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.saleStatus ?? 'saleStatus'] = 'rpn_sale';
        prefixToAttribute[attrprefix.min_length ?? 'min_length'] = 'min_length';
        prefixToAttribute[attrprefix.max_length ?? 'max_length'] = 'max_length';
        prefixToAttribute[attrprefix.sku ?? 'sku'] = 'sku';
        prefixToAttribute[attrprefix.discount ?? 'discount'] = 'discount';
        prefixToAttribute[attrprefix.date_filter ?? 'date'] = 'date_filter';

        // Handle all product attributes
        if (attrprefix.attribute) {
            for (const [attributeName, prefix] of Object.entries(attrprefix.attribute)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = attributeName;
                }
            }
        }
        if (attrprefix.custom) {
            for (const [customName, prefix] of Object.entries(attrprefix.custom)) {
                if (prefix) { // Only add if prefix is not empty
                    prefixToAttribute[prefix] = customName;
                }
            }
        }

        for (const [key, value] of urlParams.entries()) {
            if (key === 'title') {
                $("input#plugincy-search-field").val(value);
            }

            if (key === 'filters' || key === 'title') continue; // Skip the format flag and search parameter

            // Split comma-separated values
            const values = value.split(',').map(v => v.trim());

            // Find the attribute name this prefix corresponds to
            const attributeName = prefixToAttribute[key] ?? key;


            if (attributeName) {

                values.forEach(val => {
                    // Look for inputs that have name containing the attribute and value matching the value
                    const $inputs = $form.find(`input[name*="${attributeName}"][value="${val}"]`);
                    // Handle select elements
                    const $options = $form.find(`select[name*="${attributeName}"] option[value="${val}"]`);
                    const $inputtext = $form.find(`input[name*="${attributeName}"]`);
                    if ($inputs.length) {
                        $inputs.prop('checked', true);
                    }
                    else if ($options.length) {
                        $options.prop('selected', true);
                    }
                    // Handle price range specially if needed
                    else if (attributeName === 'price' && val.includes('-')) {
                        const [min, max] = val.split('-');
                        const $minInput = $form.find('input.dapfforwc-filters-range-min');
                        const $maxInput = $form.find('input.dapfforwc-filters-range-max');

                        if ($minInput.length && $maxInput.length) {
                            $minInput.val(min);
                            $maxInput.val(max);
                        }
                    } else if ($inputtext.length) {
                        $inputtext.val(value);
                    }
                });
            }
        }

        // Trigger filter change event to update the UI
        handleFilterChange($form);
    }


    /**
     * Transform standard filter URL to SEO-friendly URL format
     * @param {string} url - The original URL with standard filter parameters
     * @param {object} seoOptions - The SEO permalink configuration options
     * @returns {string} - The transformed SEO-friendly URL
     */
    function transformToSeoUrl(url, seoOptions) {
        if (!url || !seoOptions) {
            return url; // Return the original URL if no SEO options are provided
        }
        // Parse the current URL
        const urlObj = new URL(url);
        const searchParams = urlObj.searchParams;

        // Create new URLSearchParams for our SEO-friendly URL
        const seoParams = new URLSearchParams();
        seoParams.append('filters', '1'); // Add the filters=1 parameter

        // Prefixes config from SEO options
        const prefixes = seoOptions.dapfforwc_permalinks_prefix_options;

        // Process category parameters
        if (searchParams.has("product-category")) {
            // Get all category values and remove duplicates
            const categories = Array.from(new Set(searchParams.getAll("product-category")));
            if (categories.length > 0) {
                let catakey = (prefixes && prefixes["product-category"]);
                if (!catakey || catakey === "") {
                    catakey = "cata";
                }
                seoParams.append(catakey, categories.join(','));
            }
        }

        // Process tag parameters
        if (searchParams.has('tags')) {
            // Get all tag values and remove duplicates
            const tags = Array.from(new Set(searchParams.getAll('tags')));
            if (tags.length > 0) {
                let tagskey = (prefixes && prefixes["tag"]) ?? "tags";
                if (!tagskey || tagskey === "") {
                    tagskey = "tags";
                }
                seoParams.append(tagskey, tags.join(','));
            }
        }

        // process brands

        if (searchParams.has('rplurand')) {
            // Get all brand values and remove duplicates
            const brands = Array.from(new Set(searchParams.getAll('rplurand')));
            if (brands.length > 0) {
                let brandskey = (prefixes && prefixes["brand"]) ?? "brand";
                if (!brandskey || brandskey === "") {
                    brandskey = "brand";
                }
                seoParams.append(brandskey, brands.join(','));
            }
        }

        // process authors
        if (searchParams.has('rpluthor')) {
            // Get all author values and remove duplicates
            const authors = Array.from(new Set(searchParams.getAll('rpluthor')));
            if (authors.length > 0) {
                let authorskey = (prefixes && prefixes["author"]) ?? "authors";
                if (!authorskey || authorskey === "") {
                    authorskey = "authors";
                }
                seoParams.append(authorskey, authors.join(','));
            }
        }

        // process stock status
        if (searchParams.has('rplutock_status')) {
            // Get all stock_status values and remove duplicates
            const stock_status = Array.from(new Set(searchParams.getAll('rplutock_status')));
            if (stock_status.length > 0) {
                let stock_statuskey = (prefixes && prefixes["stock_status"]) ?? "stockStatus";
                if (!stock_statuskey || stock_statuskey === "") {
                    stock_statuskey = "stockStatus";
                }
                seoParams.append(stock_statuskey, stock_status.join(','));
            }
        }

        // process sale status
        if (searchParams.has('rpn_sale')) {
            // Get all sale_status values and remove duplicates
            const sale_status = Array.from(new Set(searchParams.getAll('rpn_sale')));
            if (sale_status.length > 0) {
                let sale_statuskey = (prefixes && prefixes["sale_status"]) ?? "saleStatus";
                if (!sale_statuskey || sale_statuskey === "") {
                    sale_statuskey = "saleStatus";
                }
                seoParams.append(sale_statuskey, sale_status.join(','));
            }
        }

        // Process rating parameters
        if (searchParams.has('rating')) {
            const ratings = searchParams.getAll('rating');
            if (ratings.length > 0) {
                let ratingKey = (prefixes && prefixes["rating"]) ?? "rating";
                if (!ratingKey || ratingKey === "") {
                    ratingKey = "rating";
                }
                seoParams.append(ratingKey, ratings.join(','));
            }
        }

        // Process price parameters
        if (searchParams.has('mn_price') || searchParams.has('mx_price')) {
            const currentpageminPrice = $('.range-min').attr('min') || '';
            const currentpagemaxPrice = $('.range-max').attr('max') || '';
            const minPrice = searchParams.get('mn_price') || '';
            const maxPrice = searchParams.get('mx_price') || '';

            if (
                (minPrice || maxPrice) && // at least one is set
                (minPrice >= currentpageminPrice && maxPrice <= currentpagemaxPrice) && // within range
                (minPrice !== currentpageminPrice || maxPrice !== currentpagemaxPrice) // at least one changed
            ) {
                let priceKey = (prefixes && prefixes.price) ?? "price";
                if (!priceKey || priceKey === "") {
                    priceKey = "price";
                }
                seoParams.append(priceKey, `${minPrice}-${maxPrice}`);
            }
        }

        // Process dimensions length parameters
        if (searchParams.has('min_length') || searchParams.has('max_length')) {
            const min_length = searchParams.get('min_length') || '';
            const max_length = searchParams.get('max_length') || '';
            if (min_length || max_length) {
                let lengthKey = (prefixes && prefixes.length) ?? "length";
                if (!lengthKey || lengthKey === "") {
                    lengthKey = "length";
                }
                seoParams.append(lengthKey, `${min_length}-${max_length}`);
            }
        }

        // Process dimensions width parameters
        if (searchParams.has('min_width') || searchParams.has('max_width')) {
            const min_width = searchParams.get('min_width') || '';
            const max_width = searchParams.get('max_width') || '';
            if (min_width || max_width) {
                let widthKey = (prefixes && prefixes.width) ?? "width";
                if (!widthKey || widthKey === "") {
                    widthKey = "width";
                }
                seoParams.append(widthKey, `${min_width}-${max_width}`);
            }
        }

        // Process dimensions height parameters
        if (searchParams.has('min_height') || searchParams.has('max_height')) {
            const min_height = searchParams.get('min_height') || '';
            const max_height = searchParams.get('max_height') || '';
            if (min_height || max_height) {
                let heightKey = (prefixes && prefixes.height) ?? "height";
                if (!heightKey || heightKey === "") {
                    heightKey = "height";
                }
                seoParams.append(heightKey, `${min_height}-${max_height}`);
            }
        }

        // Process dimensions weight parameters
        if (searchParams.has('min_weight') || searchParams.has('max_weight')) {
            const min_weight = searchParams.get('min_weight') || '';
            const max_weight = searchParams.get('max_weight') || '';
            if (min_weight || max_weight) {
                let weightKey = (prefixes && prefixes.weight) ?? "weight";
                if (!weightKey || weightKey === "") {
                    weightKey = "weight";
                }
                seoParams.append(weightKey, `${min_weight}-${max_weight}`);
            }
        }

        // Process search parameter
        if (searchParams.has('plugincy_search') && searchParams.get('plugincy_search') !== '') {
            seoParams.append('title', searchParams.get('plugincy_search'));
        }
        if (searchParams.has('sku') && searchParams.get('sku') !== '') {
            seoParams.append('sku', searchParams.get('sku'));
        }
        if (searchParams.has('discount') && searchParams.get('discount') !== '') {
            seoParams.append('discount', searchParams.get('discount'));
        }
        if (searchParams.has('date_filter') && searchParams.get('date_filter') !== '') {
            seoParams.append('date', searchParams.get('date_filter'));
        }

        // Process attribute parameters
        const attributeParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an attribute parameter
            if (key.startsWith('rplugpa_') && value !== '') {
                // Extract attribute name, e.g., 'rplugpa_brand' -> 'brand'
                const attributeName = key.replace('rplugpa_', '');

                if (!attributeParams[attributeName]) {
                    attributeParams[attributeName] = [];
                }
                // Only add if not already present
                if (!attributeParams[attributeName].includes(value)) {
                    attributeParams[attributeName].push(value);
                }
            }
        }

        // Add attribute parameters with their SEO prefix
        for (const [attributeName, values] of Object.entries(attributeParams)) {
            // Use prefix from config if available, otherwise use attributeName as the key
            let prefix = (prefixes && prefixes.attribute && prefixes.attribute[attributeName])
                ? prefixes.attribute[attributeName]
                : attributeName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Process custom parameters
        const customParams = {};
        for (const [key, value] of searchParams.entries()) {
            // Check if this is an custom parameter
            if (key.startsWith('rplugcusf_') && value !== '') {
                // Extract custom name, e.g., 'rplugcusf__brand' -> 'brand'
                const customName = key.replace('rplugcusf_', '');

                if (!customParams[customName]) {
                    customParams[customName] = [];
                }
                // Only add if not already present
                if (!customParams[customName].includes(value)) {
                    customParams[customName].push(value);
                }
            }
        }

        // Add custom parameters with their SEO prefix
        for (const [customName, values] of Object.entries(customParams)) {
            // Use prefix from config if available, otherwise use customName as the key
            let prefix = (prefixes && prefixes.custom && prefixes.custom[customName])
                ? prefixes.custom[customName]
                : customName;
            if (prefix && prefix !== "") {
                seoParams.append(prefix, values.join(','));
            }
        }

        // Build the new URL
        const baseUrl = urlObj.origin + urlObj.pathname;
        const seoQueryString = (seoParams.toString() === "filters=1") ? '' : seoParams.toString();

        return baseUrl + (seoQueryString ? '?' + seoQueryString : '');
    }

    // Initialize on document ready
    $(document).ready(function () {
        initProductFilter();
        initPriceRangeInputs();
    });

    // Expose public API
    window.dapfforwc_FILTER_API = {
        refresh: function () {
            handleFilterChange($(dapfforwc_FILTER.formSelector));
        },
        reset: function () {
            const $form = $(dapfforwc_FILTER.formSelector);
            $form.find('input[type="checkbox"], input[type="radio"]').prop('checked', false);
            $form.find('select').prop('selectedIndex', 0);
            $form.find('input[type="text"], input[type="search"]').val('');

            // Reset price range sliders
            const $minRange = $form.find('.range-min');
            const $maxRange = $form.find('.range-max');

            if ($minRange.length && $maxRange.length) {
                $minRange.val($minRange.attr('min'));
                $maxRange.val($maxRange.attr('max'));
                updatePriceDisplay($minRange);
                updatePriceDisplay($maxRange);
            }

            handleFilterChange($form);
        }
    };

})(jQuery);

// cateogry hide & show manage for herichical
jQuery(document).ready(function ($) {
    $(document).on('click', '.show-sub-cata', function (event) {
        event.preventDefault();
        const $btn = $(this);

        // Try multiple strategies to find the child categories container
        let $childCategories = $btn.closest('div').next('.child-categories');
        if (!$childCategories.length) $childCategories = $btn.closest('div').siblings('.child-categories').first();
        if (!$childCategories.length) $childCategories = $btn.closest('div').find('.child-categories').first();

        if (!$childCategories.length) return;

        // Use a duration and a normal function callback (or captured $btn) to update the button text reliably
        $childCategories.slideToggle(200, function () {
            $btn.text($childCategories.is(':visible') ? '-' : '+');
        });
    });
});










jQuery(document).ready(function ($) {

    function initializeSelect2() {
        $(".select2.filter-select").each(function () {
            if ($(this).hasClass('select2-hidden-accessible')) return;
            $(this).select2({ placeholder: "Select Options", allowClear: true });
        });
        $("select.select2_classic").each(function () {
            if ($(this).hasClass('select2-hidden-accessible')) return;
            $(this).select2({ placeholder: "Select Options", allowClear: true });
        });
    }

    // Initial initialization
    initializeSelect2();



    $(document).ajaxComplete(function () {
        // Check if new options are added before reinitializing
        if ($(".select2.filter-select").find("option").length > 0) {
            initializeSelect2();
        }
    });
    function initializeCollapsible() {
        $(".title").each(function () {
            const $this = $(this);
            const $form = $("form#product-filter");
            let $form_layout = "sidebar";
            if ($(window).width() > 768) {
                if ($form) {
                    $form_layout = $form.data("layout") || "sidebar";
                }
            }
            const $items = $this.parent().children().not(".title");

            if ($form.length && $form.data("mobile-style") === "style_1" && $(window).width() <= 768) {
                $items.addClass("dapfforwc-hidden-important");
                $form.removeClass("plugincy_layout_top_view");
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }
            // Hide items initially if the title has a specific class
            else if ($this.hasClass("plugincy_collapsable_minimize_initial") || $form_layout === "top_view") {
                $items.addClass("dapfforwc-hidden-important");
                $form.removeClass("plugincy_layout_top_view");
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });

            }

            else if ($this.hasClass("plugincy_collapsable_no_arrow")) {
                $this.off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }

            else if ($this.hasClass("plugincy_collapsable_arrow")) {
                $this.find(".collaps").off("click").on("click", function () {
                    $this.find("svg").toggleClass("rotated");
                    // $items.slideToggle(300);
                    $items.toggleClass("dapfforwc-hidden-important", 300);
                });
            }

        });
    }

    // Initialize collapsible elements
    initializeCollapsible();

    // Reinitialize collapsibles after AJAX content is loaded
    $(document).ajaxComplete(function () {
        initializeCollapsible();
    });

    window.re_initSelect2_Collaps = function () {
        initializeSelect2();
        initializeCollapsible();
    };
});
